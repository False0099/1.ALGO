小菜鸡今天在打某款 ingteresting 的游戏。每当他通关游戏的某一关卡，该关卡的累计得分值就会增加 $\mathrm{x}$。由于 $\mathrm{x}$ 是一个**正实数**，因此存在累计得分值不为整数的情况。但是该游戏的累计得分值只能显示整数部分，于是小菜鸡突发奇想，就有了下面的题。

  

已知小菜鸡共通关该关卡 $\mathrm{n}$ 次，依次给出小菜鸡每次通过关卡后，该关卡显示的累计得分值（即累计得分值的整数部分），请求出单次通过该关卡所增加的得分值 $\mathrm{x}$ **最大**为多少？

## 输入：
第一行给出一个整数 $\mathrm{n}(1\le \mathrm{n} \le 10^{6})$。  

  

下一行共 $\mathrm{n}$ 个整数，第 $\mathrm{i}$ 个整数 $\mathrm{a_i} (0\le \mathrm{a_i} \le 10^{9})$ 表示小菜鸡通过该关卡第 $\mathrm{i}$ 次时所显示的累计得分值。

  

特殊地，可以认为在刚开始时，关卡的累计得分值为 $0$ 。

  

输入数据保证存在至少一个合法解。

## 输出：
输出一个实数，表示 $\mathrm{x}$ 可取到的最大值。你需要保证输出结果与答案**绝对误差**不超过 $10^{-4}$。

## 样例：
输入

```
5
0 0 0 0 0
```

输出


 0.2000000000

样例一中，每次通关所显示的总分值都是 $0$ ，说明总得分值其真实值所处范围为 $[0,1)$。因此，单次通关可能增加的得分值最大应为 $0.1999999.....$ ，保留 $10$ 位小数后应为 $0.2000000000$

## 题解
我们这一题错误的思路是：求出我们所有间隔的和的平均值是多少，这样，如果我们有循环，那么我们就不能解决我们的问题。

我们的思路是，对于每一个位置，我们都可以计算出他是更新了多少次到达这一个位置的，然后我们每一次只需要求出我们单词更新的可能最大值即可。这里，我们运用了我们的公式 `dx=(a[i]+0.999999999)/i`。

```js
#include <bits/stdc++.h>
using namespace std;
#define LF(x) fixed<<setprecision(x)
#define ios ios::sync_with_stdio(false)
#define endl '\n'
typedef long long ll;
const int N = 1e6 + 10, M = 1e9 + 8;
const int mod = 1e9 + 7;
// setw(n) setfill('0') ## Add leading '0'
//===================================================
int dp[N];
//===================================================

//===================================================
int main()
{
    int n;
    double res = M;
    ios;
    cin >> n;
    for(int i = 1; i <= n; i ++)
    {
        cin >> dp[i];
        res = fmin(1.0 * (dp[i] + 1) / i, res);
    }

    cout << LF(10) << res << endl;

    return 0;
}
```