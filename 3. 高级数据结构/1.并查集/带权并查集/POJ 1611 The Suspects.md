2019冠状病毒病（英语：Coronavirus disease 2019，缩写：COVID-19 ），是一种由严重急性呼吸系统综合症冠状病毒2型（缩写：SARS-CoV-2）引发的传染病。此病在全球各国大规模爆发并急速扩散，成为人类历史上致死人数最多的流行病之一。很显然，目前最好的办法就是将所有可能的患者都隔离起来。现在某高校正在排查可能的患者，这个高校中有多个社团，每个社团经常进行内部交流，一名学生可能会加入多个社团。学校认为一旦某个社团里出现一名可疑患者，这整个社团的学生都被视为是可能的患者。现在请你帮忙找到这所学校的所有可能的患者。

## Input

输入文件包含多组数据。

对于每组测试数据：

第一行为两个整数n和m, 其中n是学生的数量, m是社团的数量。0 < n <= 30000，0 <= m <= 500。

接下来m行，每一行有一个整数k，代表社团中学生的数量。之后，有k个整数代表这个社团里每个学生的编号（在0到n-1之间）。

n = m = 0表示输入结束，不需要处理。

## Output

对于每组测试数据， 输出可能的患者数目。

## Sample Input

100 4
2 1 2
6 11 13 50 12 14
2 0 1
2 99 2
200 2
1 5
6 5 6 7 8 9 10
1 0
0 0

## Sample Output

4
1
1

## 题解
我们对于每一个并查集，要把我们的权值合并，因此这一题是我们标准的带权并查集。
在写带权并查集时，我们要注意：我们的权值合并，**只应该在我们的并查集合并时实现**。并且，我们（**每一次的合并，要确定我们的方向**），必须都由我们的一个合并到另一个，这里，我们可以采用我们的高度判定，我们由低的合并到高的，也可以采用**启发式合并**，由少的合并到多的。

```cpp
#include <stdio.h>
const int maxn = 3e4+10;
int f[maxn], h[maxn], num[maxn], n, m, k, x, y;
void Init() {
	for(int i=0; i<n; i++) {
		f[i] = i;
		h[i] = 0;
		num[i] = 1;
	}
}
int Find(int i) {
	return f[i]==i ? f[i] : f[i]=Find(f[i]);
}
void merge(int a, int b) {
	int fa = Find(a);
	int fb = Find(b);
	if(fa != fb) {
		if(h[fb]>h[fa]) {//启发式合并
			f[fa] = fb;			 //把a的根指向更高的b的根 
			num[fb] += num[fa];  //把a所在团队的数目加到 b所在团队中 
		}
		if(h[fb]<=h[fa]){//启发式合并
			f[fb] = fa;			 //把b的根指向a的根 
			num[fa] += num[fb];  //把b所在团队的数目加到 a所在团队中 
			if(h[fa] == h[fb]) h[fa]++;
		}
	}
}

int main(void) {
	while(scanf("%d %d", &n, &m) != EOF) {
		if(n==0 && m==0) return 0;  //直到 n与 m同时为 0时，结束 
		Init();  //初始化 
		while(m--) {
			scanf("%d", &k);
			scanf("%d", &x);  //先输入第一个学生编号 
			for(int i=2; i<=k; i++) {
				scanf("%d", &y);  //输入接下来的学生编号 
				merge(x, y);  //使后来的学生都进入第一个学生所在的团队 
			}
		}
		printf("%d\n", num[Find(0)]);
		//找到编号为 0的初始学生的根节点 
		//其对应的数目即为所有患者的数目 
	}
}

```