## 题目描述
动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B， B 吃 C，C 吃 A。  
现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。  
有人用两种说法对这N个动物所构成的食物链关系进行描述：  
第一种说法是"1 X Y"，表示X和Y是同类。  
第二种说法是"2 X Y"，表示X吃Y。  
此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。  
1） 当前的话与前面的某些真的话冲突，就是假话；  
2） 当前的话中X或Y比N大，就是假话；  
3） 当前的话表示X吃X，就是假话。  
你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。

## 输入格式

第一行是两个整数 N 和 K，以一个空格分隔。  
以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。  
若D=1，则表示X和Y是同类。  
若D=2，则表示X吃Y。

## 输出格式

只有一个整数，表示假话的数目

## 样例 #1

### 样例输入 #1

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5

```

### 样例输出 #1

```
3
```


## 题解
这一题，也是带权并查集的模板题目之一，但不同的是，这一题我们会选择用的权是能够表示物种之间关系的，同时，我们发现，并查集中权的合并服从以下公式（a->c）=((a->b)+(b->c))%3

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=50005;
int s[N];
int d[N];
int ans;
int n;
void init(){
	for(int i=0;i<n;i++){
		s[i]=i;
		d[i]=0;
	}
}
int find_set(int x){
	if(x!=s[x]){
		int t=s[x];
		s[x]=find_set(s[x]);
		d[x]=(d[x]+d[t])%3;//食物链 
	}
	return s[x];
}
int merge_set(int x,int y,int relation){
	int rootx=find_set(x);
	int rooty=find_set(y);
	if(rootx==rooty){
		if((relation-1)!=((d[x]-d[y]+3)%3)){
			ans++;
		}
	}
	else{
		s[rootx]=rooty;
		d[rootx]=(d[y]-d[x]+relation-1)%3;
	}
} 
```