## 题目描述
N 个小朋友（编号为 0,1,2,…,N−1）一起玩石头剪子布游戏。

其中一人为裁判，其余的人被分为三个组（有可能有一些组是空的），第一个组的小朋友只能出石头，第二个组的小朋友只能出剪子，第三个组的小朋友只能出布，而裁判可以使用任意手势。

你不知道谁是裁判，也不知道小朋友们是怎么分组的。

然后，孩子们开始玩游戏，游戏一共进行 M 轮，每轮从 N 个小朋友中选出两个小朋友进行猜拳。

你将被告知两个小朋友猜拳的胜负结果，但是你不会被告知两个小朋友具体使用了哪种手势。

比赛结束后，你能根据这些结果推断出裁判是谁吗？

如果可以的话，你最早在第几轮可以找到裁判

## 输入格式
输入可能包含多组测试用例

每组测试用例第一行包含两个整数 N 和 M。

接下来 M 行，每行包含两个整数 a,b，中间夹着一个符号，表示一轮猜拳的结果

两个整数为小朋友我的编号，a<b 表示 a 赢了 b，a=b 表示平手，a>b 表示 a 输给了 b


## 输出格式

每组测试用例输出一行结果，如果找到裁判，且只能有一个人是裁判，则输出裁判编号和确定轮数。

如果找到裁判，但裁判的人选多于 11 个，则输出 `Can not determine`。

如果根据输入推断的结果是必须没有裁判或者必须有多个裁判，则输出 `Impossible`。

具体格式可参考样例。

## 样例 #1

### 样例输入 #1

```
3 3
0<1
1<2
2<0
3 5
0<1
0>1
1<2
1>2
0<2
4 4
0<1
0>1
2<3
2>3
1 0
```

### 样例输出 #1

```
Can not determine
Player 1 can be determined to be the judge after 4 lines
Impossible
Player 0 can be determined to be the judge after 0 lines
```

## 提示
这一题是关于扩展域并查集的，将并查集的状态由基本的：几个元素属于朋友，则放入并查集，扩展为更多状态。主要用于题目中明显给出若干个人之间的关系，比如敌对关系或是派别关系，然后**求出可以使其互不干扰会有多少对关系**。
我们扩展域并查集中通常会设定 $k*n$ 个集合，其中第 $i$ 个表示 $i$ 的所有天敌，第 $i+n$ 个表示 i 的所有食物，第 $i+2n$ 表示 i 的所有同类。
然后每次我们给定一个关系时，按照我们的规则维护即可。



## 题解
我们设置并查集，在一个并查集表示我们可以采用同一种手势，


这一题和前面的并查集不同的是，我们这一题**并没有先后顺序**，所以我们发生冲突时，**可以是前面矛盾，也可以是后面矛盾**。

所以，我们这一题需要特殊的技巧。我们首先设置 $o_{a},o_{b},o_{c}$ 表示语句中第 o 个对象是天敌类、食物类、同类，$I_{a},I_{b},I_{c}$ 表示第二个对象是天敌、食物、同类。**如果 0 赢了，那么我们就合并 $O_{a},I_{b}$ **。

假设我们在添加关系时发现了**重复连边**，那么说明两个人之中至少有一个人是**裁判**，但我们**不能判断谁是**。

于是，我们需要枚举裁判，我们可以**枚举谁是裁判**。并且考虑除了他参加的比赛以外，其他是不会产生冲突的。
如果没有冲突，那就说明，这个枚举是合理的。否则就说明 x 不能是裁判

对于是否存在我们的裁判，我们可以由，x 不能是裁判这一个命题出现了 n-1 次，就说明我们只有一个裁判。

如果没有裁判，那么我们的 x 不能是裁判就会出现 N 次。


由此，我们可以得到所有可能的裁判人选，并根据人数来判定是否有冲突即可。



## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int N,M;
int p[MAXN],q[MAXN][3];
int findR(int x){
	if(p[x]==x) return x;
	else return p[x]=findR(p[x]); 
}
void merge(int u,int v){
	int ru=findR(u);
	int rv=findR(v);
	if(ru==rv) return;
	p[ru]=rv;
}
bool chk(int x){
	int r1=finR(x),r2=findR(x+N),r3=findR(x+2*N);
	if(r1==r2||r2==r3||r1==r3) return 1;
	else return 0;
}
int last;
bool solve(int x){
	for(int i=1;i<=3*N;i++){
		p[i]=i;
	}
	int u,v,op;
	int cnt=0,ans=0;
	for(int i=1;i<=M;i++){
		op=q[i][0];u=q[i][1];v=q[i][2];
		if(u==x||v==x) continue;//删除和自己相关的所有对局
		if(op=='='){
			merge(u,v);
			merge(u+N,v+N);
			merge(u+2*N,v+2*N);
		}else{
			if(op=='<'){
				swap(u,v);
			}
			merge(u,v+N);
			merge(u+N,v+2*N);
			merge(u+2*N,v);
		}
		if(chk(u)||chk(v)){
			last=max(last,i);
			return 0;
		}
	}
}
int main(){
	while(scanf("%d%d",&N,&M)!=EOF){
		int u,v;
		char op;
		for(int i=1;i<=M;i++){
			scanf("%d%c%d",&q[i][1],&q[i][0],&q[i][2]);
			++q[i][1];
			++q[i][2];
		}
		int cnt=0,ans=0;
		last=0;
		for(int i=1;i<=N;i++){
			if(solve(i)){
				++cnt;
				ans=i;
			}
		}
	}
} 

```