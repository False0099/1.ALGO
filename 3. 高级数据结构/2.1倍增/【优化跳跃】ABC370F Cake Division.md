# [ABC 370 F] Cake Division

## 题面翻译

### 问题描述

有一个圆形蛋糕，通过切割线被分成了 $N$ 块。每条切割线是一条从圆心连接到圆弧上某点的线段。

这些块和切割线按顺时针方向编号为 $1, 2, \ldots, N$，其中第 $i$ 块的质量为 $A_i$。第 $1$ 块也被称作第 $N + 1$ 块。

切割线 $i$ 位于第 $i$ 块和第 $i + 1$ 块之间，它们按照如下顺序排列：第 $1$ 块，切割线 $1$，第 $2$ 块，切割线 $2$，$\ldots$，第 $N$ 块，切割线 $N$。

我们希望在以下条件下将这个蛋糕分给 $K$ 个人。令 $w_i$ 表示第 $i$ 个人所得到的蛋糕块质量之和。

- 每个人分得一个或多个**连续**的蛋糕块。
- 没有未被分配的蛋糕块。
- 在上述两个条件的基础上，使得 $\min(w_1, w_2, \ldots, w_K)$ 的值最大化。

找到满足条件的分配方案中 $\min(w_1, w_2, \ldots, w_K)$ 的值，以及在满足条件的所有分配方案中，从未被切割过的切割线条数。这里，如果第 $i$ 块和第 $i + 1$ 块被分配给了不同的人，则认为切割线 $i$ 被切割了。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc370/tasks/abc370_f

円形のケーキがあり、ケーキは切り目によって $ N $ 個のピースに分けられています。各切り目は円の中心と円弧上の点を結ぶ線分です。

ピースおよび切り目には時計回りに $ 1,\ 2,\ \ldots,\ N $ の番号が付けられており、ピース $ i $ の質量は $ A_i $ です。ピース $ 1 $ をピース $ N\ +\ 1 $ とも呼ぶこととします。

切り目 $ i $ は ピース $ i $ とピース $ i\ +\ 1 $ の間にあり、ピース $ 1 $, 切り目 $ 1 $, ピース $ 2 $, 切り目 $ 2 $, $ \ldots $, ピース $ N $, 切り目 $ N $ の順に時計回りに並んでいます。

このケーキを以下の条件を満たすように $ K $ 人に分けようとしています。ただし、$ i $ 番目の人が受け取るピースの質量の合計を $ w_i $ とします。

- すべての人が $ 1 $ つ以上の**連続する**ピースを受け取る
- 誰も受け取らないピースは存在しない
- 上の $ 2 $ つの条件を満たすという条件下で $ \min (w_1,\ w_2,\ \ldots,\ w_K) $ が最大になるようにする
 
条件を満たす分け方における $ \min (w_1,\ w_2,\ \ldots,\ w_K) $ の値および条件を満たすすべての分け方で切られることのない切り目の個数を求めてください。ただし、切り目 $ i $ が切られるとは、ピース $ i $ とピース $ i\ +\ 1 $ が異なる人に分けられることを指します。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K $ $ A_1 $ $ A_2 $ $ \ldots $ $ A_N $

## 输出格式

条件を満たす分け方における $ \min (w_1,\ w_2,\ \ldots,\ w_K) $ の値を $ x $、切られることのない切り目の個数を $ y $ として、$ x $ と $ y $ をこの順に空白区切りで出力せよ。

## 样例 #1

### 样例输入 #1

```
5 2
3 6 8 6 4
```

### 样例输出 #1

```
13 1
```

## 样例 #2

### 样例输入 #2

```
6 3
4 7 11 3 9 2
```

### 样例输出 #2

```
11 1
```

## 样例 #3

### 样例输入 #3

```
10 3
2 9 8 1 7 9 1 3 5 8
```

### 样例输出 #3

```
17 4
```

## 提示

### 制約

- $ 2\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^4 $
- 入力される値はすべて整数
 
### Sample Explanation 1

以下の分け方が条件を満たします。 - 一方の人にピース $ 2,\ 3 $ を渡し、もう一方の人にピース $ 4,\ 5,\ 1 $ を渡す。ピース $ 2,\ 3 $ の質量の合計は $ 14 $、ピース $ 4,\ 5,\ 1 $ の質量の合計は $ 13 $ である。 - 一方の人にピース $ 3,\ 4 $ を渡し、もう一方の人にピース $ 5,\ 1,\ 2 $ を渡す。ピース $ 3,\ 4 $ の質量の合計は $ 14 $、ピース $ 5,\ 1,\ 2 $ の質量の合計は $ 13 $ である。条件を満たす分け方における $ \min (w_1,\ w_2) $ の値は $ 13 $ であり、どちらの分け方でも切られない切り目は切り目 $ 5 $ の $ 1 $ つです。

## 题解
本题，我们显然可以通过我们的二分求出我们的答案，因为我们是最小化我们的最大值。但是我们注意到这是一个**环形，那么我们应该怎么去 check 呢？**，我们首先注意到，我们对于环形的一个 trick 是破坏成链。

然后我们考虑怎么找到我们能够分割的段数，一个思路是贪心，我们枚举我们从 i 位置开始，要跳多少段，才能到达我们的最终的位置。我们对于这种东西，可以通过我们的预处理跳一跳得到。我们 check 就只需要检查，我们**跳 K 次是否会出界**即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e5, maxn = 2e9, M = 17;
int n, k;
LL a[(N << 1) + 5];
int nxt[M + 1][(N << 1) + 5];
bool check(int mid) {
	for (int i = 1, j = 1; i <= n << 1; i++) {
		while (j < n << 1 && a[j] - a[i - 1] < mid){
            j++;
        }   
		nxt[0][i] = j + 1;
	}
	nxt[0][n << 1 | 1] = n << 1 | 1;
    for (int i = 1; i <= M; i++)
		for (int j = 1; j <= (n << 1 | 1); j++)
			nxt[i][j] = nxt[i - 1][nxt[i - 1][j]];
	for (int i = 1; i <= n; i++) {
		int now = i;
		for (int j = M; j >= 0; j--)
			if (k >> j & 1) now = nxt[j][now];
		if (now <= n + i) return true;
	}
	return false;
}
int binary() {
	int l = 1, r = maxn;
	while (l < r) {
		int mid = (LL)l + r + 1 >> 1;
		check(mid) ? l = mid : r = mid - 1;
	}
	return l;
}
int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		a[n + i] = a[i];
	}
	for (int i = 1; i <= n << 1; i++)
		a[i] += a[i - 1];
	int ans = binary();
	printf("%d ", ans);
	for (int i = 1, j = 1; i <= n << 1; i++) {
		while (j < n << 1 && a[j] - a[i - 1] < ans) j++;
		nxt[0][i] = j + 1;
	}
	nxt[0][n << 1 | 1] = n << 1 | 1;
	for (int i = 1; i <= M; i++)
		for (int j = 1; j <= (n << 1 | 1); j++)
			nxt[i][j] = nxt[i - 1][nxt[i - 1][j]];
	ans = 0;
	for (int i = 1; i <= n; i++) {
		int now = i;
		for (int j = M; j >= 0; j--)
			if (k >> j & 1) now = nxt[j][now];
		ans += now > n + i;
	}
	printf("%d\n", ans);
	return 0;
}
```