# [PKUSC 2018] 星际穿越

## 题目描述

有 $n$ 个星球，它们的编号是 1 到 $n$，它们坐落在同一个星系内，这个星系可以抽象为一条数轴，每个星球都是数轴上的一个点，特别地，编号为 $i$ 的星球的坐标是 $i$。

一开始，由于科技上的原因，这 $n$ 个星球的居民之间无法进行交流，因此他们也不知道彼此的存在。现在，这些星球独立发展出了星际穿越与星际交流的工具。对于第 $i$ 个星球，他通过发射强力信号，成功地与编号在 $[l_i,i-1]$ 的所有星球取得了联系 (编号为 1 的星球没有发出任何信号)，取得联系的两个星球会建立 **双向** 的传送门，对于建立了传送门的两个星球 $u,v$，$u$ 上的居民可以花费 1 单位时间传送到 $v$，$v$ 上的居民也可以花费 1 单位时间传送到 $u$ ，我们用 $dist(x,y)$ 表示从编号为 $x$ 的星球出发，通过一系列星球间的传送门，传送到编号为 $y$ 的星球最少需要花费的时间。

现在有 $q$ 个星际商人，第 $i$ 个商人初始所在的位置是 $x_i$, 他的目的地是 $[l_i,r_i]$ 中的其中一个星球，保证 $l_i<r_i<x_i$ 。他会在这些星球中等概率挑选一个星球 $y$ (每个星球都有一样的概率被选中作为目的地)，然后通过一系列星球的传送门，**花费最少的时间**到达星球 $y$ 。商人想知道他花费的期望时间是多少？也就是计算 $\frac{1}{r_i-l_i+1}{\sum_{y=l_i}^{r_i}{dist(x_i,y)}}$ 。

## 输入格式

第一行一个正整数 $n$ ，表示星球的个数。

第二行 $n-1$ 个正整数，第 $i$ 个正整数为  $l_{i+1}$ ，表示编号在 $[l_{i+1},i]$ 区间内所有星球已经与编号为 $i+1$ 的星球取得了联系，并且可以通过花费 1 单位进行彼此的传输。保证 $l_{i+1}\leq i$

第三行一个正整数 $q$ ，表示询问组数。

接下来 $q$ 行，每行三个数字 $l_i,r_i,x_i$ ，表示在 $[l_i,r_i]$ 这个区间中等概率选择一个星球 $y$，$dist(x_i,y)$ 的期望。保证 $l_i<r_i<x_i$

## 输出格式

对于每组询问，注意到答案必然是一个有理数，因此以 $p/q$ 的格式输出这个有理数，要求 $\gcd(p,q)=1$ 。

如果答案为整数 $m$ ，输出 $m/1$ 。

## 样例 #1

### 样例输入 #1

```
7
1 1 2 1 4 6
5
3 4 6
1 5 7
1 2 4
1 2 6
1 3 5
```

### 样例输出 #1

```
3/2
13/5
3/2
2/1
1/1
```

## 提示

样例对应的无向图如下：![ex](https://cdn.luogu.com.cn/upload/pic/63831.png)

对于 $20\%$ 的数据，满足 $n \leq 100$。

对于另 $25\%$ 的数据，满足 $n\leq 2000$

对于另 $25\%$ 的数据，满足 $n\leq 5000$

对于 $100\%$ 的数据，满足 $n,q\leq 3\times 10^5$

## 题解
我们可以把每一个强力信号，看成是一个线段，我们可以从线段的起点到达线段内的任何一个点，这个问题就变为了**区间覆盖**问题，也就可以**考虑使用 ST 表**，于是，我们就可以求出我们从某一点 $i$ 出发，到达目的地 $j$ 所花费的最小代价 k。

我们思考这样一个问题，我们从某一个点开始跳，可以跳到哪里呢？我们的最左端一定是我们的 $l_{x}$,但我们能跳到的最大的点是哪里呢？答案是**满足 $l_{k}\leq x(k>x)$ 的 k 的最大值**。那么我们跳两次呢？我们此时能达到的最小点就变成了 $\min_{i=lx}^n l_{i}$。依次类推，我们每一次向左跳所能到达的点，就是我们这个**区间范围内每一个点所能到达的最左边的点的最小值**!

这样，我们就能够使用倍增优化了！设 $f_{i,0}$ 表示我们从 i 开始，向左边跳 $2^k$ 次所能到达的最左端。 $\min_{k-i}^{n}l_{k}$, $f_{i,j}=\min_{k=f_{i,j-1}}^nl_{k}$，我们的转移就可以写出 $f[i][j]=min(f[f[i][j-1]][j-1])$,我们的 $$g[i][j]=g[i][j-1]+g[f[i][j-1]][j-1]+2^{j-1}(f[i][j-1]-f[i][j])$$



同时我们采用一个数组 $sum[i][j]$ 表示我们**从 i 到 $j-i$ 的所有点的最小步数之和**。首先，我们发现，如果我们求出了 $sum[i][j]$,那么我们的答案就是 $\frac{sum[x][l]-sum[x][r+1]}{r-l+1}$。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=300010;
int n,m;
int l[N];
int pre[N][20],sum[N][20];
inline void pre_work()
{
    pre[n][0]=l[n],sum[n][0]=n-l[n];
    for (int i=n-1;i>=2;--i)
    {
        pre[i][0]=min(pre[i+1][0],l[i]);//处理出我们走一步能达到的最左端。
        sum[i][0]=i-pre[i][0];
    }
    for (int i=1;i<20;++i)
    {
        for (int j=(1<<i);j<=n;++j)
        {
            pre[j][i]=pre[pre[j][i-1]][i-1];
            sum[j][i]=sum[j][i-1]+sum[pre[j][i-1]][i-1]+(1<<(i-1))*(pre[j][i-1]-pre[j][i]);//代表我们这个区间的和
        }
    }
}
inline int calc(int aim,int x)
{
    if (aim>=l[x]) return x-aim;//特判一步之内就能到的
    //特殊处理第一步
    int step=1,ans=x-l[x];
    x=l[x];
    for (int i=19;i>=0;--i)
    {
        if (pre[x][i]>=aim)
        {
            ans+=step*(x-pre[x][i])+sum[x][i];
            //对于区间[x,pre[x][i]]内的任一节点y，它对答案的贡献就是dist(x,y)+dist(start,x)(等于step)，start表示初始的x。那么每一个加起来就是上面的式子
            step+=(1<<i);
            x=pre[x][i];
        }
    }
    if (x>aim) ans+=step*(x-aim)+x-aim;
    return ans;
}
int gcd(int a,int b)
{
    return b>0?gcd(b,a%b):a;
}
int main()
{
    scanf("%d",&n);
    for (int i=2;i<=n;++i) scanf("%d",&l[i]);
    pre_work();
    scanf("%d",&m);
    while (m--)
    {
       int L,R,x;
       scanf("%d%d%d",&L,&R,&x);
       int dist=calc(L,x)-calc(R+1,x);
       int g=gcd(dist,R-L+1);//分数处理
       printf("%d/%d\n",dist/g,(R-L+1)/g);
    }
    return 0;
}
```