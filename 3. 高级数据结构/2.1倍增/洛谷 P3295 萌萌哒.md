# [SCOI 2016] 萌萌哒

## 题目描述

一个长度为 $n$ 的大数，用 $S_1S_2S_3 \cdots S_n$ 表示，其中 $S_i$ 表示数的第 $i$ 位, $S_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串 $S_{l_1}S_{l_1+1}S_{l_1+2} \cdots S_{r_1}$ 与 $S_{l_2}S_{l_2+1}S_{l_2+2} \cdots S_{r_2}$ 完全相同。

比如 $n=6$ 时，某限制条件 $l_1=1,r_1=3,l_2=4,r_2=6$ ，那么 $123123$，$351351$ 均满足条件，但是 $12012$，$131141$ 不满足条件，前者数的长度不为 $6$ ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。

## 输入格式

第一行两个数 n 和 m，分别表示大数的长度，以及限制条件的个数。

接下来 m 行，对于第 i 行, 有 4 个数 li 1，ri 1，li 2，ri 2，分别表示该限制条件对应的两个区间。

$1\le n\le 10^5$，$1\le m\le 10^5$ ，$ 1\le li 1, ri 1, li 2, ri 2 \le n $ ；并且保证 $ ri 1-li 1=ri 2-li 2 $ 。

## 输出格式

一个数，表示满足所有条件且长度为 n 的大数的个数，答案可能很大，因此输出答案模 $ 10^9+7 $ 的结果即可。

## 样例 #1

### 样例输入 #1

```
4 2
1 2 3 4
3 3 3 3
```

### 样例输出 #1

```
90
```


## 题解
我们这一题首先可以想到，**用一个并查集统计哪些数字之间存在有包含关系，然后再在最后确定所有“自由”数字的数目，再用组合数的方式计算出最后的答案**但这么做，我们的复杂度为 $o(n^2\log n)$ 可能会超时，所以我们需要考虑其他的方法。

我们注意到，并查集的并操作具有可合并性，所以我们考虑**倍增**，我们可以把一个点拆成 $\log N$ 个点，分别代表**从 i 开始，长度为 $2^k$ 的子串**，那么当我们处理两个区间相等的关系时，**对区间做二进制拆分，拆成 log 个区间，分别并起来就行**

具体的来讲：**$fa[i][k]$ 表示【左端点为位置 i，长度为 $2^k$ 的区间】所在集合的根的左端点**。例如，我们初始的所有 $fa[i][k]=a$,当我们把区间 $[5,8]$ 合并到 $[1,4]$ 后，我们有 $fa[5][2]=1$ (区间 $[1,4]$ 的左端点)

最终计算答案时，将所有层的对应端点合并即可，做法是将每层和他的上层合并，即将 $[i][k-1]$ 与 $[find(i,k)][k-1]$ 合并，将 $[i+2^{k-1}][k-1]$ 与 $[find(i,k)+2^{k-1}][k-1]$ 合并。比如，我们要合并 $fa[5][2]$,就要把我们的 $fa[5][2]$ 和我们的 $fa[1][3]$ 之间连续连边，我们就可以理解为**沿着 k 减小的方向向上合并**，**有一种相当于我们把我们的信息全部合并到 0 的美感。**
![[无标题.png]]

这也为我们区间并查集提供了一个思路：我们定义区间并查集如下：
我们给定两个区间，这两个区间上的数组都相等。**问我们最后有哪些单点是相等的。**

我们的区间并查集分为下面两个部分：
第一部分：区间并查集的构建，这一步我们采用我们和平常相同的思路
第二部分：我们将每一层和上一层合并，直到我们


```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 100005, mod = 1000000007;
int n, m, fa[maxn][18], ans;
int find(int x, int k) {
	return fa[x][k] == x ? x : fa[x][k] = find(fa[x][k], k);
}
void merge(int x, int y, int k) {
	x = find(x, k), y = find(y, k);
	if(x != y) fa[x][k] = y;
}
int main() {
	scanf("%d %d", &n, &m);
	const int maxk = floor(log2(n));
	for(int i = 1; i <= n; ++i)
		for(int k = 0; k <= maxk; ++k)
			fa[i][k] = i;			
	for(int i = 1, l1, r1, l2, r2; i <= m; ++i) {
		scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
		for(int k = maxk; ~k; --k)
			if(l1+(1<<k)-1 <= r1) merge(l1, l2, k), l1 += 1<<k, l2 += 1<<k;
	}	
	for(int k = maxk; k; --k)
		for(int i = 1; i+(1<<k)-1 <= n; ++i) {
			int pos = find(i, k);
			merge(i, pos, k-1), merge(i+(1<<k-1), pos+(1<<k-1), k-1);
		}
	for(int i = 1; i <= n; ++i)
		if(fa[i][0] == i) ans = !ans ? 9 : ans * 10ll % mod;
	printf("%d\n", ans);
	return 0;
}
```