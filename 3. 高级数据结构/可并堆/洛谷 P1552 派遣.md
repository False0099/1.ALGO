# [APIO 2012] 派遣

## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。

## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。

现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。

   
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。

   
写一个程序，给定每一个忍者 $i$ 的上级 $B_i$，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$，输出在预算内满足上述要求时顾客满意度的最大值。

## 输入格式

第一行包含两个整数 $N$ 和 $M$，其中 $N$ 表示忍者的个数，$M$ 表示薪水的总预算。

 
接下来 $N$ 行描述忍者们的上级、薪水以及领导力。其中的第 i 行包含三个整数 $B_i,C_i,L_i$ 分别表示第 $i$ 个忍者的上级，薪水以及领导力。Master 满足 $B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号 $B_i\lt i$。

## 输出格式

一行一个整数，表示在预算内顾客的满意度的最大值。

## 样例 #1

### 样例输入 #1

```
5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1
```

### 样例输出 #1

```
6
```

## 提示

$1 \le N \le 10^5$，$1 \le M \le 10^9$，$0 \le B_i \lt i$，$1 \le C_i \le M$，$1 \le L_i \le 10^9$。

对于 $30\%$ 的数据，$N \le 3000$。

## 题解
题目中因为跟我们说过，我们可以选择一个节点的**子树**中的任意，所以我们**不一定非要是亲儿子**~~野儿子也行

我们一开始把每一个节点看成一个单独的堆，然后我们按照我们节点编号逆序枚举（相当于我们从我们的叶子节点往根节点），**合并子节点和他的父节点**，并维护我们堆中节点数和我们堆中节点的点权（薪水）和。
合并后，如果点权和超过了薪水的总预算 M，就循环删除堆顶点权大的点。（贪心）
之后，我们再去计算父节点的领导力乘以我们堆中节点数来更新答案。

## 题解
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int fa[N],pay[N],lead[N];
int ls[N],rs[N],dis[N],siz[N],root[N];
long long sum[N],ans;
int merge(int x,int y){ //合并堆
	if(!x||!y) return x^y;
	pushdown(x),pushdown(y);
	if(s[x]>s[y]) swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dep[ls[x]]<dep[rs[x]])
		swap(ls[x],rs[x]);
	dep[x]=dep[ls[x]]+1;
	return x;
}
int main(){
	cin>>n>>m;
	dis[0]=1;
	for(int i=1;i<=n;i++){
		cin>>fa[i]>>pay[i]>>lead[i];
		root[i]=i;
		siz[i]=i;
		sum[i]=pay[i];
		ans=max(ans,1ll*lead[i]);
	}
	for(int i=n;i>1;i--){
		int f=fa[i];
		root[f]=merge(root[i],root[f]);
		siz[f]+=siz[i];
		sum[f]+=sum[i];
		while(sum[f]>m){
			siz[f]--;
			sum[f]-=pay[root[f]];
			root[f]=merge(ls[root[f]],rs[root[f]]);
		} 
		ans=max(ans,1ll*lead[f]*siz[f]);
	}
}
```

