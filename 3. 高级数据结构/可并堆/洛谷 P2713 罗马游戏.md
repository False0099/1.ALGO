# 罗马游戏

## 题目描述

罗马皇帝很喜欢玩杀人游戏。他的军队里面有  $n$ 个士兵，每个士兵都是一个独立的团。最近举行了一次平面几何测试，每个士兵都得到了一个分数。皇帝很喜欢平面几何，他对那些得分很低的士兵嗤之以鼻。

他决定玩这样一个游戏。它可以发两种命令：

- `M i j` 把  $i$ 所在的团和  $j$ 所在的团合并成一个团。如果  $i,j$ 有一个士兵是死人，那么就忽略该命令。  
- `K i` 把   $i$ 所在的团里面得分最低的士兵杀死。如果  $i$ 这个士兵已经死了，这条命令就忽略。

皇帝希望他每发布一条 `K i` 命令，下面的将军就把被杀的士兵的分数报上来 
（如果这条命令被忽略，那么就报  $0$ 分）。 

保证**士兵的分数互不相同**。

## 输入格式

第一行一个整数  $n$，表示士兵数。  

第二行  $n$ 个整数   $a_1,a_2,\ldots a_n$，其中  $a_i$ 表示编号为   $i$ 的士兵的分数。

第三行一个整数  $m$。

第   $3+i$ 行描述第 i 条命令。命令为如下两种形式：`M i j` 或 `K i`。

## 输出格式

如果命令是 `K i`，对应的请输出被杀士兵的分数（如果这个人不存在，就输出  $0$）。

## 样例 #1

### 样例输入 #1

```
5
100 90 66 99 10
7
M 1 5
K 1
K 1
M 2 3
M 3 4
K 5
K 4
```

### 样例输出 #1

```
10
100
0
66
```

## 提示

对于   $100\%$ 的数据，  $1\le n\le 10^6$，$1\le m\le 10^5$，$0\le a_i\le 10^7$，
**注意测试数据中 `M i j` 的 $i,j$ 可能在同一个团中。**


## 题解
这一题我们就是属于是我们的标准的左偏树，连我们的要求都和我们的左偏树一毛一样, 所以我们就可以直接用我们的模板来进行答题了。

```cpp
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a[1000010],d[1000010],ls[1000010],rs[1000010],f[1000010],x,y;//a是每个节点的值，d是节点的距离，ls左子节点，rs右子节点，f父节点（并查集）
bool b[1000010];//是否已经删除
char z;
int find(int x)
{
	if(f[x]==x)
	return x;
	return f[x]=find(f[x]);
}//并查集
int merge(int x,int y)//合并（返回当前节点的值）
{
	if(!x||!y)//有一棵树已经空了
	return x+y;//返回
	if(a[x]>a[y]||(a[x]==a[y]&&x>y))//交换条件
	swap(x,y);
	rs[x]=merge(rs[x],y);//右子节点
	if(d[ls[x]]<d[rs[x]])//如果左子节点距离小于右子节点
	swap(ls[x],rs[x]);//交换左右子树
	d[x]=d[rs[x]]+1;//算出当前点的距离
	return x;
}
int main()
{
	cin>>n;
	d[0]=-1;
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
		cin>>a[i];
	}
	cin>>m; 
	while(m--)
	{
		cin>>z;
		if(z=='M')
		{
			cin>>x>>y;
			if(b[x]||b[y])
			continue;//有一个点已经被删除了
			x=find(x);
			y=find(y);
			if(x==y)//已经在同一个堆中了
			continue;
			f[x]=f[y]=merge(x,y);
		}
		else if(z=='K')
		{
			cin>>x;
			if(b[x])//已经删除
			{
				cout<<0<<endl;
				continue;
			}
			x=find(x);
			cout<<a[x]<<endl;
			b[x]=1;//标记删除
			f[x]=f[ls[x]]=f[rs[x]]=merge(ls[x],rs[x]);//合并左右子树
			ls[x]=rs[x]=d[x]=0;
		}
	}
	return 0;
}
```
```