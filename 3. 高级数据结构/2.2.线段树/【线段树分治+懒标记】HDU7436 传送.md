## 题目描述
有一个 $n$ 个节点 $m$ 条边的无向图，对于一条边有四个参数 $(a,b,l,r)$ ,表示这条边在 $[l,r]$ 这些时间连接 $(a,b)$ 。
有一个传送技能：如果在某时刻 $u$ 和 $v$ 在一个连通块里，可以从 $u$ 传送到 $v$ 。
小 A 初始在节点 1 ,所以小 A 想知道他能在 $[1,n]$ 中的哪些时间点能直接从 1 传送到节点 $i$ ,请你帮帮他。
由于翰出量可能过大，考虑简化输出，假设所有能从 1 到达 $i$ 的时间点为 $t_i,1\ldots t_{i,k}$,定义 $ans_i=\sum_{j=1}^kt_{i,j}$ ,你只需要输出一个 $\oplus_{i=1}^nans_i$ 即可，其中 $\oplus$ 表示异或和。

## 输入：
第一行输入 $n,m$ 。

接下来 $m$ 行，每行输入 $a_i,b_i,l_i,r_i$ ,表示第 $i$ 条边的属性。


$$1\leq n,m\leq6\times10^5,1\leq a_i,b_i,l_i,r_i\leq n.$$

## 题解
本题我们注意到，我们存在一些关于我们的**时间相关的问题**，我们显然可以通过对于我们的**时间序列建立线段树**，然后通过对于我们的线段是进行分治来进行处理。

这里，我们还有一个要维护的就是维护我们的时间内对于我们的内部的**最长时间是多少**，这里，我们可以通过**在我们的并查集的父亲节点打表记**来统计我们的内部的最长时间是多少。显然，我们这一题要求我们的出现的时间段和，我们就可以在我们的 tag 处统计我们的时间和，而不是**是否出现过**。

具体来说，我们在我们的**叶子节点处理我们的信息**。每当我们走到叶子节点，就给我们的 1 点所在的根节点的对应标记进行修改。这样，所有与 1 连通的点都可以收到我们的对应的影响。
![[Pasted image 20240923211107.png]]

**我们在分裂的时候**下传我们的标记，于一连通的点都可以收到对应的影响。**注意，则个时候，所有和我们的 x 连通的点都会被我们贡献到**，


注意，我们**在并查集合并的时候**要消除已有标记的影响。也就是我们在合并的时候，给我们的子节点加上一个-1 的影响极客。
![[Pasted image 20240923211122.png]]

这个时候，我们把对应的内容链接即可。
```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
**using namespace** std**;**

**const** **int** INF **=** 0x3f3f3f3f3f3f3f3f**;**
**const** **int** N **=** 1e6 **+** 10**;**

**struct** Msg **{**
    **int** x**,** y**,** sz**;
}** stk**[**N**];**

**int** top **=** 0**;**
**int** tag**[**N**];**
mt19937 rnd**(**time**(**0**));**

**struct** Dsu **{**
    **int** fa**[**N**],** sz**[**N**],**rk**[**N**];**
    
    **void** init**(****int** n**) {**
        **for** **(****int** i **=** 1**;** i **<=** n**;** i**++) {**
            fa**[**i**] =** i**;**
            sz**[**i**] =** 1**;**
            rk**[**i**] =** rnd**();
        }
    }**
    
    **int** find**(****int** x**) {**
        **return** x **==** fa**[**x**] ?** x **:** find**(**fa**[**x**]);
    }**
    
    **bool** same**(****int** x**,** **int** y**) {**
        **return** find**(**x**) ==** find**(**y**);
    }**
    
    **void** merge**(****int** x**,** **int** y**) {**
        x **=** find**(**x**),** y **=** find**(**y**);**
        **if** **(**x **==** y**)** **return****;**
        **if** **(**sz**[**x**] >** sz**[**y**])** swap**(**x**,** y**);**
        fa**[**x**] =** y**;**
        tag**[**x**] -=** tag**[**y**];**
        sz**[**y**] +=** sz**[**x**];**
        stk**[++**top**] = {**x**,** y**,** sz**[**x**]};
    }**
    
    **void** resume**() {**
        Msg t **=** stk**[**top**--];**
        **int** y **=** fa**[**t**.**x**];**
        **int** x **=** t**.**x**;**
        sz**[**y**] -=** sz**[**x**];**
        tag**[**x**] +=** tag**[**y**];**
        fa**[**x**] =** x**;
    }
}** dsu**;**

**struct** node **{**
    **int** l**,** r**;**
    vector**<**pair**<****int****,** **int****>>** edges**;
}** tr**[**N **<<** 2**];**

**void** build**(****int** u**,** **int** l**,** **int** r**) {**
    tr**[**u**].**l **=** l**;**
    tr**[**u**].**r **=** r**;**
    tr**[**u**].**edges**.**clear**();**
    **if** **(**l **==** r**)** **return****;**
    **int** mid **= (**l **+** r**) /** 2**;**
    build**(**u **<<** 1**,** l**,** mid**);**
    build**(**u **<<** 1 **|** 1**,** mid **+** 1**,** r**);
}**

**void** assign**(****int** u**,** **int** l**,** **int** r**,** **int** e1**,** **int** e2**) {**
    **if** **(**l **<=** tr**[**u**].**l **&&** tr**[**u**].**r **<=** r**) {**
        tr**[**u**].**edges**.**push_back**({**e1**,** e2**});**
        **return****;
    }**
    **int** mid **= (**tr**[**u**].**l **+** tr**[**u**].**r**) /** 2**;**
    **if** **(**l **<=** mid**)** assign**(**u **<<** 1**,** l**,** r**,** e1**,** e2**);**
    **if** **(**r **>** mid**)** assign**(**u **<<** 1 **|** 1**,** l**,** r**,** e1**,** e2**);
}**

**void** dfs**(****int** u**) {**
    **int** pref **=** top**;**
    **for** **(****auto** **[**u**,** v**] :** tr**[**u**].**edges**) {**
        dsu**.**merge**(**u**,** v**);
    }**
    **if** **(**tr**[**u**].**l **==** tr**[**u**].**r**) {**
        assert**(**tr**[**u**].**l**==**tr**[**u**].**r**);**
        tag**[**dsu**.**find**(**1**)]+=**tr**[**u**].**r**;
    }** **else** **{**
        dfs**(**u **<<** 1**);**
        dfs**(**u **<<** 1 **|** 1**);
    }**
    **while** **(**pref **!=** top**) {**
        dsu**.**resume**();
    }
}**

**void** init**() {**
    // Any initialization logic can go here if needed.
**}**

**void** solve**() {**
    //freopen("input.in","r",stdin);    **int** n**,**m**;**
    cin**>>**n**>>**m**;**
    vector**<****int****>** u**(**m**+**1**);**
    vector**<****int****>** v**(**m**+**1**);**
    vector**<****int****>** l**(**m**+**1**);**
    vector**<****int****>** r**(**m**+**1**);**
    **for****(****int** i**=**1**;**i**<=**m**;**i**++){**
        cin**>>**u**[**i**]>>**v**[**i**]>>**l**[**i**]>>**r**[**i**];
    }**
   // int max_time = *max_element(begin(r)+1,end(r));
    //max_time=max(max_time,*max_element(begin(l)+1,end(l)));    dsu**.**init**(**n**);**
    build**(**1**,** 1**,** n**);**

    **for****(****int** i**=**1**;**i**<=**m**;**i**++){**
        **int** uu**=**u**[**i**];**
        **int** vv**=**v**[**i**];**
        **int** ll**=**l**[**i**];**
        **int** rr**=**r**[**i**];**
        **if****(**ll**>**rr**){**
            swap**(**ll**,**rr**);
        }**
        assign**(**1**,**ll**,**rr**,**uu**,**vv**);
    }**
    dfs**(**1**);**
    **int** ans**=**0**;**
    **for** **(****int** i **=** 1**;** i **<=** n**;** i**++) {**
        ans**^=**tag**[**i**];
    }**
    cout **<<** ans**<<**endl**;
}**

**signed** **main****() {**
    ios**::**sync_with_stdio**(**false**),** cin**.**tie**(**0**);**
    **int** t **=** 1**;** // Set to 1 for a single test case; adjust as needed.    init**();**
    **while** **(**t**--) {**
        solve**();
    }
}**
```