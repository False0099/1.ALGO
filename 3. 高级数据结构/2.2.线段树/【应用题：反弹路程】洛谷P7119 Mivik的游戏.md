# Mivik 的游戏

## 题目背景

Mivik 和 W!ʌ! K 在玩游戏！

## 题目描述

Mivik 首先把 $n$ 枚硬币摆成一排，其中有一些正面朝上，其余的都是反面朝上。W!ʌ! K 打算不断执行以下操作直到这 $n$ 枚硬币中没有硬币反面朝上：

- 如果现在这 $n$ 枚硬币中有 $k$ 枚硬币反面朝上，那么翻转从左到右第 $k$ 枚硬币。具体地，如果从左到右第 $k$ 枚硬币正面朝上，则将其变为反面朝上；如果从左到右第 $k$ 枚硬币反面朝上，则将其变为正面朝上。

在 W!ʌ! K 开始玩游戏之前，Mivik 想考考 W!ʌ! K。Mivik 想让 W!ʌ! K 算出他总共会进行多少次这样的操作，或者是 W!ʌ! K 永远无法停止执行操作。

W!ʌ! K 很快解决了这个问题，但是心理比 yky 还变态的 Mivik 显然不会放过他。Mivik 进行了很多次操作，每次他翻转了一个区间的硬币，他要求 W!ʌ! K 算出他总共会进行多少次这样的操作，或者是 W!ʌ! K 永远无法停止执行操作。

**请注意，W!ʌ! K 只是需要计算总共会进行多少次操作，而不会真正进行操作。**

## 输入格式

输入共 $\left(m+2\right)$ 行。

第一行为两个非负整数 $n,m$，其中 $n$ 表示 Mivik 的硬币的个数，$m$ 表示 Mivik 进行的翻转操作的次数。

第二行为一个只包含有 $\texttt H$ 和 $\texttt T$ 的字符串。第 $i$ 个字符 $s_i$ 为 $\texttt H$ 则表示从左到右第 $i$ 枚硬币初始时是正面朝上；$s_i$ 为 $\texttt T$ 则表示从左到右第 $i$ 枚硬币初始时是反面朝上。

接下来 $m$ 行，每行两个正整数 $l_i,r_i$，表示 Mivik 翻转了从左到右数 $l_i\sim r_i$（包括 $l_i$ 和 $r_i$）的硬币。

## 输出格式

输出 $\left(m+1\right)$ 行，分别表示在真正执行操作前后共 $\left(m+1\right)$ 个时刻开始 W!ʌ! K 总共会进行多少次这样的操作，或者是 W!ʌ! K 永远无法停止执行操作。如果某一时刻 W!ʌ! K 不能停止执行操作，则在对应行输出字符串 $\texttt{never}$。

## 样例 #1

### 样例输入 #1

```
2 2
TT
2 2
1 2
```

### 样例输出 #1

```
2
1
3
```

## 样例 #2

### 样例输入 #2

```
5 0
HTHTH
```

### 样例输出 #2

```
8
```

## 样例 #3

### 样例输入 #3

```
10 10
HTHHTHTHHH
9 9
5 5
10 10
7 7
6 6
9 9
4 4
9 9
7 7
2 2
```

### 样例输出 #3

```
19
30
27
40
33
38
27
28
37
40
47
```

## 提示

### 样例解释 #1
初始时两枚硬币都是反面朝上，因此如果 W!ʌ! K 从此刻开始执行操作， W!ʌ! K 会将编号为 $2$ 的硬币翻转过来。操作后只有一枚硬币反面朝上，因此第 $2$ 次操作会将编号为 $1$ 的硬币翻转过来。在第 $2$ 次操作后没有硬币反面朝上，因此 W!ʌ! K 不会再执行操作，总共会执行 $2$ 次操作。

### 样例解释 #2
这 $8$ 次操作分别翻转了第 $2,1,2,3,4,3,2,1$ 枚硬币。

### 测试点约束
**本题采用捆绑测试。**

对于全部数据，有 $1\le n,m\le10^6$，$s_i\in\left\{\texttt H,\texttt T\right\}$，$1\le l_i\le r_i\le n$。

每个子任务的具体限制见下表：

| 子任务编号 | 分值  |    特殊限制     |
| :---: | :-: | :---------: |
|   1   | 10  |   $n\le3$   |
|   2   | 20  | $n,m\le100$ |
|   3   | 30  |  $m\le10$   |
|   4   | 20  |  $l_i=r_i$  |
|   5   | 20  |      无      |

**本题读入输出量较大，请使用较快的读入输出方式。**

## 题解
本题我们考虑找到我们的公式：我们考虑我们是怎么**消除掉一个**反面朝上的硬币的？我们先考虑只有一个硬币向上的情况，
```
HHHTH
```
很显然，想让那个反面朝上的硬币反过来，就得存在 4 个反面朝上的硬币。
所以第一步，是把前面 3 个硬币一起反过来，需要 3 步。

接下来就可以把所有反面朝上的硬币全翻回来了，共需 4 步。

如果我们令我们的 $p$ 表示我们反面朝上的这一个位置，那么我们就有：$ans=p*2+1$。


考虑有更多硬币的情况下，我们是怎么样进行的，我们模拟一下这个场景。此时一共有 $m$ 个硬币反面朝上，$k$ 的值目前为 $m$。$k$ 往右移，碰到一个反面朝上的硬币，再折回来。

我们观察到，**如果我们最后想要一次性解决**，那么我们最后一定是形如：$000\dots111$ 这样的形式，也就是我们的 0 作为我们的前缀，并且后面**不存在任意一个 0**。我们于是就需要计算，我们转换成这样的一个形式，需要的次数是多少。

**首先，我们注意到，我们的前缀的末尾，一定是我们原先的 0 的最右边**。这一规定确定了我们的结尾。

我们要计算我们要把我们以 $x$ 为起始点，向右的第一个元 1 翻转为 0 的代价，显然，应该是两点之间的距离乘二减一，也就是 $2\times (w-m)+1$。**这一结论对于后面的也适用**。

接着又碰到一个反面朝上的硬币，若这个硬币的位置为 $w_2$,则这个操作所用步数为：$w_2*2-1-2*(m-2)=w_2*2-(m-1)*2+1$

把所有的操作的步数推出来后，相加得：
$$2*(w_1+w_2+...+w_{m-1}+w_m)-2(m+(m-1)+...+2+1)+m*1$$
$$2*\sum_{i=1}^mw_i-2(m+1)*m/2+m$$
$$2*\sum_{i=1}^mw_i-(m+1)*m+m$$
$$2*\sum_{i=1}^mw_i-m^2$$

最后，我们的上述式子在我们的区间反转的情况下，只需要通过我们的线段树来进行维护即可。
```
#include<bits/stdc++.h>
#define N 1000010
#define int long long//不开 long long 见祖宗
using namespace std;
struct hhh{
	int l,r,cnt,sum,lz;
}dl[N*4];
int n,m,l,r;
int a[N];
char p;
void pushup(int bh){
	dl[bh].cnt=dl[bh*2].cnt+dl[bh*2+1].cnt;
	dl[bh].sum=dl[bh*2].sum+dl[bh*2+1].sum;
}
void pushdown(int bh){
	if(!dl[bh].lz) return;
	dl[bh*2].lz^=1;
	dl[bh*2].cnt=dl[bh*2].r-dl[bh*2].l+1-dl[bh*2].cnt;
	dl[bh*2].sum=(dl[bh*2].r+dl[bh*2].l)*(dl[bh*2].r-dl[bh*2].l+1)/2-dl[bh*2].sum;
	dl[bh*2+1].lz^=1;
	dl[bh*2+1].cnt=dl[bh*2+1].r-dl[bh*2+1].l+1-dl[bh*2+1].cnt;
	dl[bh*2+1].sum=(dl[bh*2+1].r+dl[bh*2+1].l)*(dl[bh*2+1].r-dl[bh*2+1].l+1)/2-dl[bh*2+1].sum;
	dl[bh].lz=0;
}
void build(int bh,int l,int r){
	dl[bh].l=l,dl[bh].r=r;
	if(l==r){
		if(a[l]) dl[bh].cnt=1,dl[bh].sum=l;
		return;
	}
	int mid=(l+r)>>1;
	build(bh*2,l,mid),build(bh*2+1,mid+1,r);
	pushup(bh);
}
void update(int bh,int L,int R){
	int l=dl[bh].l,r=dl[bh].r;
	if(l>=L&&r<=R){
		dl[bh].lz^=1;
		dl[bh].cnt=r-l+1-dl[bh].cnt;
		dl[bh].sum=(r+l)*(r-l+1)/2-dl[bh].sum;
		return;
	}
	pushdown(bh);
	int mid=(l+r)>>1;
	if(L<=mid) update(bh*2,L,R);
	if(R>mid) update(bh*2+1,L,R);
	pushup(bh);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>p;
		if(p=='T') a[i]=1;
	}
	build(1,1,n);
	cout<<2*dl[1].sum-dl[1].cnt*dl[1].cnt<<endl;
	while(m--){
		cin>>l>>r;
		update(1,l,r);
		cout<<2*dl[1].sum-dl[1].cnt*dl[1].cnt<<endl;
	}
	return 0;
}//由于我用的是cin和cout，这道题卡常又卡得紧，所以要开O2

```