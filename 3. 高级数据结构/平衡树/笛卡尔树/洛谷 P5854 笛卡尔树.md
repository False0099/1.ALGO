# 【模板】笛卡尔树

## 题目描述

给定一个 $1 \sim n$ 的排列 $p$，构建其笛卡尔树。

即构建一棵二叉树，满足：

1. 每个节点的编号满足二叉搜索树的性质。
2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。

## 输入格式

第一行一个整数 $n$。

第二行一个排列 $p_{1 \dots n}$。

## 输出格式

设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。

一行两个整数，分别表示 $\operatorname{xor}_{i = 1}^n i \times (l_i + 1)$ 和 $\operatorname{xor}_{i = 1}^n i \times (r_i + 1)$。

## 样例 #1

### 样例输入 #1

```
5
4 1 3 2 5
```

### 样例输出 #1

```
19 21
```

## 提示

【样例解释】

| $i$ | $l_i$ | $r_i$ |
| :-: | :-: | :-: |
| $1$ | $0$ | $0$ |
| $2$ | $1$ | $4$ |
| $3$ | $0$ | $0$ |
| $4$ | $3$ | $5$ |
| $5$ | $0$ | $0$ |

【数据范围】

对于 $30\%$ 的数据，$n \le 10^3$。

对于 $60\%$ 的数据，$n \le 10^5$。

对于 $80\%$ 的数据，$n \le 10^6$。

对于 $90\%$ 的数据，$n \le 5 \times 10^6$。

对于 $100\%$ 的数据，$1 \le n \le 10^7$。

## 题解
#### 笛卡尔树的定义：

笛卡尔树是一种二叉树，每一个结点由一个键值二元组 (�,�)(k,w) 构成。要求 �k 满足二叉搜索树的性质，而 �w 满足堆的性质。一个有趣的事实是，如果笛卡尔树的 (�,�)(k,w) 键值确定、并且 �k 不相同， �w 不相同，那么这个笛卡尔树的结构是唯一的。

`--- 摘取自 OIWIKI`

![](https://oi-wiki.org/ds/images/cartesian-tree1.png)

（维基百科上面的图片）

#### 如何建树

给定一个序列 �A （默认其没有重复元素），下面建树的过程以小根堆为例，定义序列中第 �i 个元素的键值为 (�,��)(i,Ai​)，也就是 �i 对应 �k ， ��Ai​ 对应 �w。

定义一棵树的**右链**为从根出发一直往右儿子方向能够到达的所有点按照深度从浅到深排序后而形成的一条链。

因为我们的键值 �k 是数组下标，所以我们不需要排序，直接从数组的左边往右边插入可以。

假设我们现在插入的是节点 �u，我们为了维护下标满足二叉搜索树的性质，肯定每次都是往树的**右链**的末端插入，但是我们此时要维护堆的性质。

- 1.1. 如果恰好 ��wu​ 大于当前右链末端端点的 �w 即直接将 �u 插入到 右链的末端。
    
- 2.2. 如果 ��wu​ 小于当前右链的末端端点的 �w，那么意味着 �u 应当在树上是 **当前右链** 末端端点的祖先，于是我们继续往上找，直到遇到满足第一种情况的点。
    

假如我们在右链上找到了一个点 �j 使得 ��<��wj​<wu​ ，那么就把 �j 的右儿子作为 �u 的左儿子，�j 的右儿子变为 �u，然后我们就完成了插入这个 �u。

如果没有找到任何一个点可以小于 ��wu​，那么 ��wu​ 就会成为新的右链的根节点。

具体建树的例子可以看这里：[OIWIKI - 笛卡尔树](https://oi-wiki.org/ds/cartesian-tree/)

可以发现上面的过程可以用单调栈维护右链，具体可以康康代码呀。

#### 笛卡尔树的一些性质

- 对于原正整数序列建树以后，区间 [�,�][l,r] 的极值即是树上 �l 所在位置以及 �r 所在位置的 ���LCA，运用这个性质可以做到 �(�)−�(1)O(n)−O(1) 的**在线解决**区间 `RMQ` 问题（但是得结合 `+1/-1 RMQ` 来做，编码复杂度很高，不建议使用）。
    
    ps.具体做法即先对原序列建一棵笛卡尔树，随后对这棵笛卡尔树做 `O(n) - O(1) LCA` 即可， `O(n) - O(1) LCA` 即可以用 `+1/-1 RMQ` 解决，`+1/-1 RMQ` 具体可以参见 `2017 - 徐明宽 《非常规大小分块算法初探》` 论文中提到的方法，不再赘述。
    
- 可以很容易的维护一个数在原序列的前驱后继，因为恰好它的下标键值满足二叉搜索树的性质，而且权值满足堆的性质，所以，可以通过 ���DFS 获取前驱后继等，但是常数貌似比单调栈还大。
    
- 综上，笛卡尔树的主要作用还是在于处理区间 `RMQ` 问题，处理其它问题并没有明显优势。
    

#### 模板代码

其实大家写得应该都差不多吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
typedef long long LL;
const int MAXN = 1e7 + 50;
int n, A[MAXN], tack[MAXN], top = 1, ls[MAXN], rs[MAXN];
LL ans1, ans2;

int main() {
    n = read(); tack[1] = 1;
    for(int i = 1 ; i <= n ; i ++) A[i] = read();
    for(int i = 2 ; i <= n ; i ++) {
        while(A[tack[top]] > A[i] && top) top --; // 弹栈
        if(!top) ls[i] = tack[top + 1]; // 如果右链中没有一个比它大的元素，它就成了右链的链顶并且原来的链顶就是它的左儿子
        else ls[i] = rs[tack[top]], rs[tack[top]] = i; // 想象一下把点 i 插入到某个点的下方，也就是说原本那个点的右儿子要变成 i 的左儿子，然后 i 来充当这个右儿子
        tack[++ top] = i;
    }
    for(int i = 1 ; i <= n ; i ++) {
        ans1 ^= (1ll * i * (ls[i] + 1));
        ans2 ^= (1ll * i * (rs[i] + 1));
    } printf("%lld %lld", ans1, ans2);
    return 0;
}
// Author : MuYC
```