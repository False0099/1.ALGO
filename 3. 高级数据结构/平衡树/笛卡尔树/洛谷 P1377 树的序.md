# [TJOI 2011] 树的序

## 题目描述

众所周知，二叉查找树的形态和键值的插入顺序密切相关。准确的讲： 
1. 空树中加入一个键值 $k$，则变为只有一个结点的二叉查找树，此结点的键值即为 $k$。
2. 在非空树中插入一个键值 $k$，若 $k$ 小于其根的键值，则在其左子树中插入 $k$，否则在其右子树中插入 $k$。

我们将一棵二叉查找树的键值插入序列称为树的生成序列，现给出一个生成序列，求与其生成同样二叉查找树的所有生成序列中字典序最小的那个，其中，字典序关系是指对两个长度同为 $n$ 的生成序列，先比较第一个插入键值，再比较第二个，依此类推。

## 输入格式

第一行，一个整数 $n$，表示二叉查找树的结点个数。第二行，有 $n$ 个正整数 $k_1, k_2, \cdots,k_n$，表示生成序列，简单起见，$k_1 \sim k_n$ 为一个 $1$ 到 $n$ 的排列。

## 输出格式

一行，$n$ 个正整数，为能够生成同样二叉查找数的所有生成序列中最小的。

## 样例 #1

### 样例输入 #1

```
4
1 3 4 2
```

### 样例输出 #1

```
1 3 2 4
```

## 提示

### 数据范围及约定

- 对于 $20\%$ 的数据， $1\le n ≤ 10$。
- 对于 $50\%$ 的数据， $1\le n ≤ 100$。
- 对于 $100\%$ 的数据， $1\le n ≤ 10^5$。


## 题解
这道题其实就是建一颗指定的二叉查找树，由于指定了插入方式，所以这道题目的树有两个限制：值要满足二叉查找树的限制，插入顺序上儿子比父亲晚插入，满足堆得性质。**我们本题的难点在于我们的快速建树**

#### 这不就是笛卡尔树吗！

所以就可以O(NlogN)建树了，其实桶排能到O(N)

> 整个过程的第一步是把所有点按照key排序，然后从一个节点开始，按key递增顺序依次插入节点。想象一下，假设已经有一棵笛卡尔树，那么现在我们要插入一个新的节点，而这个节点比这棵树所有节点的key都大，那么应该如何插入呢？假设这个节点已经被插入，那么它的位置肯定是在从根节点开始一直向右走。所以，每次插入新节点的时候，一定插入到最右侧那条路中的某个位置，而原来位置的节点变成了这个新节点的左子树，新插入的点变成最右侧那条路的最后一个节点。

> 那么如何确定插入的位置呢？那就要根据这个节点的value值了，因为满足堆的性质，所以一条路从上到下，其value值肯定是递减的。就是因为这个递减的性质，我们可以把最右侧的那条路用一个栈表示，栈底是根，栈顶是最新节点，从底到顶，value值和key值都递增。每次新插入一个节点的时候，就从顶往底一个个看，找到第一个value大于新节点value的节点，作为新节点的父
```cpp
#include <bits/stdc++.h>
const int MAXN=1e5+10;
using namespace std;
int N;
int ls[MAXN],rs[MAXN],vv[MAXN];
int s[MAXN],top;
struct dat{
    int val,id;
    bool operator <(const dat&d) const {
        return val<d.val;
    }
}a[MAXN];
void dfs(int st) {
	if(!st) return;
	printf("%d ",vv[st]);
    dfs(ls[st]);
    dfs(rs[st]);
}
int main() {
	scanf("%d",&N);
	for(int i=1;i<=N;++i) scanf("%d",&a[i].val),a[i].id=i;
    sort(a+1,a+N+1);
    for(int i=1;i<=N;++i) {
        while(top&&a[s[top]].id>a[i].id) top--;
		vv[i]=a[i].val;
        ls[i]=rs[s[top]];
        rs[s[top]]=i;
        s[++top]=i;
    }
 //   for(int i=0;i<=N;++i) printf("ls[%d]=%d,rs[%d]=%d vv[%d]=%d\n",i,ls[i],i,rs[i],i,vv[i]);
    dfs(rs[0]);
	return 0;
}
```