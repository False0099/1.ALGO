#主席树求区间范围个数 
# [JSOI 2018] 列队

## 题目描述

作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。

军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。

为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\vert y-x \vert$ 。

在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。

以下是对题意的一些补充：

1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。
    
2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。

## 输入格式

第一行输入两个整数 $n,m$。

第二行 $n$ 个整数 $a_i$ 表示学生的休息位置。保证学生休息的位置两两不同。

接下来 $m$ 行每行三个整数 $l,r,K$ 表示一条命令。

## 输出格式

对于每一条命令输出一行一个整数表示最小的体力值总和。

## 样例 #1

### 样例输入 #1

```
5 5
1 5 7 6 2
1 5 2
1 5 3
1 3 9
2 4 2
3 5 5
```

### 样例输出 #1

```
5
4
17
9
3
```

## 提示

**样例 1 解释**


在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。
    
在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。
    
在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。
    
在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。
    
在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。

**数据范围**

对于 $10\%$ 的数据，$n,m \leq 10$；

对于 $40\%$ 的数据，$n,m \leq 10^3$；

对于 $70\%$ 的数据，$n,m \leq 10^5$；

对于 $100\%$ 的数据，$n,m \leq 5 \times 10^5,1 \leq a_i,K \leq 10^6$。

对于 $100\%$ 的数据，学生休息的位置两两不同。

## 题解
我们这一题可以抽象为：给定一个数组，现在要我们求数组中到某个位置的总和最小，我们这一题显然可以贪一下，
不难证明，学生跑到最终的位置时，他们的相对位置不改变至少是最优解之一，这可以脑补一下。

所以我们只需要求最终相对位置不变时的答案即可。

因为学生两两位置不同，所以最终有一部分学生向右跑，有一部分学生向左跑。

向右跑的学生对答案的贡献是 k+rki​−1−ai​，rki​ 表示他的位置在这个编号区间中的学生是第 rki​ 小的。

向左跑的学生对答案的贡献是 ai​−k−rki​+1。

显然左边一部分学生向右跑，右边一部分学生向左跑。

考虑使用主席树处理这个问题。

对权值线段树进行可持久化，则编号区间内的学生就是两个线段树相减。

考虑递归进一个区间 [l,r]，有 44 种情况。

1. 这个区间中没有学生。直接返回 00。
    
2. 这个区间中的学生全部往右跑。返回 (∑k+rki​−1)−(∑ai​)，左边是等差数列求和的形式，右边可以直接记。
    
3. 这个区间中的学生全部往左跑。返回 (∑ai​)−(∑k+rki​−1)。
    
4. 不能确定这个区间中的学生的方向，递归到子树处理。
    

直接在主席树上实现即可。
```cpp
#include <cstdio>

typedef long long LL;
const int MN = 500005;
const int MS = 11000005;

int n, m, s = 1000000;
int rt[MN];
int ls[MS], rs[MS], mx[MS], mn[MS], sz[MS], cnt;
LL sum[MS];

void Add(int &rt, int l, int r, int p) {
    ls[++cnt] = ls[rt], rs[cnt] = rs[rt], sz[cnt] = sz[rt] + 1, sum[cnt] = sum[rt] + p, rt = cnt;
    if (l == r) return ;
    int mid = l + r >> 1;
    if (p <= mid) Add(ls[rt], l, mid, p);
    else Add(rs[rt], mid + 1, r, p);
}

LL Qur(int rt1, int rt2, int l, int r, int f, int k) {
    if (!(sz[rt1] - sz[rt2])) return 0;
    LL Sz = sz[rt1] - sz[rt2], Sum = sum[rt1] - sum[rt2];
    if (l >= k + f) return Sum - (2*k + 2*f + Sz - 1) * Sz / 2;
    if (r <= k + f + Sz - 1) return (2*k + 2*f + Sz - 1) * Sz / 2 - Sum;
    int mid = l + r >> 1, lsz = sz[ls[rt1]] - sz[ls[rt2]];
    return Qur(ls[rt1], ls[rt2], l, mid, f, k) + Qur(rs[rt1], rs[rt2], mid + 1, r, f + lsz, k);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, x; i <= n; ++i) {
        scanf("%d", &x);
        Add(rt[i] = rt[i - 1], 1, s, x);
    }
    for (int i = 1, l, r, k; i <= m; ++i) {
        scanf("%d%d%d", &l, &r, &k);
        printf("%lld\n", Qur(rt[r], rt[l - 1], 1, s, 0, k));
    }
    return 0;
}
```