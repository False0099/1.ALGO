# [USACO 10 OPEN] Time Travel S

## 题目描述

Farmer John 买了台时光机，这使得他可以方便地管理自己的奶牛群。

他现在有 $N$ 个操作（$1 \leq N \leq 8 \times 10^4$），每次操作仅可能是如下三种之一：

1. `a x`：添加一头编号为 $x$ 的奶牛（$1 \leq x \leq 10^6$）。
2. `s`：卖掉最近添加的奶牛（保证此时至少有一头奶牛）。
3. `t x`：回到**第 $x$ 次操作前**的状态（保证第 $x$ 次操作存在）。

你需要在 FJ 执行每次操作后输出他拥有的最新的奶牛的编号。特别地，如果没有奶牛，输出 $-1$。

## 输入格式

第一行一个整数 $N$。

接下来 $N$ 行，每行描述一次操作。

## 输出格式

第 $i$ 行输出第 $i$ 次操作后 FJ 拥有的最新的奶牛的编号。特别地，如果没有奶牛，输出 $-1$。

## 样例 #1

### 样例输入 #1

```
12
a 5
a 3
a 7
s
t 2
a 2
t 4
a 4
s
t 7
s
s
```

### 样例输出 #1

```
5
3
7
3
5
2
7
4
7
2
5
-1
```

## 提示

下面是样例解释，其中拥有的奶牛已经按添加顺序排好。

| 操作编号 | 操作    | 拥有的奶牛   | 输出  |
| ---- | ----- | ------- | --- |
| 1    | `a 5` | 5       | 5   |
| 2    | `a 3` | 5,3     | 3   |
| 3    | `a 7` | 5,3,7   | 7   |
| 4    | `s`   | 5,3     | 3   |
| 5    | `t 2` | 5       | 5   |
| 6    | `a 2` | 5,2     | 2   |
| 7    | `t 4` | 5,3,7   | 7   |
| 8    | `a 4` | 5,3,7,4 | 4   |
| 9    | `s`   | 5,3,7   | 7   |
| 10   | `t 7` | 5,2     | 2   |
| 11   | `s`   | 5       | 5   |
| 12   | `s`   | /       | -1  |

## 题解
我们本体的思路就是通过我们的简单的可持久化栈来实现我们的题目要求。

而要实现我们的可持久化栈，我们就需要通过我们的**类链表**来实现我们的版本存储，这是因为我们的每一个版本之间的变化元素都是**少量的**，因此，我们只需要存储我们每一个版本间的不同点即可。

而**由于本题中的变化**都是限制在我们的结尾，所以我们不妨用类似于**树**的方法，我们存储我们每一次最后操作后的位置在哪里。之后，我们每一次再去跳版本即可。

```
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+10;
map<int,int> val;
map<int,int> fa;
map<int,int> save;
int idx;
int main(){
	int t;
	cin>>t;
	int version=0;//x表示我们的版本号 
	int cur=0;//cur表示当前版本的尾指针 
	while(t--){
		char ope;
		cin>>ope;
		if(ope=='a'){
			int u;
			cin>>u;
			//val[idx]=u,fa[idx]=now,now=idx,save[++version] 
			fa[++idx]=cur;
			val[idx]=u;
			cur=idx;
			save[++version]=cur;			
		}
		if(ope=='s'){
			cur=fa[cur];
			save[++version]=cur;
		}
		if(ope=='t'){
			int u;
			cin>>u;
			cur=save[u-1];
			save[++version]=cur;
		}
		cout << ((val[cur] == 0) ? -1 : val[cur]) << '\n';
	}
}
```