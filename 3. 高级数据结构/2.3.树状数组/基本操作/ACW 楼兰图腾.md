# 知识点
  ## [[树状数组]]
# 题目
 在完成了分配任务之后，西部 314来到了楼兰古城的西部。

相传很久以前这片土地上 (比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀 (V)，一个部落崇拜铁锹 (∧)，他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。

西部 314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n个点，经测量发现这 n个点的水平位置和竖直位置是两两不同的。

西部 314认为这幅壁画所包含的信息与这 n个点的相对位置有关，因此不妨设坐标分别为 (1, y 1), (2, y 2),…, (n, yn)，其中 y 1∼yn是 1到 n的一个排列。

西部 314 打算研究这幅壁画中包含着多少个图腾。

如果三个点 (i, yi), (j, yj), (k, yk)满足 1≤i<j<k≤n且 yi>yj, yj<yk
，则称这三个点构成 V 图腾;

如果三个点 (i, yi), (j, yj), (k, yk)
 满足 1≤i<j<k≤n且 yi<yj,yj>yk，则称这三个点构成 ∧ 图腾;

西部 314想知道，这 n个点中两个部落图腾的数目。

因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。

## 输入格式
第一行一个数 n
。

第二行是 n
 个数，分别代表 y 1，y 2,…, yn
。

## 输出格式
两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数。

## 数据范围
对于所有数据，n≤200000，且输出答案不会超过 int 64。
Y 1∼yn是 1到 n的一个排列。

## 输入样例：
5
1 5 3 2 4
## 输出样例：
3 4

# 思路
我们不难发现，这一题要求一个正三角和倒三角的图案。朴素的方法就是找到每一个点，作为三角图形的中间点，再分别求左侧和右侧**比这个数还要小或大的的数字的总数**，最后在该点的结果就是左右两侧直接相乘。

我们所能优化的，就是求左右两侧比这个数还要大的的数字的方法。朴素做法当然是直接遍历即可。但如果我们想要提高效率，就需要用到树状数组。

我们构建两个树状数组，一个**按照我们正序添加**，**求在这个数左侧比这个数还要小/大的数的和**，另一个按照我们的逆序添加，求在这个数的右侧，比这个数还要大/小的数字和。

我们用树状数组来储存每一个位置上每一个数字出现的次数，比如我现在有一个数组 1,2,4,5,3。那么对应的理论上第一次更新后的树状数组应该具有如下的形式

```markdown
//第一次更新
a[0]  a[1]  a[2]  a[3]  a[4]  a[5]  a[6] 
 0     1     0     0     0     0     0  
 //第二次更新
a[0]  a[1]  a[2]  a[3]  a[4]  a[5]  a[6]
 0      1     1     0     0     0     0
    
```
 在这个的基础上，我们想要求得最小值，就可以转换为求 n-1 以及以下的数字在母数组中出现的总次数。就是很典型的树状数组前缀和的查询。
 
# AC 代码
```cpp
#include <iostream>
using namespace std;
int a[N],tr[N];
int greater[N],lower[N];
void add(int a,int b){
	for(int i=a;i<=n;i+=lowbit(i)){
		tr[i]+=b;
	}
}
int ask(int a){
	int sum=0;
	for(int i=a;i>=0;i-=lowbit(i)){
		sum+=tr[i];
	}
	return sum;
}

int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
			int y=a[i];
			Lower[i]=ask[i-1];
			//res1*=lower[i]*(i-lower[i]);
			Greater[i]=ask[n]-ask[y];
			//res2*=greater[i]*(i-greater[i]);
			add(y,1);
	}
	memset(tr,0,sizeof tr);
	for(int i=n;i>=1;i--){
		int y=a[i];
		resA+=(LL)(lower[i])*ask(y-1);
		resB+=(LL)(Greater[i])*(ask(n)-ask(y));
		add(y,1);
	}
	cout<<resA<<" "<<resB<<endl;
	return 0;
}
```
# 备注
***对于 y 轴为任意数字的情况，我们可以通过数字离散化的方法回到我们原本的 0-n 问题。
反着跑一边其实是不必要的，因为知道一侧的，另一侧的可以用减法直接算出来