# [HEOI 2012] 采花

## 题目描述

萧薰儿是古国的公主，平时的一大爱好是采花。

今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。

花园足够大，容纳了 $n$ 朵花，共有 $c$ 种颜色，用整数 $1 \sim c$ 表示。且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴。同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。

由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了 $m$ 个行程，然后一一向你询问公主能采到的花共有几种不同的颜色。

## 输入格式

输入的第一行是三个用空格隔开的整数，分别代表花的个数 $n$，花的颜色数 $c$，以及行程数 $m$。

输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 朵花的颜色 $x_i$。

第 $3$ 行到第 $(m + 2)$ 行，每行两个整数 $l, r$，第 $(i + 2)$ 行的数字代表第 $i$ 次行程为第 $l$ 到第 $r$ 朵花。

## 输出格式

共输出 $m$ 行，每行一个整数。第 $i$ 行的整数代表第 $i$ 次行程公主能采到的花共有几种不同的颜色。

## 样例 #1

### 样例输入 #1

```
5 3 5
1 2 2 3 1
1 5
1 2
2 2
2 3
3 5
```

### 样例输出 #1

```
2
0
0
1
0
```

## 提示

#### 输入输出样例 $1$ 解释

共有五朵花，颜色分别为 $1,~2,~2,~3,~1$。

对于第一次行程，公主采花的区间为 $[1, 5]$，可以采位置 $1,~2,~3,~5$ 处的花，共有 $1$ 和 $2$ 两种不同的颜色。

对于第二次行程，公主采花的区间为 $[1, 2]$，但是颜色为 $1$ 和 $2$ 的花都只出现了一次，因此公主无花可采。

对于第三次行程，公主采花的区间为 $[2, 2]$，但是颜色为 $2$ 的花只出现了一次，公主无花可采。

对于第四次行程，公主采花的区间为 $[2, 3]$，可以采 $2,~3$ 位置的花，只有 $2$ 这一种颜色。

对于第五次行程，公主采花的区间为 $[3,5]$，但是颜色为 $1, 2, 3$ 的花都只出现了一次，因此公主无花可采。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有两个子任务**。

对于子任务 $1$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 3 \times 10^5$。

对于子任务 $2$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 2 \times 10^6$。

对于全部的测试点，保证 $1 \leq x_i \leq c$，$1 \leq l \leq r \leq n$。

## 题解
这一题相当于是问：给定一个区间，问在这个区间内有多少数出现了两次以上，这个时候，我们就需要用贡献法来计算。我们先把问题按照右端点排序后进行离线。


我们这一题可以选择用我们的二维数组或是用我们的分块算法去计算
回顾 hh 的项链，我们使用离线+树状数组，和 $last[j]$表示上一次出现 j 的位置，对于第 p 个的数 j,我们 $add(last[j],-1)$,$add(p,1)$,因为我们按照 r 排序，只用管最右边的一个，所以留下最右端的就可以，对于一个询问直接树状数组求区间和

比较一下这两道题的区别，同样是计算颜色不同的数量，但是这道题目要求只有存在两个相同颜色这个颜色才做出贡献，怎么办呢？

我们维护两个东西，$last1[j]$表示上上次出现j的位置,$last2[j]$表示上次出现j的位置

对于第p个的数j第一次出现j时没有用，我们直接记录$last1=p$;第二次出现j时，他就会产生代价，但值得注意的是我们不应该在第二次出现j的位置上+1，而是**在上一次出现的位置last1上+1**，这是因为我们按照r从小到大排序,比如2,2,3这个序列，如果我们在第二次出现2的位置上+1，变成(0,1,0)，当询问$[2,3]$就不对了,应该在倒数第二次出现的位置+1变成(1,0,0);

**两次以上出现，我们只需要在倒数第2次的位置上+1，其他位置上出现j全部为零**，实现：$add(last1[j],-1);add(last2[j],1),last1=last2,last2=j;$

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<set>
#include<vector>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 2000010
using namespace std;
struct node{
    int l,r,id;
}q[N];
int c[N],ans[N],n,m,k,color[N],first[N],next[N],nnext[N],b[N];
il bool cmp(node x,node y){return x.l<y.l;}
il int lowbit(int x){return x&(-x);}
il vd add(int x,int y){
    for(int i=x;i<=n;i+=lowbit(i)) c[i]+=y;
}
il int query(int x){
    int sum=0;
    for (int i=x;i>0;i-=lowbit(i)) sum+=c[i];
    return sum;
}
int main(){
    read(n),read(k),read(m);
    For(i,1,n) read(color[i]);
    Dow(i,n,1){
        next[i]=first[color[i]];
        first[color[i]]=i;
    }
    For(i,1,n)
        nnext[i]=next[next[i]];
    For(i,1,n)
        if (++b[color[i]]==2) add(i,1);
    For(i,1,m){
        read(q[i].l),read(q[i].r);
        q[i].id=i;
    }
    sort(q+1,q+1+m,cmp);
    int now=1;
    For(i,1,m){
        for (;now<q[i].l;now++){
            if (next[now]) add(next[now],-1);
            if (nnext[now]) add(nnext[now],1);
        }
        ans[q[i].id]=query(q[i].r)-query(q[i].l-1);
    }
    For(i,1,m) print(ans[i]),print('\n');
    flush();
}
```