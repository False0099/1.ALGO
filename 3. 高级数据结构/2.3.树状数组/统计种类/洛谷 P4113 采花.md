#种类问题 #权值线段树 #mex 
# [HEOI 2012] 采花

## 题目描述

萧薰儿是古国的公主，平时的一大爱好是采花。

今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。

花园足够大，容纳了 $n$ 朵花，共有 $c$ 种颜色，用整数 $1 \sim c$ 表示。且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴。同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。

由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了 $m$ 个行程，然后一一向你询问公主能采到的花共有几种不同的颜色。

## 输入格式

输入的第一行是三个用空格隔开的整数，分别代表花的个数 $n$，花的颜色数 $c$，以及行程数 $m$。

输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 朵花的颜色 $x_i$。

第 $3$ 行到第 $(m + 2)$ 行，每行两个整数 $l, r$，第 $(i + 2)$ 行的数字代表第 $i$ 次行程为第 $l$ 到第 $r$ 朵花。

## 输出格式

共输出 $m$ 行，每行一个整数。第 $i$ 行的整数代表第 $i$ 次行程公主能采到的花共有几种不同的颜色。

## 样例 #1

### 样例输入 #1

```
5 3 5
1 2 2 3 1
1 5
1 2
2 2
2 3
3 5
```

### 样例输出 #1

```
2
0
0
1
0
```

## 提示

#### 输入输出样例 $1$ 解释

共有五朵花，颜色分别为 $1,~2,~2,~3,~1$。

对于第一次行程，公主采花的区间为 $[1, 5]$，可以采位置 $1,~2,~3,~5$ 处的花，共有 $1$ 和 $2$ 两种不同的颜色。

对于第二次行程，公主采花的区间为 $[1, 2]$，但是颜色为 $1$ 和 $2$ 的花都只出现了一次，因此公主无花可采。

对于第三次行程，公主采花的区间为 $[2, 2]$，但是颜色为 $2$ 的花只出现了一次，公主无花可采。

对于第四次行程，公主采花的区间为 $[2, 3]$，可以采 $2,~3$ 位置的花，只有 $2$ 这一种颜色。

对于第五次行程，公主采花的区间为 $[3,5]$，但是颜色为 $1, 2, 3$ 的花都只出现了一次，因此公主无花可采。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有两个子任务**。

对于子任务 $1$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 3 \times 10^5$。

对于子任务 $2$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 2 \times 10^6$。

对于全部的测试点，保证 $1 \leq x_i \leq c$，$1 \leq l \leq r \leq n$。

## 题解
我们这一题和我们的[[洛谷 P4173 RMQ Promblem]] 问题是具有一定的相似性的。都是要统计我们在 $[l,r]$ 区间上我们所走过的数字的个数，这一题我们采用**离线的办法去计算**。
我们仿照[[洛谷 P4173 RMQ Promblem]] 的思路，我们树状数组维护的是我们权值范围内，我们的最后一次出现位置的最小值。
之后，我们将我们的询问离线后，按照我们的右端点进行排序。然后，我们就可以从左到右依次对我们的树状数组进行修改，并将修改后的树状数组作为我们每一个点的查询依据，来查询我们的答案。
这里，我们要求得答案应该满足下面几个要求：第一个我们是**最小**的一个数，第二个：我们的对应的最后一次出现的位置，**要比我们的 $l$ 要大**。对应的，我们把我们的**数值当作下表**（权值树状数组），把我们的**最后一次出现的位置当作我们的权值**。

这一题不同的是，我们的一个数字可以出现两次，因此我们可以开两个数组，`last1,last2`,分别记录我们上一次和上上次出现的位置。只有在我们的 `last1,last2` 都在我们的范围内的时候，我们才会让我们的答案++。

修改后再去进行我们的查询即可。

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<set>
#include<vector>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 2000010
using namespace std;
struct node{
    int l,r,id;
}q[N];
int c[N],ans[N],n,m,k,color[N],first[N],next[N],nnext[N],b[N];
il bool cmp(node x,node y){return x.l<y.l;}
il int lowbit(int x){return x&(-x);}
il vd add(int x,int y){
    for(int i=x;i<=n;i+=lowbit(i)) c[i]+=y;
}
il int query(int x){
    int sum=0;
    for (int i=x;i>0;i-=lowbit(i)) sum+=c[i];
    return sum;
}
int main(){
    read(n),read(k),read(m);
    For(i,1,n) read(color[i]);
    Dow(i,n,1){
        next[i]=first[color[i]];
        first[color[i]]=i;
    }
    For(i,1,n)
        nnext[i]=next[next[i]];
    For(i,1,n)
        if (++b[color[i]]==2) add(i,1);
    For(i,1,m){
        read(q[i].l),read(q[i].r);
        q[i].id=i;
    }
    sort(q+1,q+1+m,cmp);
    int now=1;
    For(i,1,m){
        for (;now<q[i].l;now++){
            if (next[now]) add(next[now],-1);
            if (nnext[now]) add(nnext[now],1);
        }
        ans[q[i].id]=query(q[i].r)-query(q[i].l-1);
    }
    For(i,1,m) print(ans[i]),print('\n');
    flush();
}
```