# [HNOI 2009] 梦幻布丁

## 题目描述

$n$ 个布丁摆成一行，进行 $m$ 次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。

例如，颜色分别为 $1,2,2,1$ 的四个布丁一共有 $3$ 段颜色.

## 输入格式

第一行是两个整数，分别表示布丁个数 $n$ 和操作次数 $m$。  
第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个布丁的颜色 $a_i$。  
接下来 $m$ 行，每行描述一次操作。每行首先有一个整数 $op$ 表示操作类型：
- 若 $op = 1$，则后有两个整数 $x, y$，表示将颜色 $x$ 的布丁全部变成颜色 $y$。
- 若 $op = 2$，则表示一次询问。

## 输出格式

对于每次询问，输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
4 3
1 2 2 1
2
1 2 1
2
```

### 样例输出 #1

```
3
1
```

## 提示

### 样例 1 解释
初始时布丁颜色依次为 $1, 2, 2, 1$，三段颜色分别为 $[1, 1], [2, 3], [4, 4]$。  
一次操作后，布丁的颜色变为 $1, 1, 1, 1$，只有 $[1, 4]$ 一段颜色。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, m \leq 10^5$，$1 \leq a_i ,x, y \leq 10^6$。

### 提示

请注意，**不保证**颜色的编号不大于 $n$，也**不保证** $x \neq y$，$m$ **不是**颜色的编号上限。

## 题解
**对于启发式合并，我们其实就是采用我们的一个暴力思路，但是我们可以用我们的启发式合并，来优化我们的暴力，来减少我们暴力的思路**

首先，如果我们给定了一个已经染色的区间，问我们有多少段，这是方便的，我们只需要比较我们当前位置和上一个位置是否相等，相等的话我们就认为段数不变的，否则我们认为是段数要加 1 的。

其次，我们每一次的修改，我们首先有：我们的段数与我们具体是什么颜色没有任何关系：1221=3443. 因此，我们对于修改而言，可以考虑比较我们修改部分的颜色，然后让我们比较小比分的颜色变成比较大部分的颜色。然后，**对于我们的每一次修改，我们对于答案的贡献可以通过我们的 $modify$ 函数计算得到，就是减去我们的老贡献、加上我们的新贡献即可**



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
const int M=1e8+10;
vector<int> pos[N];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		pos[a[i]].push_back(i);
	}
	for(int i=1;i<=n+1;i++){
		ans+=a[i]!=a[i-1];
	}
	for(int i=0;i<m;i++){
		int op;
		cin>>op;
		if(op==2){
			cout<<ans<<endl;
		}else{
			int x,y;
			cin>>x>>y;
			if(x==y){
				continue;
			}
			if(pos[x].size()>pos[y].size()){
				pos[x].swap(pos[y]);//我们互换一下颜色，保证我们的y是大集合 
			}
			if(pos[y].empty()) continue;
			int col=a[pos[y]][0]; 
			auto modify=[&](int p,int col){
				ans-=(a[p]!=a[p-1])+(a[p]!=a[p+1]);
				a[p]=col;
				ans+=(a[p]!=a[p-1])+(a[p]!=a[p+1]);
			}
			for(int p:pos[x]){
				modify(p,col);
				pos[y].push_back(p);
			} //修改我们的颜色 
			pos[x].clear();
		}
	}
}
```