# [ABC 329 F] Colored Ball

## 题面翻译

给定 $N$ 个盒子，每个盒子里面有一个颜色为 $C_i$ 的小球。有 $Q$ 次操作，每次操作将第 $a_i$ 个盒子中的球都放到第 $b_i$ 个盒子里面，你需要在每次操作后输出当前操作结束后第 $b_i$ 个盒子里面有多少个不同颜色的小球。

如果盒子为空，输出 $0$ 即可。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_f

$ 1,\ 2,\ \ldots,\ N $ の番号がついた $ N $ 個の箱があり、はじめ箱 $ i $ には色 $ C_i $ のボールが $ 1 $ つ入っています。

$ Q $ 個のクエリが与えられるので、これらを順に処理してください。

各クエリは整数の組 $ (a, b) $ によって与えられ、その内容は以下の通りです。

- 箱 $ a $ のボールをすべて箱 $ b $ に移し、その後箱 $ b $ に何種類の色のボールが入っているかを出力する。
 
ただし、箱 $ a $ や箱 $ b $ が空の場合もあることに注意してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。ここで、 $ \text{query}_i $ は $ i $ 番目のクエリを意味する。

> $ N $ $ Q $ $ C_1 $ $ C_2 $ $ \ldots $ $ C_N $ $ \text{query}_1 $ $ \text{query}_2 $ $ \vdots $ $ \text{query}_Q $

各クエリは次の形式で与えられる。

> $ a $ $ b $

## 输出格式

$ Q $ 行出力せよ。 $ i $ 行目には $ i $ 番目のクエリに対する答えを出力せよ。

## 样例 #1

### 样例输入 #1

```
6 5
1 1 1 2 2 3
1 2
6 4
5 1
3 6
4 6
```

### 样例输出 #1

```
1
2
1
1
3
```

## 样例 #2

### 样例输入 #2

```
5 3
2 4 2 4 2
3 1
2 5
3 2
```

### 样例输出 #2

```
1
2
0
```

## 提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 200000 $
- $ 1\ \leq\ C_i\ \leq\ N $
- $ 1\ \leq\ a,\ b\ \leq\ N $
- $ a\ \neq\ b $
- 入力される数値はすべて整数
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリでは、箱 $ 1 $ のボールをすべて箱 $ 2 $ に移します。箱 $ 2 $ には色 $ 1 $ のボールが $ 2 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 2 $ 番目のクエリでは、箱 $ 6 $ のボールをすべて箱 $ 4 $ に移します。箱 $ 4 $ には色 $ 2 $ のボールが $ 1 $ つ、色 $ 3 $ のボールが $ 1 $ つ入っている状態となるため、$ 2 $ を出力します。 - $ 3 $ 番目のクエリでは、箱 $ 5 $ のボールをすべて箱 $ 1 $ に移します。箱 $ 1 $ には色 $ 2 $ のボールが $ 1 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 4 $ 番目のクエリでは、箱 $ 3 $ のボールをすべて箱 $ 6 $ に移します。箱 $ 6 $ には色 $ 1 $ のボールが $ 1 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 5 $ 番目のクエリでは、箱 $ 4 $ のボールをすべて箱 $ 6 $ に移します。箱 $ 6 $ には色 $ 1 $ のボールが $ 1 $ つ、色 $ 2 $ のボールが $ 1 $ つ、色 $ 3 $ のボールが $ 1 $ つ入っている状態となるため、$ 3 $ を出力します。

## 题解
我们这一题要求我们处理每一次合并后，我们合并后区间内有多少种颜色。这个如果我们是暴力合并的话，我们就可以直接用我们的 stl 解决，但是这样的话会让我们的时间复杂度超标，于是我们就考虑启发式合并来优化。
我们每一次把大的箱子合并到小的箱子即可。
```cpp
#include <iostream>
#include <set>
using namespace std;
const int N = 2e5 + 20;
set<int> g[N];
int n,m;
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) {
        int x;
        cin >> x;
        g[i].insert(x);
    }
    for(int i = 1; i <= m; i++) {
        int a,b;
        cin >> a >> b;
        if(g[a].size() <= g[b].size()) {
            for(auto x : g[a]) {
                g[b].insert(x);
            }
            g[a].clear();
        } else {
            for(auto x : g[b]) {
                g[a].insert(x);
            }
            g[b].clear();
            swap(g[a],g[b]);
        }
        cout << g[b].size() << '\n';
    }
    return 0;
}
```