# 遍历问题

## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。

## 输入格式

共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。

## 输出格式

输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。

## 样例 #1

### 样例输入 #1

```
abc                           
cba
```

### 样例输出 #1

```
4
```


## 题解
我们有这么一个引理：在**一棵树上若有一个节点是只有一个子节点的**，那么这个子节点在左在右不影响我们先序或后序遍历的顺序，那么我们**总树数就要乘以 2**，为了找到只有一个子节点的节点数，

在先序遍历中某一元素 A 的后继元素 B，如果在后序遍历中 A 的前驱元素是 B，那么 A 只有一个子树，问题得解。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
char a[10002],b[10002];//分别记录前序和后序 
int main()
{
            scanf("%s\n%s",&a,&b);
            int len=strlen(a),ans=1;
            for(int i=0;i<=len-2;i++)
                     for(int j=0;j<=len-1;j++)
                              if(b[j]==a[i]&&b[j-1]==a[i+1]) ans*=2;
            cout<<ans;
            return 0; 
}
```