# 猫猫和企鹅

## 题目描述

王国里有 $n$ 个居住区，它们之间有 $n-1$ 条道路相连，并且保证从每个居住区出发都可以到达任何一个居住区，并且每条道路的长度都为 $1$。

除 $1$ 号居住区外，每个居住区住着一个小企鹅，有一天一只猫猫从 $1$ 号居住区出发，想要去拜访一些小企鹅。可是猫猫非常的懒，它只愿意去距离它在 $d$ 以内的小企鹅们。

猫猫非常的懒，因此希望你告诉他，他可以拜访多少只小企鹅。

## 输入格式

第一行两个整数 $n, d$，意义如题所述。

第二行开始，共 $n - 1$ 行，每行两个整数 $u, v$，表示居民区 $u$ 和 $v$ 之间存在道路。

## 输出格式

一行一个整数，表示猫猫可以拜访多少只小企鹅。

## 样例 #1

### 样例输入 #1

```
5 1
1 2
1 3
2 4
3 5
```

### 样例输出 #1

```
2
```

## 提示

对于 $100\%$ 的数据，满足 $1 \le n ,d \le 10^5$，保证所有居民区从 $1$ 开始标号。

## 题解
我们本题的操作之一就是要求我们距离 d 的距离小于 k 的点有多少个。我们的思路就是先求出每一个点到我们的根节点的距离分别是多少，然后我们进行一个统计即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
vector <int> g[123456];
bool vis[123456];
int ans,n,d;
void dfs(int now,int dis)
{
	vis[now]=1;
	if(dis==d) return;
	for(int i=0;i<g[now].size();i++)
	{
		if(!vis[g[now][i]])
		{
			dfs(g[now][i],dis+1);
			ans++;
		}
	}
}
int main()
{
	cin>>n>>d;
	for(int i=1;i<n;i++)
	{
		int a,b;
		cin>>a>>b;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(1,0);
	cout<<ans;
	return 0;
}
```

 