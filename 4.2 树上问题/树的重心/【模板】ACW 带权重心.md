# 知识点
  ## [[动态规划]] [[树形DP]] [[DFS]] [[求最值]]
# 题目
 给定一棵树，树中包含 $n$ 个结点（编号 $1-n$ ）和 $n−1$ 条无向边，每个点都有一个权值。

请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。

#### 输入格式

第一行包含整数 $n$。

接下来 $n−1$  行，每行包含三个整数 $a_{i},b_{i},c_{i}$ 表示点 $a_{i}$ 和 $b_{i}$ 之间存在一条权值为 $c_{i}$ 的边。

#### 输出格式

输出一个整数，表示所求点到树中其他结点的最远距离。

#### 数据范围

$1≤n≤10000$,  
$1≤ai,bi≤n$  
$1≤ci≤10^5$

#### 输入样例：

```
5 
2 1 1 
3 2 1 
4 3 1 
5 1 1
```

#### 输出样例：

```
2
```

# 思路
我们考虑根据我们的定义去进行计算，我们先求出我们向下子树的大小最大值，然后在计算出我们的向上子树的最大值。
其中，向上子树的最大值，可以通过我们用我们的树的总数 n 减去我们的以这个结点为我们的根节点的子树的大小和。于是，我们就可以写出我们的代码
```cpp
void dfs(int u,int fa){
	sz[u]=w[u];
	for(auto v:G[u]){
		if(v==fa){
			continue;
		}
		dfs(v,u);
		mx[u]=max(mx[u],mx[v]);
		sz[u]+=sz[v];
	}
	mx[u]=max(mx[u],n-sz[u]);
	if(mx[u]<mx[mxi]){
		mxi=u;
	}
}
```

