# [USACO 22 DEC] Circular Barn S

## 题目描述

Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \le N \le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \le a_i \le 5 \times 10^6)$。游戏玩法如下：

- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。
- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。
- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。

当两位农夫均采用最优策略时，求获胜的农夫。

## 输入格式

输入包含 $T$ 个子测试用例。输入的第一行包含 $T(1 \le T \le 1000)$。下面是 $T$ 个子测试用例。

每个子测试用例的第一行包含 $N$，第二行包含 $a_1, \cdots ,a_N$。

输入保证所有 $N$ 之和不超过 $2 \times 10^5$。

## 输出格式

对于每一个子测试用例，输出获胜的农夫，为 `Farmer John` 或 `Farmer Nhoj` 之一。

## 样例 #1

### 样例输入 #1

```
5
1
4
1
9
2
2 3
2
7 10
3
4 9 4
```

### 样例输出 #1

```
Farmer Nhoj
Farmer John
Farmer John
Farmer John
Farmer Nhoj
```

## 提示

### 样例 1 解释

对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。

对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。

对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。

对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$
、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 

### 测试点性质

- 测试点 $2-4$ 满足 $N=1$。
- 测试点 $1,2,5-7$ 满足 $a_i \le 1000$。
- 测试点 $8-20$ 没有额外限制。

## 题解
**Game 类题目，标准做法先手玩样例，再考虑极限情况**。**手玩不可操作，考虑我们的总共操作轮次是多少。**

我们本题首先，我们**对于 $n=1$ 的情况进行讨论**，也就是**先找我们的特殊情况**，如果我们满足我们的 $n=1$,那么我们就可以知道，如果我们有 $a[i]\%4=0$,那么我们就一定是先手必败，否则我们一定是先手必胜。

我们扩展到 $n>1$ 的情况。我们对于这一种游戏，我们通常都是**只关心我们进行多少轮，而不关心我们每一轮的具体操作**，于是我们就考虑计算我们对于每一个数字都会区**进行多少轮**。对于一个房间，如果在这个房间能赢得人一定想缩短我们的操作次数，因为操作的越快，我们后续翻盘的概率就越低。而我们输的人想让我们的操作次数一定是越多越好，因为我们操作的越慢，我们后面翻盘的概率就越大。所以我们只需要按照双方的策略算出操作次数，取最早结束的哪一个房间即可。

接下来，我们就知道，如果我们想要尽可能快的结束我们的比赛，我们一定是先去减去我们当前的比现在最大的质数是多少。我们的最后的结果就是 $\frac{a_{i}-p}{2}+1$ 次操作。如果我们想尽可能慢的结束我们的比赛，物品们最后一定是进行 $\frac{a_i}{2}$ 个操作。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=5e6;
int T,n,x,cnt,ans,mx[4],v[M+10],vis[M+10],prime[M];
void get_prime(int n){
	vis[1]=1;
	mx[1]=1;
	v[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]){
			prime[++cnt]=i;
			mx[i%4]=i;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
			vis[i*prime[j]]=1;
			if(!(i%prime[j])){
				break;
			}
		}
		v[i]=!(i%4)?i/2:(i-mx[i%4])/2+1;
	}
}
int main(){
	scanf("%d",&T);
	get_prime(M);
	while(T--){
		scanf("%d",&n);
		ans=1e9;
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			if(v[x]/2<ans/2)
				ans=v[x];
		}
		if(ans&1){
			puts("Farmer John");
		}
		else{
			puts("Farmer Nhoj");
		}
	}
	return 0;
}

```