# 欧几里德的游戏

## 题目描述

欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 $M$ 和 $N$，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 $0$。然后是 Ollie，对刚才得到的数，和 $M,N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$，他就取得了胜利。下面是他们用 $(25,7)$ 两个数游戏的过程：

- 初始：$(25,7)$；
- Stan：$(11,7)$；
- Ollie：$(4,7)$；
- Stan：$(4,3)$；
- Ollie：$(1,3)$；
- Stan：$(1,0)$。

Stan 赢得了游戏的胜利。

现在，假设他们完美地操作，谁会取得胜利呢？

## 输入格式

**本题有多组测试数据。**

第一行为测试数据的组数 $C$。
下面 $C$ 行，每行为一组数据，包含两个正整数 $M,N(M,N<2^{31})$。

## 输出格式

对每组输入数据输出一行，如果 Stan 胜利，则输出 `Stan wins`；否则输出 `Ollie wins`。

## 样例 #1

### 样例输入 #1

```
2
25 7
24 15
```

### 样例输出 #1

```
Stan wins
Ollie wins
```

## 提示

$1 \leq C \leq 6$。

## 题解
我们首先观察到，最终态为(0,x),如果达到这个状态，那么就是必胜态。
我们能推导出一个递归式子，如果(b,a%b)是必胜的，那么只有(b+a%b,b)是必失败的，其他所有符合$(b+kd,b)$ 的式子都是必胜的
如果(b,a%b)是必败的，那么所有(b+kd,b)的式子都是必胜的，这样我们就能递归的解决所有的问题。
```cpp
bool dfs(int a,int b){
	if(a<b) swap(a,b);
	if(b==0) return 0;
	if(dfs(b,a%b)==0||a>2*b) return 1;
	else return 0;
} 
```