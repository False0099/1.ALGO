#交互题 #博弈论 

# [NOIP 2010 普及组] 三国游戏

## 题目描述

小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。

在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。

游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵→计算机→小涵→……”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。

已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。下面举例说明计算机的选将策略，例如，游戏中一共有 $6$ 个武将，他们相互之间的默契值如下表所示：

 ![](https://cdn.luogu.com.cn/upload/pic/54.png) 

双方选将过程如下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/55.png) 

小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  

假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。

## 输入格式

共 N 行。

第一行为一个偶数 $N$，表示武将的个数。

第 $2 $行到第 $N$行里，第$ i+1 $行有$ N_i $个非负整数，每两个数之间用一个空格隔开，表示$ i $号武将和$ i+1, i+2,…, N $号武将之间的默契值（$0≤$ 默契值 $≤1,000,000,000$）。

## 输出格式

共一或二行。

若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出$ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。

## 样例 #1

### 样例输入 #1

```
6 
5 28 16 29 27 
23 3 20 1 
8 32 26 
33 11 
12
```

### 样例输出 #1

```
1
32
```

## 样例 #2

### 样例输入 #2

```
8 
42 24 10 29 27 12 58 
31 8 16 26 80 6 
25 3 36 11 5 
33 20 17 13 
15 77 9 
4 50 
19
```

### 样例输出 #2

```
1
77
```

## 提示

【数据范围】

对于$ 40\%$的数据有 $N≤10$。

对于$ 70\% $的数据有$ $N≤18$。

对于 $100\%$ 的数据有 $N≤500$。


## 题解
我们本题中，我们的计算机采用的是**贪心**的思路，即每一次操作的目的都是打断我们玩家取最优解。我们这一题的博弈思路是：每一次拿的都比我们的计算机的要大，起码不能比我们的计算机要小。
首先，我们证明，我们无论是玩家或者是我们的计算机，都不可能拿到一个武将的最佳搭配，所以，我们就可以考虑去采取下面的一个策略，我们先找到我们最佳的那一行或列，然后我们的计算机，一定会去选取我们的另一个阻止我们拿到最大值。这个时候，我们就可以拿我们那一列对应的次大值。这样我们得到的一定是最优的。
于是，我们的答案一定就是我们的**每一行的次大值的最大值**。

```cpp
```cpp
#include<bits/stdc++.h>
using namespace std;

//放到 main 外面去定义可以得到的好处：数组 mo 的中所有元素都会被默认赋值为 0
int mo[501][501],n;
int main()
{
    cin>>n;
    // 构造二维数组要用嵌套的 fo r循环，i 写入到数组第一维，j 写到数组第二维
    for(int i=1;i<=n;i++) {
        for(int j=i+1;j<=n;j++) {
            cin>>mo[i][j];
            //(i,j) 的对称位置是(j,i)
            mo[j][i]=mo[i][j];
        }
    }
    //ans 保存二维数组每一行次大值中的最大值
    int ans = 0;
    //对数组的第二维进行排序
    for(int i=1;i<=n;i++)
    {
        //对 mo 的每一行都排序，sort 默认是从小到大的
        sort(mo[i],mo[i]+n+1);
        //排序后每一行第二大的值是 mo[i][n-1]
        if(mo[i][n-1] > ans) 
            ans = mo[i][n-1];
    }

    cout<<1<<endl<<ans;
    return 0;
}
```
```