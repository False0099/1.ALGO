# [ABC 332 E] Lucky bag

## 题面翻译

你有 $n$ 个物品，第 $i$ 种物品重量为 $w_i$，将这些物品全部分到 $D$ 个盒子中，每个盒子的重量为其中物品重量之和，求盒子重量的方差最小值，答案误差在 $10^{-6}$ 之内。

允许存在盒子没有物品，此时其重量为 $0$ 。

$2\leq D\leq n\leq15$

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc332/tasks/abc332_e

AtCoder 社は、[オンラインショップ](https://suzuri.jp/AtCoder/home) でグッズを販売しています。

今、$ N $ 個のグッズが社内に残っています。 ここで、$ i $ $ (1\leq\ i\leq\ N) $ 個目のグッズの重さは $ W_i $ です。

高橋君は残ったグッズをまとめて $ D $ 袋の福袋として販売する事にしました。  
高橋君は各福袋に入ったグッズの重さの合計の分散を最小にしたいと考えています。  
ここで、各福袋に入ったグッズの重さの合計がそれぞれ $ x_1, x_2,\ldots, x_D $ であるとき、  
それらの平均を $ \bar{x}=\frac{1}{D}(x_1+x_2+\cdots+x_D) $ として、分散は $ V=\frac{1}{D}\displaystyle\sum_{i=1}^D\ (x_i-\bar{x})^2 $ として定義されます。

各福袋に入ったグッズの重さの合計の分散が最小になるようにグッズを分けた時の分散の値を求めてください。  
ただし、空の福袋が存在してもかまいません（この時福袋に入ったグッズの重さの合計は $ 0 $ として定義されます）が、  
**どのグッズも $ D $ 袋のうちちょうど $ 1 $ つの福袋に入っている** ようにするものとします。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ D $ $ W_1 $ $ W_2 $ $ \ldots $ $ W_N $

## 输出格式

各福袋に入ったグッズの重さの合計の分散が最小になるようにグッズを分けた時の分散の値を出力せよ。  
出力は、真の値との絶対誤差または相対誤差が $ 10^{-6} $ 以下のとき正解と判定される。

## 样例 #1

### 样例输入 #1

```
5 3
3 5 3 6 3
```

### 样例输出 #1

```
0.888888888888889
```

## 提示

### 制約

- $ 2\ \leq\ D\leq\ N\leq\ 15 $
- $ 1\ \leq\ W_i\leq\ 10^8 $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ つめの福袋に $ 1,3 $ 個目のグッズを、 $ 2 $ つめの福袋に $ 2,5 $ 個目のグッズを、 $ 3 $ つめの福袋に $ 4 $ 個目のグッズを入れると、 それぞれの福袋に入ったグッズの重さの合計は $ 6,8,6 $ となります。 このとき、重さの平均は $ \frac{1}{3}(6+8+6)=\frac{20}{3} $ であり、分散は $ \frac{1}{3}\left\{\left (6-\frac{20}{3}\right)^2+\left (8-\frac{20}{3}\right)^2+\left (6-\frac{20}{3}\right)^2\ \right\}=\frac{8}{9}=0.888888\ldots $ となり、このときが最小です。同じ重さのグッズが複数存在し得ること、各グッズはいずれかの福袋に入っている必要があることに注意してください。

## 题解
我们本体要求我们计算出我们把我们的 $N$ 个元素分成 $D$ 组，并且要求我们分组后每一组之间的方差最小，求最小值是多少。

我们考虑我们的状态压缩，我们设 $f[i][S]$ 表示我们目前一共选择的情况为 $S$ 的前提下，我们分成 $i$ 个袋子后，我们的状态最优是多少。显然，我们的 $f[i][S]$ 可以根据我们的子状态 $T\in S$ 来进行转移，这个时候，我们既有：$f[i][S]=f[i-1][T]+f[1]\left[ \frac{S}{T} \right]$。

然后，我们再去分别取最小值即可。这么做，我们的时间复杂度大致为 $o(3^n)$。**这里**，我们需要注意枚举子集状态转移的时候，我们应该用下面的方法来枚举子集：

```
int S;
for (int k = S; k; k = S & (k - 1))
```

于是，我们的所有障碍都已经扫除，现在我们考虑我们的结果。(**注意，记得要初始化的是偶要左移而不是右移**)

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=16;
const int S=1<<16;
int f[N][S];
signed main(){
	int n,d;
	cin>>n>>d;
	vector<int> a(n);
	int sum=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	memset(f,0x3f3f3f3f,sizeof f);
	for(int s=0;s<1<<n;s++)
	{
		f[1][s]=0;
		for(int i=0;i<n;i++){
			if(s&1<<i){
				f[1][s]+=a[i];
			}
		}
		f[1][s]*=f[1][s];
		//预处理 dp[1][s]，即只有一个袋子时 s 状态对应的总重平方
	}		
	for(int i=2;i<=d;i++){
		for(int s=0;s<1<<n;s++)
		{
			for(int t=s;t;t=s&t-1)
		
				f[i][s]=std::min(f[i][s],f[i-1][s^t]+f[1][t]);
		}
	}
	
	//cout<<f[d][(1<<n)-1];
	printf("%.15Lf",(f[d][(1<<n)-1]*d-sum*sum)*1.0l/d/d);
}
```