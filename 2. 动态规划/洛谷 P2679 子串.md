# [NOIP 2015 提高组] 子串

## 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 输入格式

第一行是三个正整数 $n,m,k$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。

第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。

第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。

## 输出格式

一个整数，表示所求方案数。

由于答案可能很大，所以这里要求输出答案对 $1000000007$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
6 3 1 
aabaab 
aab
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
6 3 2 
aabaab 
aab
```

### 样例输出 #2

```
7
```

## 样例 #3

### 样例输入 #3

```
6 3 3 
aabaab 
aab
```

### 样例输出 #3

```
7
```

## 提示

![](https://cdn.luogu.com.cn/upload/pic/1830.png) 

对于第 1 组数据: $1≤n≤500,1≤m≤50,k=1$;  
对于第 2 组至第 3 组数据: $1≤n≤500,1≤m≤50,k=2$;   
对于第 4 组至第 5 组数据: $1≤n≤500,1≤m≤50,k=m$;   
对于第 1 组至第 7 组数据: $1≤n≤500,1≤m≤50,1≤k≤m$;  
对于第 1 组至第 9 组数据: $1≤n≤1000,1≤m≤100,1≤k≤m$;   
对于所有 10 组数据: $1≤n≤1000,1≤m≤200,1≤k≤m$。

## 题解
我们假设有：状态 $f[i][j][d]$ 表示**我们 A 串的前 i 个字符**中**选择了 d 个子串**，**匹配了 B 串的前 j 个字符**。
这么做是不好转移的，所以我们要用一种全新的状态 $f[i][j][d][0/1]$ 表示 A 串前 i 个字符中选择 d 个字符串，匹配了 B 串的前 j 个字符而且**第 i 个字符选或不选**。
那么当我们**第 i 个字符不选，也就是不匹配时，他不属于任何一个子串**中他也不会和我们的字符串 B 进行匹配，**所以我们的 j 是不会变的**。我们的转移逻辑时，我们可以用前面的第 $i-1$ 个字符选货不选直接转换过来，并且由于我们没有用，我们的子串选择数量时不会改变的。因此我们的转移可以写成
$f[i][j][d][0]=f[i-1][j][d][1]+f[i-1][j][d][0]$


当我们的第 i 个字符与我们的第 j 个字符恰好相等时，我们可以考虑选或是不选，如果选，那么我们的方案数就由我们的 $f[i-1][j-1][d][1/0],f[i-1][j-1][d-1][1-0]$ 转移过来。因为我们的**子串必须是连续**的，所以最多**只能由 d-1 转移过来**。其中，d-1 表示我们另开一个子串，d 表示我们沿用上一个子串。


```cpp
#include<cstdio>
#include<iostream>
#define prime 1000000007
using namespace std;
char a[1001],b[201];
int n,m,t,f[2][201][201][2],s,now,pre=1;//s是用来记录之前有多少个A串字符能和B串第一个字符匹配
int main(){
    scanf("%d%d%d",&n,&m,&t);
    scanf("%s%s",a+1,b+1);//吐槽：这个奇葩的读入我以前一直没用过...
    for (int i=1;i<=n;i++){
        swap(now,pre); //交换，只要i改变
        f[now][1][1][0]=s;//边界1
        if (a[i]==b[1]) f[now][1][1][1]=1,s++;//边界2，解决了s统计的问题
        for (int j=2;j<=m;j++){
            for (int k=1;k<=t;k++){
                if (a[i]==b[j]){
                    f[now][j][k][1]=((f[pre][j-1][k-1][1]+f[pre][j-1][k][1])%prime+f[pre][j-1][k-1][0])%prime;
                }//方程2
                f[now][j][k][0]=(f[pre][j][k][0]+f[pre][j][k][1])%prime;//方程1
            }
        }
    for(int j=1;j<=m;j++)
          for(int k=1;k<=t;k++)
            f[pre][j][k][1]=f[pre][j][k][0]=0;//清空
    }
    printf("%d",(f[now][m][t][1]+f[now][m][t][0])%prime);
    return 0; 
}
```