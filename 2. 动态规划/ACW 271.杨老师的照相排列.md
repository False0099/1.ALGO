有 $N$ 个学生合影，站成左端对齐的 $k$ 排，每排分别有 $N_1, N_2, …, N_k$ 个人。 ($N_1 \ge N_2 \ge … \ge N_k$)

第 $1$ 排站在最后边，第 $k$ 排站在最前边。

学生的身高互不相同，把他们从高到底依次标记为 $1, 2, …, N$。

在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减。

问一共有多少种安排合影位置的方案？

下面的一排三角矩阵给出了当 $N=6, k=3,N_1=3,N_2=2,N_3=1$ 时的全部 $16$ 种合影方案。注意身高最高的是 $1$，最低的是 $6$。

```
123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146
45  46  35  36  34  36  34  35  25  26  24  26  24  25  26  25
6   5   6   5   6   4   5   4   6   5   6   4   5   4   3   3
```

#### 输入格式

输入包含多组测试数据。

每组数据两行，第一行包含一个整数 $k$ 表示总排数。

第二行包含 $k$ 个整数，表示从后向前每排的具体人数。

当输入 $k=0$ 的数据时，表示输入终止，且该数据无需处理。

#### 输出格式

每组测试数据输出一个答案，表示不同安排的数量。

每个答案占一行。

#### 数据范围

$1 \le k \le 5$,学生总人数不超过 $30$ 人。

#### 输入样例：

```
1
30
5
1 1 1 1 1
3
3 2 1
4
5 3 3 1
5
6 5 4 3 2
2
15 15
0
```

#### 输出样例：

```
1
1
16
4158
141892608
9694845
```

## 题解
### 算法

因为我们在我们的每一个序列中，我们的每行、每列的身高都是单调的，所以我们可以从高到低依次考虑标记为 1，2，3，4，... N。这样，在任意时刻，已经安排好位置的学生在每一行中占据的一定是从左端开始的若干个位置, **用一个 k 元组表示每一行已经安排的学生人数，我们即可描绘出已经处理部分的轮廓**。当我们安排一位新学生是：我们考虑所有满足条件的行号
$1.a_{i}<N_{i}$
2. $i=1\mid a_{i-1}>a_{i}$
只要这样，我们每一列的单调性也就得以满足。换言之，我们**不需要关心已经占站好的学生的具体方案，我们只需要转化为轮廓就能解决我们的问题**

##### (DP, 线性 DP) $O(k(\frac{N}{k})^k)$

核心性质：

> 从高到低依次安排每个同学的位置，那么在安排过程中，当前同学一定占据每排最靠左的连续若干个位置，且从后往前每排人数单调递减。否则一定不满足“每排从左到右身高递减，从后到前身高也递减”这个要求。

DP 的核心思想是用集合来表示一类方案，然后从集合的维度来考虑状态之间的递推关系。

受上述性质启发，状态表示为：

*   `f[a][b][c][d][e]` 代表从后往前每排人数分别为 `a, b, c, d, e` 的所有方案的集合, 其中 `a >= b >= c >= d >= e`；
*   `f[a][b][c][d][e]` 的值是该集合中元素的数量；

状态计算对应集合的划分，令最后一个同学被安排在哪一排作为划分依据，可以将 `f[a][b][c][d][e]` 划分成 5 个不重不漏的子集：

*   当 `a > 0 && a - 1 >= b` 时，最后一个同学可能被安排在第 1 排，方案数是 `f[a - 1][b][c][d][e]`；
*   当 `b > 0 && b - 1 >= c` 时，最后一个同学可能被安排在第 2 排，方案数是 `f[a][b - 1][c][d][e]`；
*   当 `c > 0 && c - 1 >= d` 时，最后一个同学可能被安排在第 3 排，方案数是 `f[a][b][c - 1][d][e]`；
*   当 `d > 0 && d - 1 >= e` 时，最后一个同学可能被安排在第 4 排，方案数是 `f[a][b][c][d - 1][e]`；
*   当 `e > 0` 时，最后一个同学可能被安排在第 5 排，方案数是 `f[a][b][c][d][e - 1]`；

#### 时间复杂度

由均值不等式，最坏情况下共有 $(\frac{N}{k})^k$ 状态，计算每个状态需要 $O(k)$ 的计算量，因此总时间复杂度是 $O(k(\frac{N}{k})^k)$。

#### C++ 代码

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 31;

int n;
LL f[N][N][N][N][N];

int main()
{
    while (cin >> n, n)
    {
        int s[5] = {0};
        for (int i = 0; i < n; i ++ ) cin >> s[i];
        memset(f, 0, sizeof f);
        f[0][0][0][0][0] = 1;

        for (int a = 0; a <= s[0]; a ++ )
            for (int b = 0; b <= min(a, s[1]); b ++ )
                for (int c = 0; c <= min(b, s[2]); c ++ )
                    for (int d = 0; d <= min(c, s[3]); d ++ )
                        for (int e = 0; e <= min(d, s[4]); e ++ )
                        {
                            LL &x = f[a][b][c][d][e];
                            if (a && a - 1 >= b) x += f[a - 1][b][c][d][e];
                            if (b && b - 1 >= c) x += f[a][b - 1][c][d][e];
                            if (c && c - 1 >= d) x += f[a][b][c - 1][d][e];
                            if (d && d - 1 >= e) x += f[a][b][c][d - 1][e];
                            if (e) x += f[a][b][c][d][e - 1];
                        }
        cout << f[s[0]][s[1]][s[2]][s[3]][s[4]] << endl;
    }

    return 0;
}
```

但同时，我们也可以用我们的组合数学中的杨氏表和钩子公式来进行迅速的计算（详情参见组合数学）