给定长度为 $N$ 的序列 $A$，构造一个长度为 $N$ 的序列 $B$，满足：

1.  $B$ 非严格单调，即 $B_1 \le B_2 \le … \le B_N$ 或 $B_1 \ge B_2 \ge … \ge B_N$。
2.  最小化 $S = \sum_{i=1}^N|A_i-B_i|$。

只需要求出这个最小值 $S$。

#### 输入格式

第一行包含一个整数 $N$。

接下来 $N$ 行，每行包含一个整数 $A_i$。

#### 输出格式

输出一个整数，表示最小 $S$ 值。

#### 数据范围

$1 \le N \le 2000$,  
$0 \le A_i \le 10^6$

#### 输入样例：

```
7
1
3
2
4
5
3
9
```

#### 输出样例：

```
3
```


## 题解
本题，我们可以通过把单调递增和单调递减分别处理的方法，来简化我们的题目，假设我们的题目构造后的数列是单调递增的，那么我们就有：
1. 如果是在原数列的某一部分是单调上升的，那么我们这一部分就直接照抄
2. 如果我们在原数列的某一部分是单调递减的，我们就构造这个区间的中位数。
3. 如果在原数列中既有上升也有下降，那么我们就构造两个组合的中位数。
上面的操作我们可以通过我们的可并堆来解决。

但是，我们既然放在了 dp 里，我们就考虑 dp 做法！

引理：在满足 S 最小化的前提下，一定存在一种构造序列 B 的方案，使得 B 中的数值都在 A 中出现过，于是我们考虑完成了前 i 个构造是，我们的绝对值的最小值是多少

我们可以发现，我们每一位的大小是多少，只要大于我们的前一位，那么我们的这个值就很好表示，因此我们用 $f[i][j]$ 表示我们更新到第 i 位，且我们的第 i 位选择了 j 时，我们目前已经有的最小答案是多少。我们于是可以这样转移
$f[i][j]=min(f[i][k]+|A_{i}-j|)(0\leq k\leq j)$
根据引理，我们可以把我们的 A 序列中出现的数离散化，把 DP 状态中第二位 j 的范围降低到 N，于是我们的复杂度就为 $o(n^2)$