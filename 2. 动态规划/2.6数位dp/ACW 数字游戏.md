# 知识点
  ## [[数位DP]] [[动态规划]] [[符合条件的总数]]
# 题目
 科协里最近很流行数字游戏。

某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。

现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$ ，问这个区间内有多少个不降数。

#### 输入格式

输入包含多组测试数据。

每组数据占一行，包含两个整数 $a$ 和 $b$ 。

#### 输出格式

每行给出一组测试数据的答案，即 $[a,b]$  之间有多少不降数。

#### 数据范围

$1≤a≤b≤2^{31}−1$  

#### 输入样例：

```
1 9
1 19
```

#### 输出样例：

```
9
18
```

# 思路b
·我们还是按照数位 dp 的的思路来做，我们回顾一下数位 dp 的的思路
·首先我们先预处理一下固定了一位后，剩下的总共的个数，这是一个只有剩余位数和当前的数字有关的，所以我们就可以先通过 dp 处理一下处理一下
·然后我们再把原来的数按照从大到小来分解，分解后的结果就是我们最后的结果
# *重点在于找到左边那一类如何直接计算*
# AC 代码
```cpp
void init(){
	for(int i=0;i<=9;i++){
		f[1][i]=i;
	}
	for(int i=2;i<n;i++){//表示一共有i位 
		for(int j=1;j<=9;j++){//表示起始位大小为j 
			for(int k=j;k<=9;k++){//列举比它大的所有数字 
				f[i][j]+=f[i-1][k];
			}
		}
	}
} 
void dfs(int n){
	vector<int> t;
	while(n){
		t.push_back(t%10);
		t/=10;
	}
	int res=0,last=0;//last表示起始位的大小 
	for(int i=t.size()-1;i>=0;i--){
		int x=t[i];
		for(int j=last;j<x;j++){
			res+=f[i+1][j];
		}
		if(x<last) break;//右序结束 
		last=x;
	}
	return ans;
}
```
# 备注
