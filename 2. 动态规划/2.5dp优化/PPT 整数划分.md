##  [[线性dp]] [[dp优化]]
## 题目描述
给出一个正整数序列，a1,a2,…,aN，将序列分成若干段，每段有一个权值，如将 ai,…,aj 划分成一段，则该段权值 F=(a(i)+a(i+1)+…+a(j))* i+T，求一种划分方案，使得每段的权值之和最小

## 提示
1<=N<=1000000
## 题解
设置 $dp[i]$ 表示把**区间**任意划分，并且 **j 是其中最后一段的末尾时**，我们所能得到的最大的结果。

我们的状态转移就可以写成 $dp[j]=min\left( s[i]-s[k]*i+t+f[k] \right)$。翻译为：我们把 $i-j$ 划分为 $i-k$ 和 $k+1$ 到 j 这一段，我们 $k+1$ 到 j 这一段可以直接计算出来，就是我们的 $(s[i]-s[k])*i+t$,而我们的 $0-k$ 又符合我们的定义，所以我们就可以用 dp 来计算。这是一个 $o(n^2)$ 的算法，对于我们的时间来说时不够的

我们不妨思考转移过程能否由优化的思路：我们发现，对于 $f[i]$ 的每一次转移，
**决策 k1优于 k2等价于**$(sum[i]-sum[k1])*i+T+f[k1]<(sum[i]-sum[k2])*i+T+f[k2]$，我们等价变形后可以得到
$$
i<(f[k2]-f[k1])/(sum[k2]-sum[k1])
$$

我们设 $g(k1,k2)=(f[k2]-f[k1])/(sum[k2]-sum[k1]),(k1<k2)$ 注意到 $g(k1,k2)$ 的值跟无关
则对于状态 $f[i]$,**决策 k 1 优于 k 2 等价于 g (k 1, k 2)>i**

我们用一个队列 k 来维护所有可能成为最优决策的决策

k 1<k 2<k 3<…<kn，那么 k 1, k 2,…, kn 应该满足：$i<g(k1,k2)<g(k2,k3)<…<g(kn-1,kn)$

我们在计算 $f[i]$ 的过程中维护此队列，则计算 $f[i]$ 时的最优决策即为 k1

•加入一个新决策 k：如果 $g(kn-1,kn)>g(kn,k)$，则 kn 为无用决策，将 kn 从队列中删除，如此反复直到满足 $g(kn-1,kn)<g(kn,k)$，将 k 插入队列尾部

•（2）删除决策：如果$g(k1,k2)<i$，则k1在以后的计算中都不会成为最优决策，将k1从队首删除
## 代码
```cpp

```