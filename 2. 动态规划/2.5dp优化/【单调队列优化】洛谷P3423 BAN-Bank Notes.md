# [POI 2005] BAN-Bank Notes

## 题目描述

`Byteotian Bit Bank(BBB)` 拥有一套先进的货币系统，这个系统一共有 $n$ 种面值的硬币，面值分别为 $b_1,b_2,\cdots,b_n$。但是每种硬币有数量限制，现在我们想要凑出面值 $k$，求最少要用多少个硬币。数据保证 $k$ 可以被凑出。

## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个整数 $b_i$，表示这 $n$ 种硬币的面值。

第三行 $n$ 个整数 $c_i$，表示这 $n$ 种硬币的数量。

第四行一个整数 $k$。

## 输出格式

第一行一个整数，表示最少需要多少个硬币。

第二行 $n$ 个整数，表示第 $i$ 种硬币需要多少个。

如果有多种方案，输出其中一种即可。

## 样例 #1

### 样例输入 #1

```
3
2 3 5
2 2 1
10
```

### 样例输出 #1

```
3
1 1 1
```

## 提示

对于 $100\%$ 的数据，$1 \le n \le 200$，$1 \le b_1 < b_2 < \cdots < b_n \le 2 \times 10^4$，$1 \le c_i \le 2 \times 10^4$，$1 \le k \le 2 \times 10^4$。

## 题解
本题，我们考虑先列出我们的 dp 转移方程，注意到这是一个非常典型的背包问题，于是我们就有转移如下所示：$f[i][j]=\max\{f[i][j],f[i-1][j-t*val[i]]+t\}$

于是，但是注意到我们本题中，我们的 $j$ 的范围很大，于是**我们考虑优化**，我们可以考虑使用我们的**j**, 即采用我们的单调队列优化。

我们首先需要知道**什么样的式子可以进行单调队列优化**，我们的式子必须形如：$max\{f[k]+t*k\}$,并且**不能出现类似于 y-k, 2 k** 这一类影响我们的团结的形式。

因此，我们可以判定，我们原来的 $f[i-1][j-t\times val[i]]+t$ 就不是一个**团结**的狮子，我们必须把我们的式子进行对应的转化，让它变成一个**团结的狮子**。

我们考虑有下面的转换方法：`d=c[i],a=j/c[i],b=j%c[i]`，于是我们就有：$j=a\times d+b$,那么我们的原方程就变为: $(j-k*d = a*d+b-k*d)$ $= (a-k)*d+b$

我们令 $a-k=k^{'}$。我们的原来的式子就变为：$f[i][j]=f[i-1][k'\times d+b]-k'\times w[i])+a\times w[i]$

其中我们的 $a$ 是一个常量，我们的内部的关于 $k$ 的式子也已经变得团结了这个时候，我们就只需要考虑我们的单调队列优化即可。例如：
```
for(int i=1;i<=n;i++)//枚举物品种类

{
    cin>>c[i]>>w[i]>>num[i];//c,w,num分别对应 体积,价值,个数
    if(V/c[i] <num[i]) num[i]=V/c[i];//求lim
    for(int mo=0;mo<c[i];mo++)//枚举余数
    {
        head=tail=0;//队列初始化
        for(int k=0;k<=(V-mo)/c[i];k++)//枚举我们这一次用多少个k
        {
            int x=k;//
            int y=f[k*c[i]+mo]-k*w[i];
            while(head<tail && que[head].pos<k-num[i])head++;//限制长度
            while(head<tail && que[tail-1].value<=y)tail--;//限制最优
            que[tail].value=y,que[tail].pos=x;
            tail++;
            f[k*c[i]+mo]=que[head].value+k*w[i];//求当前这一个值的最佳答案
            //加上k*w[i]的原因:
            //我们的单调队列维护的是前i-1种的状态最大值.
            //因此这里加上k*w[i].
        }

    }

}
```
