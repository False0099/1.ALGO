# [ABC 325 F] Sensor Optimization Dilemma

## 题面翻译

作为 Keyence 的工厂经理，您希望监控传送带上的几个区段。您总共要监控 $N$ 个部分，其中 $i$ -th 部分的长度为 $D_i$ 米。

有两种传感器可供选择，下面是每种传感器的一些信息。

- $j$ 型传感器 $(1\leq j \leq 2)$：可监控长度为 $L_j$ 米的路段。每个传感器的价格为 $C_j$，您最多可以使用 $K_j$ 个此类传感器。

您可以将一个区段分成几个区段进行监控。如果传感器监测的区域重叠，或者监测的区域长度超过您要监测的区域长度，也没有问题。例如，当 $L_1=4$ 和 $L_2=2$ 时，您可以使用一个 $1$ 型传感器来监控长度为 $3$ 米的区段，或者使用一个 $1$ 型和一个 $2$ 型传感器来监控长度为 $5$ 米的区段。

确定是否可能监控所有 $N$ 段，如果可能，求必要传感器的最低总成本。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_f

キーエンスの工場長であるあなたは、ベルトコンベア上のいくつかの区間をセンサーによって監視したいと考えています。 あなたが監視したい区間は全部で $ N $ 個あり、$ i $ 個目の区間の長さは $ D_i $ メートルです。

センサーには $ 2 $ 種類の候補があり、それぞれのセンサーに関する情報は以下の通りです。

- センサー $ j\ (1\leq\ j\ \leq\ 2) $ : 長さ $ L_j $ メートルの区間を監視できる。価格は $ 1 $ 個あたり $ C_j $ であり、全体で最大 $ K_j $ 個まで使用することができる。

$ 1 $ つの区間をいくつかの区間に分割して監視することもできます。 また、センサーが監視する区間が重なっていたり、監視したい区間の長さより余分に監視していたりしても問題はありません。例えば、$ L_1=4, L_2=2 $ であるとき、センサー $ 1 $ を $ 1 $ つ使って長さ $ 3 $ メートルの区間を監視したり、センサー $ 1,2 $ を $ 1 $ つずつ使って長さ $ 5 $ メートルの区間を監視したりすることが可能です。

$ N $ 個の区画をすべて監視することが可能であるか判定し、可能ならば必要なセンサーの価格の総和の最小値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ D_1 $ $ D_2 $ $ \dots $ $ D_N $ $ L_1 $ $ C_1 $ $ K_1 $ $ L_2 $ $ C_2 $ $ K_2 $

## 输出格式

$ N $ 個の区画をすべて監視することが不可能ならば `-1` を、可能ならば必要なセンサーの価格の総和の最小値を出力せよ。

## 样例 #1

### 样例输入 #1

```
3
3 5 10
4 3 3
2 2 6
```

### 样例输出 #1

```
17
```

## 样例 #2

### 样例输入 #2

```
3
3 5 10
4 3 3
2 2 3
```

### 样例输出 #2

```
-1
```

## 样例 #3

### 样例输入 #3

```
2
4 8
3 1 100
4 10000 100
```

### 样例输出 #3

```
5
```

## 提示

### 制約

- $1\leq\ N\ \leq\ 100$
- $1\leq\ D_i, L_j\ \leq\ 10^5$
- $1\leq\ C_j\ \leq\ 10^9$
- $1\leq\ K_j\ \leq\ 10^3$
- 入力は全て整数

### Sample Explanation 1

以下のようにすることで、センサー $ 1 $ を $ 3 $ つ、センサー $ 2 $ を $ 4 $ つ使ってすべての区間を監視できます。 - センサー $ 1 $ を $ 1 $ つ使って $ 1 $ 個目の区間を監視する。 - センサー $ 1,2 $ を $ 1 $ つずつ使って $ 2 $ 個目の区間を監視する。 - センサー $ 1 $ を $ 1 $ つ、センサー $ 2 $ を $ 3 $ つ使って $ 3 $ 個目の区間を監視する。 このとき、必要なセンサーの価格の総和は $ 3\times\ 3\ +\ 2\times\ 4\ =\ 17 $ であり、これが最小です。

### Sample Explanation 3

$ 1 $ つも使わない種類のセンサーがあっても構いません。

## 题解
首先，我们考虑下面的一种最最暴力的方法，我们设 $f(i,j,k)$ 表示我们处理前 $i$ 个，使用了 $j$ 种 1 类模板，$k$ 种 2 类木板，是否可行。

最后，我们就可以有下面的转移：
$f(i,j,k)=max(f(i-1,m,n)\land(i-m)*l_{1}+(j-n)*l_{2}>a[i]$。

这个时候，我们的复杂度达到了令人兴奋的 $o(nk^{4})$,显然是不能通过的，这个时候，我们就需要考虑优化，**我们的一个思想便是，把我们的状态作为我们的结果**。我们考虑让我们的 2 类模板作为我们是否可以的一个转移方法，这个时候，我们就有：
$f(i,j)$ 表示我们把我们的前 $i$ 个，使用了 $j$ 种 1木板，我们的 2 木板的最小个数是多少。

我们就有：
$f(i,j)=min\left( f(i-1,k)+\frac{a[i]-(j-k)*l_{1}}{l_{2}} \right)(a[i]\leq a[l])$.

最后，我们只需要检查我们的 $f(n,j)$ 是不是大于我们的 $k$ 即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
const int N=110;
const int K=1010;
int d[N];
int f[N][K];
int len1,cost1,count1;
int len2,cost2,count2;
int calc(int i,int cnt){
	return (max(d[i]-len1*(cnt),0ll)+len2-1)/len2;
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	cin>>len1>>cost1>>count1;
	cin>>len2>>cost2>>count2;
	memset(f,0x3f3f3f3f3f3f3f3f3f3f,sizeof f);
	for(int j=0;j<=count1;j++){
		f[0][j]=0;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=count1;j++){
			for(int k=0;k<=j;k++){
				f[i][j]=min(f[i][j],f[i-1][k]+calc(i,j-k));
			}
		}
	}
//	for(int i=1;i<=n;i++){
//		for(int j=0;j<=count1;j++){
//			cout<<f[i][j]<<" ";
//		}
//		puts("");
//	}
	int ans=0x3f3f3f3f3f3f3f3f3f3f;
	for(int j=0;j<=count1;j++){
		if(f[n][j]>count2){
			continue;
		}
		ans=min(ans,f[n][j]*cost2+j*cost1);
	}
	if(ans==0x3f3f3f3f3f3f3f3f3f3f){
		cout<<-1<<endl;
	}else{
		cout<<ans<<endl;
	}
}
```