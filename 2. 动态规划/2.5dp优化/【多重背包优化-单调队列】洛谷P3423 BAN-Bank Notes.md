# [POI 2005] BAN-Bank Notes

## 题目描述

`Byteotian Bit Bank(BBB)` 拥有一套先进的货币系统，这个系统一共有 $n$ 种面值的硬币，面值分别为 $b_1,b_2,\cdots,b_n$。但是每种硬币有数量限制，现在我们想要凑出面值 $k$，求最少要用多少个硬币。数据保证 $k$ 可以被凑出。

## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个整数 $b_i$，表示这 $n$ 种硬币的面值。

第三行 $n$ 个整数 $c_i$，表示这 $n$ 种硬币的数量。

第四行一个整数 $k$。

## 输出格式

第一行一个整数，表示最少需要多少个硬币。

第二行 $n$ 个整数，表示第 $i$ 种硬币需要多少个。

如果有多种方案，输出其中一种即可。

## 样例 #1

### 样例输入 #1

```
3
2 3 5
2 2 1
10
```

### 样例输出 #1

```
3
1 1 1
```

## 提示

对于 $100\%$ 的数据，$1 \le n \le 200$，$1 \le b_1 < b_2 < \cdots < b_n \le 2 \times 10^4$，$1 \le c_i \le 2 \times 10^4$，$1 \le k \le 2 \times 10^4$。

## 题解
本题，我们考虑先列出我们的 dp 转移方程，注意到这是一个非常典型的背包问题，于是我们就有转移如下所示：$f[i][j]=\max\{f[i][j],f[i-1][j-t*val[i]]+t\}$

众所周知，我们的上面的式子，可以转换为对于下面的式子进行 $k$ 次
$f[i][j]=\max(f[i-1][j-val[i]]+1)$

我们考虑枚举我们的 $val[i]$ 而不是枚举我们的 $i$,这个时候，我们看我们能否对于我们的其他元素进行对应的优化，根据调和计数，我们最多有 $\dfrac{m}{val[i]}$ 个物品能够用于我们的元素的枚举，也就是我们的 $k$ 的范围是属于我们的 $\left[ 0,\frac{m}{val[i]} \right]$。这个时候我们的伪代码就可以写成：这样做，我们可以把我们的时间复杂度有华为我们的 $o(m^2\log m)$。
```
for(int w=0;w<=W;w++){
	for(int j=0;j<=W;j++){
		for(int k=0;k<m/w;k++){
			f[j]=f[j-w]+calc(w,k);
		}
	}
}
```



这个时候，我们也只需要预处理出来我们的 $f[w][k]$,就可以完成我们的对应的转移，显然，我们的 $f[w][k]$ 表示，我们的总价值**不超过 w 的 qi 情况下，我们买 k 个元素时，我们的最小花费**。


 ```
for(int i=1;i<=n;i++)//枚举物品种类

{
    cin>>c[i]>>w[i]>>num[i];//c,w,num分别对应 体积,价值,个数
    if(V/c[i] <num[i]) num[i]=V/c[i];//求lim
    for(int mo=0;mo<c[i];mo++)//枚举余数
    {
        head=tail=0;//队列初始化
        for(int k=0;k<=(V-mo)/c[i];k++)//枚举我们这一次用多少个k
        {
            int x=k;//
            int y=f[k*c[i]+mo]-k*w[i];
            while(head<tail && que[head].pos<k-num[i])head++;//限制长度
            while(head<tail && que[tail-1].value<=y)tail--;//限制最优
            que[tail].value=y,que[tail].pos=x;
            tail++;
            f[k*c[i]+mo]=que[head].value+k*w[i];//求当前这一个值的最佳答案
            //加上k*w[i]的原因:
            //我们的单调队列维护的是前i-1种的状态最大值.
            //因此这里加上k*w[i].
        }

    }

}
```
