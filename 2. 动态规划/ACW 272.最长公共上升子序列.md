熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 $A$ 和 $B$ 的长度均不超过 $3000$。

#### 输入格式

第一行包含一个整数 $N$，表示数列 $A，B$ 的长度。

第二行包含 $N$ 个整数，表示数列 $A$。

第三行包含 $N$ 个整数，表示数列 $B$。

#### 输出格式

输出一个整数，表示最长公共上升子序列的长度。

#### 数据范围

$1 \le N \le 3000$,序列中的数字均不超过 $2^{31}-1$。

#### 输入样例：

```
4
2 2 1 3
2 1 2 3
```

#### 输出样例：

```
2
```


## 题解
我们这一题，考虑到我们的 LCS+LIS，我们可以设置状态如下 $f[i][j]$,表示我们从 i 到 j 所能形成的，**以 $b[J]$ 结尾**的最大的 LCIS 的长度。
显然，我们 f 数组的更新，依赖于我们上一位的信息，所以我们考虑怎么获取前面的信息
当我们的更新依赖于前面的信息时：我们一般有两种，如果我们前面的信息数量是规律性的，我们可以另外加一维来表示我们的不同选取，如果我们前面的是没有规律性的，我们就选择遍历我们该位置往前的所有位置来更新我们的信息。

因为有要求我们公共序列，所以我们就不能够让我们的 j 串变大，只能让我们的 i 串变大。

那么，当我们的 $A_{i}\neq B_{j}$ 时，我们的 $f[i][j]=f[i-1][j]$,当我们的 $A_{i}=B_{j}$ 时，我们有 $F[i][j]=max(F[i-1][k])+1(0\leq k<j,B_{k}<B_{j})$
于是我们可以三重循环来求解

```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(a[i]==b[j]){
			if(b[k]<a[i]){
				f[i][j]=max(f[i][j],f[i-1][k]+1)
			
		}else{
			f[i][j]=f[i-1][j];
		}
	}
}
```
然后我们发现每次循环求得的 maxv 是满足 $a[i] > b[k]$的 $f[i - 1][k] + 1$ 的前缀最大值。
因此可以直接将 maxv 提到第一层循环外面，减少重复计算，此时只剩下两重循环。

最终答案枚举子序列结尾取最大值即可。

时间复杂度
代码中一共两重循环，因此时间复杂度是 O (n 2)
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

Using namespace std;

Const int N = 3010;

Int n;
Int a[N], b[N];
Int f[N][N];

Int main ()
{
    Scanf ("%d", &n);
    For (int i = 1; i <= n; i ++ ) scanf ("%d", &a[i]);
    For (int i = 1; i <= n; i ++ ) scanf ("%d", &b[i]);

    For (int i = 1; i <= n; i ++ )
    {
        Int maxv = 1;
        For (int j = 1; j <= n; j ++ )
        {
            F[i][j] = f[i - 1][j];
            If (a[i] == b[j]) f[i][j] = max (f[i][j], maxv);
            If (a[i] > b[j]) maxv = max (maxv, f[i - 1][j] + 1);
        }
    }

    Int res = 0;
    For (int i = 1; i <= n; i ++ ) res = max (res, f[n][i]);
    Printf ("%d\n", res);

    Return 0;
}
```



