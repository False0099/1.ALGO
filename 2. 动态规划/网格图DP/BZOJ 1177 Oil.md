## 题目描述
采油区域 Siruseri政府决定将石油资源丰富的Navalur省的土地拍卖给私人承包商以建立油井。被拍卖的整块土地为一个矩形区域，被划分为M×N个小块。 Siruseri地质调查局有关于Navalur土地石油储量的估测数据。这些数据表示为M×N个非负整数，即对每一小块土地石油储量的估计值。 为了避免出现垄断，政府规定每一个承包商只能承包一个由K×K块相连的土地构成的正方形区域。 AoE石油联合公司由三个承包商组成，他们想选择三块互不相交的K×K的区域使得总的收益最大。 例如，假设石油储量的估计值如下： 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 8 8 8 1 1 1 1 8 8 8 8 8 1 1 1 1 8 8 8 8 8 1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1 9 9 9 1 1 1 1 1 1 9 9 9 如果K = 2, AoE公司可以承包的区域的石油储量总和为100, 如果K = 3, AoE公司可以承包的区域的石油储量总和为208。 AoE公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。

## 输入格式


输入第一行包含三个整数M, N, K，其中M和N是矩形区域的行数和列数，K是每一个承包商承包的正方形的大小（边长的块数）。接下来M行，每行有N个非负整数表示这一行每一小块土地的石油储量的估计值
## 输出格式

输出只包含一个整数，表示AoE公司可以承包的区域的石油储量之和的最大值。

## 样例 #1

### 样例输入 #1

```
12 12 3  
2 3 2 3 3 3 3 2 3 3 2  
3 3 3 2 2 3 3 4 2 2 3  
3 4 3 4 2 3 4 3 4 3 2  
4 4 4 5 3 2 4 4 4 3 3  
4 5 3 3 6 6 6 3 5 2 3  
5 5 4 5 5 6 6 4 5 3 2  
3 4 2 3 6 7 6 3 3 3 3  
2 3 3 3 2 2 2 2 3 4 3  
2 2 4 3 4 3 2 3 3 2 4  
3 3 3 3 2 4 3 3 3 2 3  
2 3 2 3 4 4 3 3 2 3 2  
3 3 3 3 3 3 4 2 3 4 3
```

### 样例输出 #1

```
119
```

## 提示
省流版：给出一个 n* n 矩阵，选出 3 个不相交的 $k*k$ 矩阵，使得权值最大。
## 题解
首先，我们这一题考虑用到前缀和，我们把一个矩形分成三块，有六种方法，![[Pasted image 20230911144732.png]] 我们如果按照这样分割的思想来做的话，就能够保证我们题目中要求的**不相交**。
因此我们**分别在切割后的三个部分中找到 $k*k$ 面积最大的，加起来就是答案**。
求出在每个部分中面积最大的，我们考虑计算数组 $ne[][],se[][],sw[][],nw[][]$,即以某个方块为定点的右上矩形，右下矩形，左下矩形，左上矩形中贡献最大的 $K*K$ 正方形的贡献；和计算数组 $hen[][],shu[][]$ 表示第 $i$ 排到第 j 排的横条的最大贡献和从第 i 列到第 j 列的竖条的最大贡献。

二维的区域和，我们可以用二维前缀和来实现，**这一点同样可以运用于我们的 dp 当中**，我们以 $nw[][]$ 数组为例，
![[Pasted image 20230911145305.png]]
如图，在 $(i,j)$ 的左上矩形中，任何 $K*K$ 的正方习惯，要么在淡蓝中，要么在深蓝中，要么都在。于是很容易写出 $$nw[i][j]=max(nw[i-1][j],nw[i][j-1],(i,j)左上角的K*K正方形的贡献)$$




## 代码
```cpp
```cpp
#include<bits/stdc++.h>
using namespace std;

int N,M,K;  //个人习惯，N才表示行
int s[1505][1505],k[1505][1505]; 
int ne[1505][1505],se[1505][1505],sw[1505][1505],nw[1505][1505];
int hen[1505][1505],shu[1505][1505];
int ANS;

int main(){
	cin>>N>>M>>K;
	for(int i=1;i<=N;i++)
	for(int j=1;j<=M;j++){
		int a;cin>>a;  //懒得设a数组了 
		s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a;
	}
	
	for(int i=K;i<=N;i++)  //左上K*K正方形 
	for(int j=K;j<=M;j++){
		k[i][j]=s[i][j]-s[i-K][j]-s[i][j-K]+s[i-K][j-K];//枚举以(i,j)为右下角的k*k正方形
	}
	
	for(int i=K;i<=N;i++)  //nw,sw,se,ne 
	for(int j=K;j<=M;j++)
		nw[i][j]=max(nw[i-1][j],max(nw[i][j-1],k[i][j]));
	for(int i=N-K+1;i>=1;i--)
	for(int j=K;j<=M;j++)
		sw[i][j]=max(sw[i+1][j],max(sw[i][j-1],k[i+K-1][j]));
	for(int i=N-K+1;i>=1;i--)
	for(int j=M-K+1;j>=1;j--)
		se[i][j]=max(se[i+1][j],max(se[i][j+1],k[i+K-1][j+K-1]));
	for(int i=K;i<=N;i++)
	for(int j=M-K+1;j>=1;j--)
		ne[i][j]=max(ne[i-1][j],max(ne[i][j+1],k[i][j+K-1]));
	
	for(int i=1;i<=N-K+1;i++) //横排 
	for(int j=K;j<=M;j++)
		hen[i][i+K-1]=max(hen[i][i+K-1],k[i+K-1][j]);
	for(int len=K+1;len<=N;len++)
	for(int i=1;i<=N-len+1;i++)
		hen[i][i+len-1]=max(hen[i+1][i+len-1],hen[i][i+len-2]);
		
	for(int j=1;j<=M-K+1;j++) //竖列 
	for(int i=K;i<=N;i++)
		shu[j][j+K-1]=max(shu[j][j+K-1],k[i][j+K-1]);//初始化
	for(int len=K+1;len<=M;len++)
	for(int j=1;j<=M-len+1;j++)
		shu[j][j+len-1]=max(shu[j+1][j+len-1],shu[j][j+len-2]);//更新
	
	for(int x1=K;x1<=N-K;x1++)  //统计,注意区域间千万不能有相交! 
	for(int x2=K;x2<=M-K;x2++){
		ANS=max(ANS,shu[1][x2]+ne[x1][x2+1]+se[x1+1][x2+1]); //图1 
		ANS=max(ANS,shu[x2+1][M]+nw[x1][x2]+sw[x1+1][x2]);   //图3
		ANS=max(ANS,hen[x1+1][M]+nw[x1][x2]+ne[x1][x2+1]);   //图4
		ANS=max(ANS,hen[1][x1]+sw[x1+1][x2]+se[x1][x2+1]);   //图6 
	}
	for(int x1=K;x1<=N-2*K;x1++)  //图2 
	for(int x2=x1+K;x2<=N-K;x2++)
		ANS=max(ANS,hen[1][x1]+hen[x1+1][x2]+hen[x2+1][N]);
	for(int x1=K;x1<=M-2*K;x1++)  //图4 
	for(int x2=x1+K;x2<=M-K;x2++)
		ANS=max(ANS,shu[1][x1]+shu[x1+1][x2]+shu[x2+1][N]);
	
	cout<<ANS;
```



