# 知识点
  ## [[动态规划]]
# 题目
 # [NOIP 2000 提高组] 方格取数

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

```plain
A
 0  0  0  0  0  0  0  0
 0  0 13  0  0  6  0  0
 0  0  0  0  7  0  0  0
 0  0  0 14  0  0  0  0
 0 21  0  0  0  4  0  0
 0  0 15  0  0  0  0  0
 0 14  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
                         B
```
某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

## 输入格式

输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。

## 输出格式

只需输出一个整数，表示 $2$ 条路径上取得的最大的和。

## 样例 #1

### 样例输入 #1

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 样例输出 #1

```
67
```

## 提示

NOIP 2000 提高组第四题

# 思路
***这一题不是个一般的题目，因为他要求走两次，我们可以以这样的思路来思考，我们召唤一个分身，让他跟我一起来走，最后我们要求的结果，就是这两个点加起来的距离的和。因此我们这题的状态表示为
$f[i][j][k][l]$,其中，前两个表示自己走到的位置（i，j），后两个表示分身走到的位置（k，l），整个表示我们第一个人走到（i，j），第二个人走到（k，l）时我们所能获得的最大价值
转移方程也是可以得到的 $f[i][j][k][l]=max(f[i-1][j][k][l],f)$
					$f[i][j][k][l]=max(f[i][j-1][k][l])$
					$f[i][j][k][l]=max(f[i][j][k-1][l],f)$
					$f[i][j][k][l]=max(f[i][j][k][l-1],f)$
因为每次走过了相同的点就要取出，所以我们还要加上一个判断语句
```cpp
if(i==k and j==l){
	f-=m[i][k];
}
```

# AC 代码
```cpp
#include <iostream>
using namespace std;
const int N=1e3+10;
int f[N][N][N][N];
int g[N][N];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>g[i][j];
		}
	}
	for(int i=0;i<n;i++){
	for(int j=0;j<m;j++){
	for(int k=0;k<n;k++){
	for(int l=0;l<m;l++){
		f[i][j][k][l]=max(f[i-1][j][k-1][l],f[i][j][k][l]);
		f[i][j][k][l]=max(f[i][j-1][k][l-1],f[i][j][k][l]);
		f[i][j][k][l]=max(f[i-1][j][k][l-1],f[i][j][k][l]);
		f[i][j][k][l]=max(f[i][j-1][k-1][l],f[i][j][k][l]);
		f[i][j][k][l]+=mp[i][j]+mp[k][l];
		if(i==k and j==l){
			f-=g[i][j];
		}
	}
	}
	}	
	}
}
```
# 备注
