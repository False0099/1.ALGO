# 知识点
  ## [[动态规划]] [[单调队列]]
# 题目
 烽火台是重要的军事防御设施，一般建在交通要道或险要处。

一旦有军情发生，则白天用浓烟，晚上有火光传递军情。

在某两个城市之间有 n 座烽火台，每个烽火台发出信号都有一定的代价。

为了使情报准确传递，在连续 m 个烽火台中至少要有一个发出信号。

现在输入 n,m,和每个烽火台的代价，请计算在两城市之间准确传递情报所需花费的总代价最少为多少。

#### 输入格式

第一行是两个整数 n,m，具体含义见题目描述；

第二行 n 个整数表示每个烽火台的代价 ai。

#### 输出格式

输出仅一个整数，表示最小代价。

#### 数据范围

$1≤m≤n≤2×10^5$  
$0≤ai≤1000$ 

#### 输入样例：

```
5 3
1 2 5 6 2
```

#### 输出样例：

```
4
```



# 思路
·连续 m 个烽火台等价于两个烽火台之间的间隔小于等于m
·根据上述的描述，我们可以写出状态方程 $f[i]=min(f[j]+w[i]),(0<i-j+1<m-1)$ 其中，$f[i]表示以 i 为右端点的前缀区间选择第i个的方案$
·如果我们直接枚举 j，也不是不可以，但是我们得知 j 是在一个区间范围内的，而且区间的长度是固定的，在必要的情况下，我们就可以选择用单调队列来优化。
# AC 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e5 + 10;

int n, m;
int w[N], f[N];
int que[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);

    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        while (hh <= tt && i - que[hh] > m) hh ++ ;
        f[i] = f[que[hh]] + w[i];
        while (hh <= tt && f[que[tt]] >= f[i]) tt -- ;
        que[ ++ tt] = i;
    }

    if (n + 1 - m > que[hh]) hh ++ ;   //滑动窗口往后滑动一位

    printf("%d\n", f[que[hh]]);

    return 0;
}

作者：一只野生彩色铅笔
链接：https://www.acwing.com/solution/content/67778/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
# 备注
