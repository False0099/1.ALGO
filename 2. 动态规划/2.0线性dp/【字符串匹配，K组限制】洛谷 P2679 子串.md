# [NOIP 2015 提高组] 子串

## 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 输入格式

第一行是三个正整数 $n,m,k$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。

第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。

第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。

## 输出格式

一个整数，表示所求方案数。

由于答案可能很大，所以这里要求输出答案对 $1000000007$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
6 3 1 
aabaab 
aab
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
6 3 2 
aabaab 
aab
```

### 样例输出 #2

```
7
```

## 样例 #3

### 样例输入 #3

```
6 3 3 
aabaab 
aab
```

### 样例输出 #3

```
7
```

## 提示

![](https://cdn.luogu.com.cn/upload/pic/1830.png) 

对于第 1 组数据: $1≤n≤500,1≤m≤50,k=1$;  
对于第 2 组至第 3 组数据: $1≤n≤500,1≤m≤50,k=2$;   
对于第 4 组至第 5 组数据: $1≤n≤500,1≤m≤50,k=m$;   
对于第 1 组至第 7 组数据: $1≤n≤500,1≤m≤50,1≤k≤m$;  
对于第 1 组至第 9 组数据: $1≤n≤1000,1≤m≤100,1≤k≤m$;   
对于所有 10 组数据: $1≤n≤1000,1≤m≤200,1≤k≤m$。

## 题解

对于这一类题，我们有一种抽象思路：把我们取 k 个子串，变成**取 k 个集合**，我们**dp最后一位表示我们在不在我们的第 k 个集合中**

本题中，我们可以采用 dp 的思路来解决我们的问题，我们设我们从字符串的 1-m 位置取出了我们的 j 个的方案数。我们可以考虑用我们类似于 LCS 的思路，我们设我们的状态为 $dp[i][j][k]$ 表示我们第一个字符串的前 i 位和我们第二个字符串的前 j 位匹配且用了 k 个子串的方案有多少。
但是这么做**不能解决不使用**和使用，所以我们要**添加一位表示我们是否使用了当前字符**于是我们的 dp 方程就变成了
$dp[i][j][k][0]=dp[i-1][j][k][0]+dp[i-1][j][k][1]$
$dp[i][j][k][1]=dp[i-1][j-1][k-1][0]+dp[i-1][j-1][k][1]+dp[i-1][j-1][k-1][1](a_{i}==b_{j})$



```cpp
```cpp
#include<cstdio>
#include<iostream>
#define prime 1000000007
using namespace std;
char a[1001],b[201];
int n,m,t,f[2][201][201][2],s,now,pre=1;//s是用来记录之前有多少个A串字符能和B串第一个字符匹配
int main(){
    scanf("%d%d%d",&n,&m,&t);
    scanf("%s%s",a+1,b+1);//吐槽：这个奇葩的读入我以前一直没用过...
    for (int i=1;i<=n;i++){
        swap(now,pre); //交换，只要i改变
        f[now][1][1][0]=s;//边界1
        if (a[i]==b[1]) f[now][1][1][1]=1,s++;//边界2，解决了s统计的问题
        for (int j=2;j<=m;j++){
            for (int k=1;k<=t;k++){
                if (a[i]==b[j]){
                    f[now][j][k][1]=((f[pre][j-1][k-1][1]+f[pre][j-1][k][1])%prime+f[pre][j-1][k-1][0])%prime;
                }//方程2
                f[now][j][k][0]=(f[pre][j][k][0]+f[pre][j][k][1])%prime;//方程1
            }
        }
    for(int j=1;j<=m;j++)
          for(int k=1;k<=t;k++)
            f[pre][j][k][1]=f[pre][j][k][0]=0;//清空
    }
    printf("%d",(f[now][m][t][1]+f[now][m][t][0])%prime);
    return 0; 
}
```
```