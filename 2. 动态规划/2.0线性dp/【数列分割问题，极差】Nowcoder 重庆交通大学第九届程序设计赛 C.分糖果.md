SummerWater 要在自己的生日宴会上将 $n$ 包糖果分给 $m$ 个小朋友。每包糖果都要分出去，每个小朋友至少要分一包，也可以分多包。

SummerWater 已经提前将糖果准备好了，为了在宴会当天能把糖果分得更平均一些，小李要先计算好分配方案。

SummerWater 将糖果从 $1$ 到 $n$ 编号，第 $i$ 包糖果重 $w_i$。小朋友从 $1$ 到 $m$ 编号。每个小朋友只能分到编号连续的糖果。请找一个方案，使得小朋友分到的糖果的最大重量和最小重量的差最小，请求出这个差。

例如，SummerWater 现在有 5 包糖果，重量分别为 6, 1, 2, 7, 9，如果 SummerWater 要分给两个小朋友，则最优的方案 (当然可能不止一个方案最优)是第一个小朋友分到 1 至 3 包糖果，重量为 9，第二个小朋友分到 4 至 5 包糖果，重量是 16，差为7。

再如，SummerWater 现在有 5 包糖果，重量分别为 6, 1, 2, 7, 9，如果 SummerWater 要分给三个小朋友，则最优的方案是第一个小朋友分到 1 至 3 包糖果，重量为 9，第二个小朋友分到第 4 包糖果，重量是 7，第三个小朋友分到第 5 包糖果，重量是 9，最大重量和最小重量的差最小，为2。

再如，SummerWater 现在有 5 包糖果，重量分别为 6, 1, 2, 7, 9，如果 SummerWater 要分给四个小朋友，则最优的方案是第一个小朋友分到第 1 包糖果，重量为 6，第二个小朋友分到 2 至 3 包糖果，重量是 3，第三个小朋友分到第 4 包糖果，重量是 7，第四个小朋友分到第 5 包糖果，重量是 9，最大重量和最小重量的差最小，为6。

再如，SummerWater 现在有 5 包糖果，重量分别为 6, 1, 2, 7, 9，如果 SummerWater 要分给五个小朋友，显然唯一的方案是每个小朋友分到一包，最大重量和最小重量的差为8。

## 输入
输入第一行包含两个整数 $n$ 和 $m$ ($1\leq n\leq 100,1\leq m \leq 50$)，分别表示糖果包数和小朋友数量。

第二行包含 $n$ 个整数 $w_1$, $w_2$, …, $w_n$ ($1\leq w_i \leq 1000$)，表示每包糖果的重量。

## 输出
输出一个整数，表示在最优情况下小朋友分到的糖果的最大重量和最小重量的差。

## 样例
输入
--

 5 3 6 1 2 7 9

```
5 3
6 1 2 7 9```

输出
--

 2

```

## 题解
我们这一题要求我们把我们的数组分成 m 段连续，然后我们要最小化我们的极差。
我们首先考虑最小化我们的最大值，显然有一个 $dp$, 
$f_{i,j}=\min_{0\leq k<j}\{f_{i,j},max\{f_{i-1,k},s_j-s_k\}\}$
要最小化我们的极差，我们的自然想法就是枚举我们的最小值，只有 $dp$ 在我们满足区间权值和大于等于这么枚举的最小值时才可以转移。

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

int s[N], a[N];
int f[N / 2][N];
bool has[100010];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            has[s[j] - s[i - 1]] = true;
    int res = 1e9;
    for (int mn = 1; mn * m <= s[n]; mn++) {
        if (!has[mn]) continue;
        memset(f, 0x3f, sizeof f);
        f[0][0] = mn;
        for (int i = 1; i <= m; i++)
            for (int j = 0; j <= n; j++)
                for (int k = 0; k < j; k++)
                    if (s[j] - s[k] >= mn)
                        f[i][j] = min(f[i][j], max(f[i - 1][k], s[j] - s[k]));
        res = min(res, f[m][n] - mn);
    }
    cout << res << '\n';
    return 0;
}
```
