# [ZJOI 2013] 话旧

## 题目描述

小林跟着银河队选手去了一趟宇宙比赛，耳濡目染，变得学术起来。回来后，他发现世界大变样了。比丘兽究级进化，成了凤凰兽；金先生因为发了一篇 paper，一跃成为教授，也成为了银河队选拔委员会成员。

一日，小林与金教授聊天。金教授回忆起过去的岁月，那些年他学过的电路原理。他曾经对一种三角波很感兴趣，并且进行了一些探究。小林感到很好奇，于是金教授就将课题形式化地说了一遍。

有一定义在 $[0,N]$ 的连续函数 $f(x)$，其中 $N$ 是整数，满足 $f(0)=f(N)=0$，它的所有极值点在整数处取到，且 $f(x)$ 的**极小值**均是 $0$。对于任意的 $0$ 到 $N-1$ 间的整数 $I$，$f(x)$ 在 $(I, I+1)$ 上是斜率为 $1$ 或 $-1$ 的一次函数。

金先生研究的是，若他知道其中 $K$ 个整点的函数值，那么：

1. 有多少个函数满足条件？
2. 满足条件的函数中，$f(x)$ 的最大值，最大能是多少？

小林思考了一下，便想出了很好的算法。那么作为经过多年训练的你呢？

## 输入格式

第一行包含两个用空格隔开的整数 $N,K$。接下来 $K$ 行，每行两个整数，表示 $x_i$ 和 $f(x_i)$。

## 输出格式

一行两个整数，分别对应两个问题的答案。考虑到第一问答案可能很大，你只要输出它除以 $19940417$ 的余数。

## 样例 #1

### 样例输入 #1

```
2 0
```

### 样例输出 #1

```
1 1
```

## 样例 #2

### 样例输入 #2

```
6 9
4 2
4 2
2 0
4 2
6 0
5 1
2 0
0 0
0 0
```

### 样例输出 #2

```
1 2
```

## 提示

- 对于 $10\%$ 的数据，$N \leq 10$。
- 对于 $20\%$ 的数据，$N \leq 50$。
- 对于 $30\%$ 的数据，$N \leq 100$，$K \leq 100$。
- 对于 $50\%$ 的数据，$N \leq 10^3$，$K \leq 10^3$。
- 对于 $70\%$ 的数据，$N \leq 10^5$。
- 另有 $10\%$ 的数据，$K=0$。
- 对于 $100\%$ 的数据，$ 0 \leq N \leq 10^9$，$0 \leq K \leq 10^6$。

## 题解
我们本题的思路是：因为我们的极小值为 0，所以我们**一旦下降，就必须走到 0**。假设我们有解的条件下：我们即当前是在上升还是在下降状态，我们记 $f[i][0/1]$ 表示我们到第 i 个点位置且第 i 个点为上/降。
考虑我们已知的相邻两个点之间的转移。记我们左边的为 $(x_{1},y_{1})$,右边的为 $(x_{2},y_{2})$,我们于是有下面的几种情况：
1. 左升右降
2. 左降右升
3. 左升右升
4. 左降右降

我们记讲到最低处时，我们的位置分别为 $(x_{1}',0),(x_{2}',0)$ 那么我们记我们

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=19940417;
const int MAXK=1000010;
struct Point
{
	int x,y;
};
bool operator<(const Point& a,const Point& b){return a.x<b.x;}
bool operator==(const Point& a,const Point& b){return a.x==b.x;}
Point p[MAXK];
ll f[MAXK][2];
ll qpow(ll a,ll b)
{
	ll ret=1;
	while(b)
	{
		if(b%2)ret=ret*a%mod;
		b/=2;
		a=a*a%mod;
	}
	return ret;
}
inline void add(ll &x,ll y)
{
	x=(x+y%mod)%mod;
}
int main()
{
	int n,k,tmax=0;
	scanf("%d%d",&n,&k);
	p[k+1].x=n;
	for(int i=1;i<=k;i++)scanf("%d%d",&p[i].x,&p[i].y);
	sort(p,p+k+2);
	k=unique(p,p+k+2)-p-1;
	f[0][1]=1;
	for(int i=1;i<=k;i++)
	{
		int x1=p[i-1].x,y1=p[i-1].y;
		int x2=p[i].x,y2=p[i].y;
		int len=x2-x1-y1-y2;
		tmax=max(tmax,x2-x1+y1+y2);
		if(x1-x2==y1-y2)
		{
			add(f[i][0],f[i-1][0]);
			if(y1==0)add(f[i][0],f[i-1][1]);
		}
		else if(x1-x2==y2-y1)
		{
			add(f[i][1],f[i-1][0]+f[i-1][1]);
		}
		else if(len<0)
		{
			add(f[i][1],f[i-1][0]);
			if(y1==0)add(f[i][1],f[i-1][1]);
		}
		else if(len==0)
		{
			add(f[i][1],f[i-1][0]);
			if(y1==0)add(f[i][1],f[i-1][1]);
			add(f[i][0],f[i-1][0]+f[i-1][1]);
		}
		else
		{
			ll t=(2*f[i-1][0]+f[i-1][1])*qpow(2,len/2-1)%mod;
			if(y2>0)add(f[i][0],t);
			add(f[i][1],t);
		}
	}
	printf("%lld %d\n",f[k][1],tmax);
	return 0;
}
```