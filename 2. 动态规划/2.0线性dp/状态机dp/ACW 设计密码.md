# 知识点
  ## [[KMP算法]] [[动态规划]] [[状态机]]
# 题目
 你现在需要设计一个密码 S，S需要满足：

S的长度是 N；
S只包含小写英文字母；
S不包含子串 T；
例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。

请问共有多少种不同的密码满足要求？

由于答案会非常大，请输出答案模 109+7 的余数。

## 输入格式
第一行输入整数 N，表示密码的长度。

第二行输入字符串 T，T 中只包含小写字母。

## 输出格式
输出一个正整数，表示总方案数模 10^9+7 后的结果。

## 数据范围
1≤N≤50
,
1≤|T|≤N，|T|是 T的长度。

## 输入样例 1：
2
A
## 输出样例 1：
625
## 输入样例 2：
4
Cbc
## 输出样例 2：
456924

# 思路
***首先看到这个非常缝合的题干，我们会考虑到有下面要素，一个是 kmp 算法，因为要匹配字串，而是暴力枚举，因为枚举一般都是通过 dfs 或 bfs 进行的。但这一题的复杂度显然不支持我们进行这样的遍历，所以我们要思考一些其他的方法。

# AC 代码
```cpp
#include <iostream>
int ne[N];
int main(){
	for(int i=2,j=1;j<n;j++){
		while(s[j+1]!=s[i]&&j){
			j=ne[j];
		}
		if(s[j+1]==s[i]){
			j++;
		}
		ne[i]=j;
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			for(int k='a';k<='z';k++){
				int u=j;
				while(u&&s[u+1]!=k) u=ne[u];
				if(s[u+1]==k) u++;
				if(u<m) f[i+1][u]=(f[i+1][u]+f[i][j])%mod;
			}
		}
	}
}
```
# 备注
