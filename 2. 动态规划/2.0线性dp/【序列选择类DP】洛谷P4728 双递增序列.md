# [HNOI 2009] 双递增序列

## 题目描述

考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \dots, a_n$ 的一个划分 $U=\{ a_{i_1}, a_{i_2}, \dots, a_{i_{n/2}} \}, V=\{ a_{j_1}, a_{j_2}, \dots, a_{j_{n/2}} \}=\{ a_1, a_2, \dots, a_n \}-U$，且 $i_1<i_2< \dots <i_{n/2}, a_{i_1}<a_{i_2}< \dots <a_{i_{n/2}}, j_1<j_2< \dots <j_{n/2}, a_{j_1}<a_{j_2}< \dots <a_{j_{n/2}}$。

比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\{3, 4, 8\}, V=\{1, 5, 7\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。

现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。

## 输入格式

第一行仅包含一个整数 $m$，表示需要判断 $m$ 个序列。  
接下来的 $m$ 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 $n$，表示序列的长度，随后的 $n$ 个整数表示序列本身的元素 $a_1, a_2, \dots, a_n$。同一行的各数之间用一个空格隔开。

## 输出格式

输出 $m$ 行，如果第 $i$ 个序列为好的序列，那么第 $i$ 行输出 `Yes!`，否则输出 `No!`。

## 样例 #1

### 样例输入 #1

```
2
6 3 1 4 5 8 7
6 3 2 1 6 5 4
```

### 样例输出 #1

```
Yes!
No!
```

## 提示

对于 $10\%$ 的数据，$n \le 100$。  
对于 $40\%$ 的数据，$n \le 300$。  
对于 $100\%$ 的数据，$1 \le n \leq 2000$，$1 \le m \leq 25$，$0 \le a_i \le 10^6$
。


## 题解
首先，我们如果考虑暴力 dp，我们需要知道下面的几个信息，才能进行我们的转移：
1. 我们的 a 类数组中的最后一个数是多少
2. 我们的 a 类数组的长度是多少
3. 我们的 b 类数组中的最后一个数是多少
4. 我们的 b 类数组的长度是多少。
于是我们的状态就有：$f[a][b][c][d]\to f[a+1][i][c][d]$, $f[a][b][c][d]\to f[a][b][c+1][i]$ 由于我们是一个可行性的转移，所以我们状态只需要设置为 bool 即可。

我们最后的时间复杂度就是 $o(n^4)$,显然不能够通过我们的本题。考虑优化。

优化一：首先我们知道我们处理到了第几个，也就是说我们的 c 是可以不需要枚举的，我们的 $c$ 直接用我们的 $i-a$ 就可以计算出来了。这时，我们的时间复杂度显然已经优化到了我们的 $o(n^3)$

优化二：我们可以知道，一个序列结尾的数越小，我们越容易去接我们的新的数字，因此，我们可以计算出我们在上述状态下，我们的末尾的最佳状况，一定是在我们的结尾去除我们的最优的时候，我们可以把这一维度设置到我们的 dp 结果当中去。于是我们的 dp 数组中就应该包含：
```
bool
min_last
```

这是，我们的转移显然就可以按照我们把我们的当前数字放到那一个集合中来分类，如果我们放在当前集合，我们就有：
$bool[len][last]\to bool[len+1][last+1]\&min[len+1][last+1]\to min(min[len][last])$ 
如果我们放到一个新的集合中，我们就有：
$bool[len][last]\to bool[len][last]\&min[len+1][last+1]=min(min[len+1][last+1],a[i])$

其中我们的 last 需要我们进行枚举，综上我们的复杂度仍然是我们的 $o(n^3)$

考虑到，如果我们一个点选中了，那么他一定是某个序列的结尾，那么我们怎么能够知道它的长度是多少，于是我们就需要设置一个状态 $j$ 表示 $i$ 所在集合的长度为多少。我们的状态转移就有：$dp[i-1][j]\to dp[i][j+1],(a[i]>a[i-1])$ (选定我们的 $i$ 和 $i-1$ 在同一个集合中), $dp[i-1][j]\to dp[i][i-j+1]$,这里表示我们选定的 $i$ 和 $i-1$ 不在同一个集合当中。

不包含 $A_i$ 的子序列长度为 $j$ ,则包含 $A_i$ 的子序列长度为 $i-j$ ,用 $dp_{i,j}$ 表示该子序列未尾的最小值。这样，我们就用两维的状态表示出了四个信息，最终答案是 $dp_{n,\frac n2}$ 

```cpp
#include <bits/stdc++.h>

using namespace std;

const int inf = 0x3f3f3f3f;
const int N = 2005; 

int T, n;
int a[N], dp[N][N];

int main() {
	cin >> T;
	while(T--) {
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) scanf("%d", a + i);
		memset(dp, 0x3f, sizeof dp);
		dp[1][1] = -inf;
		for(int i = 1; i < n; i++) {//由于我的转移是转移i+1，所以i<n。
			for(int j = 1; j <= min(n / 2, i); j++) {//剪去无用状态
				if(a[i] < a[i + 1]) dp[i + 1][j + 1] = min(dp[i][j], dp[i + 1][j + 1]);
				if(a[i + 1] > dp[i][j]) dp[i + 1][i - j + 1] = min(a[i], dp[i + 1][i - j + 1]);//转移
			}
		}
		if(dp[n][n / 2] == inf) puts("No!");
		else puts("Yes!");
	}	
	return 0;
}
```