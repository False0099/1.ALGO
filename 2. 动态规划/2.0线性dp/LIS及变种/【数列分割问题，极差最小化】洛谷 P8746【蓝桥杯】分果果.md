# [蓝桥杯 2021 省 A] 分果果

## 题目描述

小蓝要在自己的生日宴会上将 $n$ 包糖果分给 $m$ 个小朋友。每包糖果都要分出去，每个小朋友至少要分一包，也可以分多包。

小蓝已经提前将糖果准备好了，为了在宴会当天能把糖果分得更平均一些，小蓝要先计算好分配方案。

小蓝将糖果从 $1$ 到 $n$ 编号, 第 $i$ 包糖果重 $w_{i}$ 。小朋友从 $1$ 到 $m$ 编号。每个小朋友只能分到编号连续的糖果。小蓝想了很久没想出合适的分配方案使得每个小朋友分到的糖果差不多重。因此需要你帮他一起想办法。为了更好的分配糖果，**他可以再买一些糖果，让某一些编号的糖果有两份**。当某个编号的糖果有两份时，一个小朋友最多只能分其中的一份。

请找一个方案，使得小朋友分到的糖果的最大重量和最小重量的差最小，请输出这个差。

例如，小蓝现在有 5 包糖果, 重量分别为 $6,1,2,7,9$，如果小蓝要分给两个小朋友，则他可以将所有糖果再买一份，两个小朋友都分到 $1$ 至 $5$ 包糖果，重量都是 $25$, 差为 $0$。

再如，小蓝现在有 $5$ 包糖果, 重量分别为 $6,1,2,7,9$，如果小蓝要分给三个小朋友，则他可以将第 $3$ 包糖果再买一份，第一个小朋友分 $1$ 至 $3$ 包，第二个小朋友分 $3$ 至 $4$ 包，第三个小朋友分第 $5$ 包，每个小朋友分到的重量都是 $9$，差为 $0$。

再如, 小蓝现在有 5 包糖果, 重量分别为 $6,1,2,7,9$, 如果小蓝要分给四个小朋友，则他可以将第 $3$ 包和第 $5$ 包糖果再买一份, 仍然可以每个小朋友分到的重量都是 $9$，差为 $0$。

再如, 小蓝现在有 $5$ 包糖果, 重量分别为 $6,1,2,7,9$, 如果小蓝要分给五个小朋友, 则他可以将第 $4$ 包和第 $5$ 包糖果再买一份, 第一个小朋友分第 $1$ 至 $2$ 包重量为 $7$ , 第二个小朋友分第 $3$ 至 $4$ 包重量为 $9$, 第三个小朋友分第 $4$ 包重量为 $7$, 第四个和第五个小朋友都分第 $5$ 包重量为 $9$。差为 $2$。

## 输入格式

输入第一行包含两个整数 $n$ 和 $m$, 分别表示糖果包数和小朋友数量。

第二行包含 $n$ 个整数 $w_{1}, w_{2}, \cdots, w_{n}$, 表示每包糖果的重量。

## 输出格式

输出一个整数, 表示在最优情况下小朋友分到的糖果的最大重量和最小重量的差。

## 样例 #1

### 样例输入 #1

```
5 2
6 1 2 7 9
```

### 样例输出 #1

```
0
```

## 样例 #2

### 样例输入 #2

```
5 5
6 1 2 7 9
```

### 样例输出 #2

```
2
```

## 提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 10,1 \leq m \leq 10,1 \leq w_{i} \leq 10$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 30,1 \leq m \leq 20,1 \leq w_{i} \leq 30$;

对于所有评测用例, $1 \leq n \leq 100,1 \leq m \leq 50,1 \leq w_{i} \leq 100$ 。在评测数据中, $w_{i}$ 随机生成, 在某个区间均匀分布。

蓝桥杯 2021 第一轮省赛 A 组 J 题。

## 题解
这一题我们要最小化我们的极差，我们的思路都是枚举我们的最小值，然后求出在满足条件的前提下，我们的最大值最小是多少。然而这一题我们不能再简单的用我们的 $dp[i][j]$ 来进行转移，我们这一题因为我们不能有包含，所以我们的难点之一在于怎么设计我们的 $dp$,
首先，我们要推导出一个性质，就是我们的区间之间不会存在对应的包含关系，否则，我们一定可以通过变换，使得我们的结果更优。
我们可以发现，我们的第 $i$ 条线段的取值，和我们的第 $i-2$ 条的右端点有关，于是，我们就可以定义我们的 $f[i][j][k]$ 为选择了 $i$ 段区间，第 $i$ 段区间的末尾元素为 $w_{j}$,且第 $i+1$ 段区间的左端点可以在 $k$ 之后的最小的最大值。（k 也可以理解为我们最后一个选了两个的元素所在的位置）
我们的转移就有 $f[i][j][k]=f[i][j][k-1]$ (就是左端点在 $k-1$)之后也一定可以在 $k$ 之后，
第二种就是 $f_{i,j,k}=min\{f_{i,j,k},\max_{0\leq l\leq k}\{s_j-s_l,f_{i-1,k,l}\}\}$
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

int s[N], a[N];
int f[N / 2][N][N];
bool has[10010];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            has[s[j] - s[i - 1]] = true;
        }
    }
    int res = 1e9;
    for (int mn = 1; mn * m <= s[n] * 2; mn++) {
        if (!has[mn]) continue;
        memset(f, 0x3f, sizeof f);
        f[0][0][0] = mn;
        for (int i = 1; i <= m; i++) {
            for (int j = i; j <= n; j++) {
                for (int k = 0; k <= j; k++) {
                    if (k > 0) f[i][j][k] = f[i][j][k - 1];
                    for (int l = 0; l <= k; l++) {
                        if (s[j] - s[l] >= mn) {
                            f[i][j][k] = min(f[i][j][k], max(s[j] - s[l], f[i - 1][k][l]));
                        }
                    }
                }
            }
        }
        res = min(res, f[m][n][n] - mn);
    }
    cout << res << '\n';
    return 0;
}
```