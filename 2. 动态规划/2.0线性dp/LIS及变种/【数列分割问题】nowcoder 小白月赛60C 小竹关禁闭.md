妈妈成功将小竹救了出来，她觉得小竹实在是太笨了，决定关小竹一周禁闭。可是小竹哪里能忍受失去自由，他早就偷藏了一部手机用于联系你，请求你帮助他逃离。  
  
你通过观察发现他房间内有 $n$ 个可用于制成绳子的物品，第 $i$ 个的长度为 $a_i$ 。当你使用第 $i$ 个物品制作绳子时，其右侧的 $k$ 个物品（不含第 $i$ 个物品）就无法再被用于制作绳子。最终，小竹用选择的物品制成绳子，绳子的长度是所选择物品的长度之和。  
  
小竹想知道, 他能制作的绳子长度最长为多少？

第一行两个整数 $n,k(1 \le k\le n \le 2000)$。  
  
第二行 $n$ 个用空格隔开的整数，第 $i$ 个整数为 $a_i(1 \le a_i \le 2000)$，表示第 $i$ 个物品的长度。

一行一个整数，表示绳子的最长长度。

## 示例
输入
--

 5 2 1 2 3 4 5

```
5 2
1 2 3 4 5```

输出
--

 7

```

## 题解
我们这一题就是我们的典型的有后效性的 DP，我们的解决方案就是要么我们状态转移，要么我们就直接考虑暴力的转移，我们设置我们的 $dp[i]$ 表示我们用 0-i 所能构成的最长是多少，然后，我们就能发现，我们的转移就可以写成：$dp[i]=max(dp[j])+a[i]$,其中我们的 j 满足 $i-j\geq k$,看上去很符合我们单调队列的优化。

```cpp
代码如下：
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[2005];
int f[2005];
int ans;
 
int main()
{
    int n,k;
    cin>>n>>k;
   
    for(int i=1;i<=n;i++) cin>>a[i];
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(i-k-1<0) f[i]=a[i];
        else f[i]=f[i-k-1]+a[i];//可以转移
        f[i]=max(f[i],f[i-1]);
        ans=max(ans,f[i]);
    }
    cout<<ans<<endl;
    
      
    return 0;
 }
```

说明
--

```
使用第 $2$ 个和第 $5$ 个物品制成绳子```