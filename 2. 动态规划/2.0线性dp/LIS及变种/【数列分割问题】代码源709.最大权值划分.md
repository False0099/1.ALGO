
![[Pasted image 20231128153020.png]]
![[Pasted image 20231128153027.png]]

## 题解
我们这一题贪心的想法是：如果我们已经到达了我们的最终形态，那么我们的每一个**划分内都是单调不减**的，但我们也不能直接就把我们的数组分成一整个单调的块。
我们考虑我们的 $dp[i][1]$ 表示我们第 i 个数在上升序列的最大值，我们的 $dp[i][0]$ 表示我们第 $i$ 个数在下降序列的最大值，

我们遍历数组，如果我们有 $a[i]>a[i-1]$,如果我们希望我们的 $a[i]$ 在我们的上升序列中，那么我们需要讨论 $a[i-1]$ 是上升还是下降，
如果我们的 $a[i-1]$ 在下降序列中，那么我们就有 $dp[i][1]=dp[i-1][0]$,否则，我们就有 $dp[i][1]=dp[i-1][1]+a[i]-a[i-1]$,我们取最大值，我们就有：$dp[i][1]=max(dp[i-1][0],dp[i-1][1]+a[i]-a[i-1])$

如果我们希望 $a[i]$ 在下降序列中。
如果 $a[i]$ 在下降序列中，例如 $[8,5,4],[7]$ 虽然两者都是下降，但是我们不能合并，于是：$dp[i][0]=dp[i-1][0]$,
如果我们呢的 $a[i]$ 在上升序列中，我们就有 $dp[i][0]=dp[i-1][1]$

```cpp
void slove() {
    cin >> n;
    for (int i = 1; i <= n; i++)cin >> a[i];
    for (int i = 2; i <= n; i++) {
        if (a[i] > a[i - 1]) {
            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + a[i] - a[i - 1]);
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
        }
        else {
            //a[i] < a[i - 1]
            dp[i][0] = max(dp[i - 1][1], dp[i - 1][0] + a[i - 1] - a[i]);
            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]);
        }
    }
    cout << max(dp[n][0], dp[n][1]) << endl;
}
```