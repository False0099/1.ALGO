# 花店橱窗布置

## 题目描述

某花店现有 $F$ 束花，每一束花的品种都不一样。至少有同样数量的花瓶，被按顺序摆成一行。花瓶的位置是固定的，从左到右按 $1\sim V$ 顺序编号，$V$ 是花瓶的数目。

花束可以移动，并且每束花用 $1\sim F$ 的整数标识。所有花束在放入花瓶时必须保持其标识数的顺序。例如，假设杜鹃花的标识数为 $1$，秋海棠的标识数为 $2$，康乃馨的标识数为 $3$，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。每个花瓶只能放一束花。

每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数 $a_{i,j}$）来表示，空置花瓶的美学值为 $0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示：

|     | 花瓶 1  | 花瓶 2 | 花瓶 3 | 花瓶 4  | 花瓶 5 |
| --- | ----- | ---- | ---- | ----- | ---- |
| 杜鹃花 | $7$   | $23$ | $-5$ | $-24$ | $16$ |
| 秋海棠 | $5$   | $21$ | $-4$ | $10$  | $23$ |
| 康乃馨 | $-21$ | $5$  | $-4$ | $-20$ | $20$ |

根据表格，杜鹃花放在花瓶 $2$ 中，会显得非常好看，但若放在花瓶 $4$ 中，则显得很难看。

为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

## 输入格式

输入文件的第一行是两个整数 $F$ 和 $V$，分别为花束数和花瓶数。

接下来是矩阵 $a_{i,j}$，共 $F$ 行，每行 $V$ 个整数，$a_{i,j}$ 表示花束 $i$ 摆放在花瓶 $j$ 中的美学值。

## 输出格式

输出文件的第一行是一个整数，为最大的美学值；接下来一行 $F$ 个整数，为那束花放入那个花瓶的编号。

## 样例 #1

### 样例输入 #1

```
3 5
7 23 -5 -24 16
5 21 -4 10 23
-21 5 -4 -20 20
```

### 样例输出 #1

```
53
2 4 5
```

## 提示

对于 $100\%$ 的数据，$1\le F\le V\le 100$。

感谢 @罗恺提供 SPJ


## 题解
我们本题的思路很简单，如果我们不考虑任何优化，我们可以设 $dp[i][j]$ 表示我们把 $i$ 类花放在 $j$ 位置时，我们的最大价值时多少，于是我们就可以有从我们的 $dp[i-1][]$ 转移到我们的 $dp[i][]$,其中我们要满足 i 位置的 j 必须严格大于 i-1 位置的 j。

因此，我们的转移就是如下所示：
```cpp
dp[i][j]=dp[i-1][k]+g[i][j];
```

同时，因为我们还需要记录我们的最大值，所以我们还需要记录我们的答案：
```cpp
pre[i][j]=k;
```


```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<iostream>
#define max(a,b) a>b?a:b
#define debug(x) cout<<#x<<x<<endl;
#define debug1d(a,n)for(int i=1;i<=n;i++)cout<<"a["<<i<<"]="<<a[i]<<endl;
using namespace std;
int f,v,a[105][105],dp[105][105],pre[105][105],pos[105],maxx;
//a：第i朵花放在第j个花瓶的价值
//pre：dp[i][j]时，它的上一朵花的位置
//pos：最大值时，选取的花 
void input()//输入 
{
    scanf("%d%d",&f,&v);
    int i,j;
    for(i=1;i<=f;i++)
     for(j=1;j<=v;j++)scanf("%d",&a[i][j]);
}

int main()
{
    int i;
    input();
    {
    int i,j,k;
    j=1;
    memset(pre,0,sizeof(pre));
    for(i=1;i<=f;i++)
     for(j=1;j<=v;j++)
      dp[i][j]=-32767;
    for(i=1;i<=f;i++)dp[0][i]=0;
    //数据的初始化 
      
      
    //核心代码 
    for(i=1;i<=f;i++)
     for(j=i;j<=v;j++)
      {
           for(k=i-1;k<j;k++)
           if(dp[i][j]<dp[i-1][k]+a[i][j])
            {
                dp[i][j]=dp[i-1][k]+a[i][j];
                pre[i][j]=k;
            }
          
      }
    //核心代码完 
}
    
    
    maxx=-32767;
    for(i=1;i<=v;i++)
    {
        if(dp[f][i]>maxx){
            pos[f]=i;
            maxx=dp[f][i];
        }
    }
    //寻找最大值最后一朵花存放位置 
    
    printf("%d ",maxx);printf("\n");
    //每次从当前位置向前寻找上一个花的位置 
    for(i=f;pre[i][pos[i]]!=0;i--)
    {
        pos[i-1]=pre[i][pos[i]];
    }
    for(int i=1;i<=f;i++){
     printf("%d ",pos[i]);
    }
    return 0;
}
```