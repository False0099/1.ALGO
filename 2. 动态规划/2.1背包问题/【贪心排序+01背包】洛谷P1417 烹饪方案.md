# 烹调方案

## 题目背景

由于你的帮助，火星只遭受了最小的损失。但 gw 懒得重建家园了，就造了一艘飞船飞向遥远的 earth 星。不过飞船飞到一半，gw 发现了一个很严重的问题：肚子饿了 ~。

gw 还是会做饭的，于是拿出了储藏的食物准备填饱肚子。Gw 希望能在 $T$ 时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的 gw 只好求助于你了。

## 题目描述

一共有 $n$ 件食材，每件食材有三个属性，$a_i$，$b_i$ 和 $c_i$，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t\times b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

众所周知，gw 的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大。

## 输入格式

第一行是两个正整数 $T$ 和 $n$，表示到达地球所需时间和食材个数。

- 下面一行 $n$ 个整数，$a_i$；
- 下面一行 $n$ 个整数，$b_i$；
- 下面一行 $n$ 个整数，$c_i$。

## 输出格式

输出最大美味指数。

## 样例 #1

### 样例输入 #1

```
74 1
502
2
47
```

### 样例输出 #1

```
408
```

## 提示

### 数据范围及约定

- 对于 $40\%$ 的数据 $1 \le n \le 10$；
- 对于 $100\%$ 的数据 $1 \le n \le 50$。

所有数字均小于 $10^5$。

### 题目来源

Tinylic 改编

## 题解
我们本题首先如果我们不考虑我们的 b，我们本题就是一个简单的 0-1 背包问题，但是因为本题中存在 $b$ 相关的限制，所以我们直接通过我们的 0-1 背包问题计算不一定计算出我们的最优答案。

这是为什么？因为如果我们的 0-1 背包想要转移，一定要满足在这个时间下，在我们原来的定义 $f[i][j]$,会因为我们的 $i$ 的排序不同而导致我们的结果产生不同的差距。而我们因此需要找到一个可能的 $i$，让我们的结果尽可能的正确。

而我们要怎么样找到我们的这一个可能的 $i$,我们可以考虑用我们的临项交换法来尝试性的推导我们的式子。比如：我们假设我们原来的相邻的物品为 $(x,y)$,那么这个时候，我们就列出我们分别先做我们的 $(x,y)$ 的代价
$a[x]-(p+c[x])*b[x]+a[y]-(p+c[x]+c[y])*b[y]$
$a[y]-(p+c[y])*b[y]+a[x]-(p+c[y]+c[x])*b[x]$

对于我们的上面的式子化简，假如我们的 $(x,y)$ 是最优的，那么我们一定要满足：$c[x]*b[y]<c[y]*b[x]$,发现只要满足这个条件，我们的 $(x)$ 在 $y$ 前面就是更优的。

因此我们只需要根据我们的这一个进行排序，之后我们再去进行我们的 0-1 背包即可。

```cpp
#include<iostream>
#include<climits>
#include<algorithm>
#include<cstring>
#define LL long long
#define maxsize 100000
using namespace std;
struct obj {
	LL a, b, c;
}list[55];

LL dp[100005] = {};//定义dp[i][j]为考虑前i种食材，经过j时刻后的最大美味度

bool cmp(obj p, obj q) {
	return (LL)p.b*(LL)q.c > (LL)p.c*(LL)q.b;//满足该方程返回true，不换顺序
}

int main() {
	int T,n;
	cin >>T>>n;

	for (int i = 1; i <= n; i++) {
		cin >> list[i].a ;
	}
	for (int i = 1; i <= n; i++) {
		cin >> list[i].b;
	}
	for (int i = 1; i <= n; i++) {
		cin >> list[i].c;
	}

	sort(list+1, list +n+1, cmp);
	memset(dp, -1, sizeof(dp));
	dp[0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = T; j >=0; j--) {
			if (j >= list[i].c&&dp[j - list[i].c] != -1) {
				dp[j] = max(dp[j], dp[j - list[i].c] + list[i].a - j*list[i].b);
			}
		}
	}
	LL res = 0;
	for (int i = 0; i <= T; i++) {
		res = max(res, dp[i]);
	}
	cout << res;
	return 0;
}

```