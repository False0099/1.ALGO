# 知识点
  ## [[动态规划]]
# 题目
 总公司拥有 M台相同的高效设备，准备分给下属的 N个分公司。

各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。

问：如何分配这 M 台设备才能使国家得到的盈利最大？

求出最大盈利值。

分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 M
。

## 输入格式
第一行有两个数，第一个数是分公司数 N，第二个数是设备台数 M；

接下来是一个 N×M的矩阵，矩阵中的第 i行第 j列的整数表示第 i个公司分配 j台机器时的盈利。

## 输出格式
第一行输出最大盈利值；

接下 N行，每行有 2个数，即分公司编号和该分公司获得设备台数。

答案不唯一，输出任意合法方案即可。

## 数据范围
1≤N≤10
,
1≤M≤15
## 输入样例 ：
3 3
30 40 50
20 30 50
20 25 30
## 输出样例 ：
70
1 1
2 1
3 1

# 思路
***我们首先转换问题，原文中所求的，我们可以转换为我们的分组背包问题。很显然，我们规定的价值就是我们的生产的总数。我们的背包容量就是我们的分配给每一个人的台数，所以最后我们的结果是显然的，但是，因为这一题的背包价值不是线性的，我们的优化就基本失效了

**这一题还要求我们输出方案，背包问题输出方案我们可以采用 dfs 的方法，通过搜索动态规划的结果去求我们最开始的方案，我们不妨从图论的角度出发，我们把每一次转移都视作是从前一个状态转移到了后一个状态。这样的话原本我们要求的方案，就是求从起点到终点的最短路。且这条路是唯一的。又因为是一个拓扑图，所以我们可以直接用 dfs 去算。

# AC 代码
```cpp
#include <iostream>
using namespace std;
int f[N][N];
int w[N][N];
void dfs(int i, int j)
{
    if (!i) return;
    //寻找当前状态f[i][j]是从上述哪一个f[i-1][k]状态转移过来的
    for (int a = 0; a <= j; ++ a)
    {
        if (f[i - 1][j - a] + w[i][a] == f[i][j])
        {
            path[cnt ++ ] = a;
            dfs(i - 1, j - a);
            return;
        }
    }
}
int main(){
	int n,V;
	cin>>n>>V;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>w[i][j];
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			for(int k=0;k<m;k++){
				f[i][j]=max(f[i-1][j],f[i][j-k]+s[i][k]);
			}
		}
	}
	//输出方案
	
}
```
# 备注
