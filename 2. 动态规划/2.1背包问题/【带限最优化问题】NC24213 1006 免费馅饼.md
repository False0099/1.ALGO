  SERKOI 最新推出了一种叫做“免费馅饼”的游戏: 游戏在一个舞台上进行。舞台的宽度为 W 格，天幕的高度为 H 格，游戏者占一格。开始时游戏者站在舞台的正中央，手里拿着一个托盘。下图为天幕的高度为 4 格时某一个时刻游戏者接馅饼的情景。

![](https://uploadfiles.nowcoder.com/images/20180630/305473_1530368564528_B939E371B076E9BE71313B2C08C23104)  

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。  
馅饼有很多种，游戏者事先根据自己的口味，对各种馅饼依次打了分。同时，在 8-308 电脑的遥控下，各种馅饼下落的速度也是不一样的，下落速度以格/秒为单位。  
当馅饼在某一秒末恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。  
写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 输入：
第一行是用空格隔开的两个正整数，分别给出了舞台的宽度 W（1 到 99 之间的奇数）和高度 H（1 到 100 之间的整数）。  
接下来依馅饼的初始下落时间顺序给出了所有馅饼的信息。每一行给出了一块馅饼的信息。由四个正整数组成，分别表示了馅饼的初始下落时刻（0 到 1000 秒），水平位置、下落速度（1 到 100）以及分值。游戏开始时刻为 0。从 1 开始自左向右依次对水平方向的每格编号。  
输入文件中同一行相邻两项之间用一个或多个空格隔开

## 输出：
第一行给出了一个正整数，表示你的程序所收集的最大分数之和。  
其后的每一行依时间顺序给出了游戏者每秒的决策。输出 0 表示原地不动、1 或 2 表示向右移动一步或两步、-1 或-2 表示向左移动一步或两步。输出应持续到游戏者收集完他要收集的最后一块馅饼为止

## 题解
我们本题同时要记录方案和记录我们的最大分数。

发现我们本题中需要两个维度的信息，一个是时间，一个是位置，我们就可以设 $dp[t][x]$ 表示我们时间为 $t$ 时在 $x$ 位置，我们能获得的最大价值是多少。

于是，我们就可以通过我们的简单的状态转移来得到我们的答案。
$dp[t][x]=max(dp[t][x],dp[t-1][x-1]+g[t][x])$
$dp[t][x]=max(dp[t][x],dp[t-1][x-2]+g[t][x])$
$dp[t][x]=max(dp[t][x],dp[t-1][x+1]+g[t][x])$
$dp[t][x]=max(dp[t][x],dp[t-1][x+2]+g[t][x])$

同时，因为我们的初始状态在我们的重点，所以我们要把中点的值设置为 0。其他位置都设置为-1.

```cpp
#include <iostream>
using namespace std;
int n, m ;
long long g[10010][110], f[10010][110],q[10010];
int main (){
    cin >> n >> m;

    int t,x,v,w, ma = 0;
    while(cin >> t >> x >> v >> w){
        if((m-1) % v) continue;
        ma = max(ma,t + (m-1) / v);
        g[t + (m-1) / v][x] += w;
    }
    /*
    for(int i = 1; i <= ma; i++)
    {
        for(int j = 1; j <= n; j++) 
        {
            cout << g[i][j] << ' ';
        }
        cout << endl;
    }
    */
    for(int i = 0; i <= ma; i++)
        for(int j = 0; j <= n; j++) f[i][j] = -1;
    
    
    f[0][((n+2)-1)/2] = 0;
    int a;
    for(int i = 0; i <= ma; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            if(f[i][j] != -1)
            {
                for(int k = -2; k <= 2; k++)
                {
                    a = j + k;
                    if(a >= 1 && a <= n)
                    {
                        f[i+1][a] = max(f[i+1][a], f[i][j] + g[i+1][a]);
                    }
                }
            }
        }
    }
    int ans = 0, h;
    for(int i = 1; i <= n; i++) {
        if(ans < f[ma][i]){
            ans = f[ma][i];
            h = i;
        }
    }
    for(int i = ma - 1; i >= 0; i--){
        for(int j = h - 2; j <= h + 2; j++){
            if(j >= 1 && j <= n ){
                if(f[i+1][h] - g[i+1][h] == f[i][j]){
                    q[i] = h-j;
                    h = j;
                    break;
                }
            }
        }
    }
    
    cout << ans << '\n';
    
    for(int i = 0; i < ma; i++) cout << q[i] << '\n';
}
```