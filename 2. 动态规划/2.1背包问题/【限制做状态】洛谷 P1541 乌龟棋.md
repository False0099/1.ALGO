# [NOIP 2010 提高组] 乌龟棋

## 题目背景

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

## 题目描述

乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。


乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。


游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。


很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。


现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？

## 输入格式

每行中两个数之间用一个空格隔开。

第 $1$ 行 $2$ 个正整数 $N,M$，分别表示棋盘格子数和爬行卡片数。


第 $2$ 行 $N$ 个非负整数，$a_1,a_2,…,a_N$，其中 $a_i$ 表示棋盘第 $i$ 个格子上的分数。


第 $3$ 行 $M$ 个整数，$b_1,b_2,…,b_M$，表示 $M$ 张爬行卡片上的数字。


输入数据保证到达终点时刚好用光 $M$ 张爬行卡片。

## 输出格式

$1$ 个整数，表示小明最多能得到的分数。

## 样例 #1

### 样例输入 #1

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 样例输出 #1

```
73
```

## 提示

每个测试点 1 s。

小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。


对于 $30\%$ 的数据有 $1≤N≤30,1≤M≤12$。


对于 $50\%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。


对于 $100\%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。

## 题解
我们本题的思路如下：我们一共只有四种卡，我们统计我们每一张牌拥有的个数是多少，然后我们就可以 dp 了，我们设 $dp[i][j][k][l][m]$ 为我们在第 i 格，手上有 j 张 a 卡，k 张 b 卡，l 张 c 卡，m 张 d 卡时，所能获得的最大权值是多少，于是我们就可以用我们的记忆化搜索去计算，又因为我们**每张卡最多使用 k 张**，我们就可以取我们的

$dp[i][j][k][l][m]\to dp[i+1][j-1][k][l][m]$
$dp[i][j][k][l][m]\to dp[i+2][j][k-1][l][m]$
$dp[i][j][k][l][m]\to dp[i+3][j][k][l-1][m]$
$dp[i][j][k][l][m]\to dp[i+4][j][k][l][m-1]$

搜索如上所示，我们代码如下所示：
```cpp
#include<cstdio>
using namespace std;
int t[5],a[355],dp[45][45][45][45],n,m;
int max(int x,int y){return x>y?x:y;}
int dfs(int w,int x,int y,int z){
	if(dp[w][x][y][z])return dp[w][x][y][z];
	if(w==t[1]&&x==t[2]&&y==t[3]&&z==t[4])return a[n];//与其他题解不同之处，我是逆推的，于是需要加这条返回条件
	if(w<t[1])dp[w][x][y][z]=max(dp[w][x][y][z],dfs(w+1,x,y,z)+a[1+w+x*2+y*3+z*4]);
	if(x<t[2])dp[w][x][y][z]=max(dp[w][x][y][z],dfs(w,x+1,y,z)+a[1+w+x*2+y*3+z*4]);
	if(y<t[3])dp[w][x][y][z]=max(dp[w][x][y][z],dfs(w,x,y+1,z)+a[1+w+x*2+y*3+z*4]);
	if(z<t[4])dp[w][x][y][z]=max(dp[w][x][y][z],dfs(w,x,y,z+1)+a[1+w+x*2+y*3+z*4]);//分别考虑四张牌的情况
	return dp[w][x][y][z];
}
int main()
{
	n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		t[x]++;
	}
	dfs(0,0,0,0);
    //逆推无需赋初值
	printf("%d\n",dp[0][0][0][0]);//直接输出
	return 0;
}
```
