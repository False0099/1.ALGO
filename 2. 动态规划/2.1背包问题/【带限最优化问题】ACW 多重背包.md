# 知识点
  ## [[多重背包]]
# 题目
 有 N种物品和一个容量是 V的背包。

第 i种物品最多有 si件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

## 输入格式
第一行两个整数，N，V(0<N≤1000， 0<V≤20000)，用空格隔开，分别表示物品种数和背包容积。

接下来有 N行，每行三个整数 vi, wi, si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

## 输出格式
输出一个整数，表示最大价值。

## 数据范围
0<N≤1000

0<V≤20000

0<vi, wi, si≤20000
提示
本题考查多重背包的单调队列优化方法。

输入样例
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10

# 思路
***对于多重背包问题，我们向来都是有一个方法叫做直接暴力写转移方程的办法去完成这一道题目的，但是我们如果想要更优秀的时间复杂度，就需要用到单调队列优化多重背包，就像单调队列你能优化区间 DP 一样，

**就像单调队列可以优化区间 DP 的原理一样，单调队列优化区间 DP 的原理在于，我们要求的是一个区间内的最值，很难不去想到我们的单调队列，他就是能求出一个区间内最值的方法。

***观察一个多重背包的更新过程，我们能发现如下几点 1：每一次容量的更新都是在同余系下进行的，即更新只会从同余系中找对应的元素。
2.同余系中的元素的个数是有限的，而我们每一次都是要选择同余系中的一个最大值。

**因此，我们可以根据同余系去构造我们的单调队列，使得每一次更新只需要掉用一次数据就可以了。

**另外，我们还存在一种优化方法为二进制优化，即将多重背包划分为若干个二的倍数数量的 0-1 背包。然后我们就能一次获得一个简化的结果。

# AC 代码
```cpp
#include <iostream>
using namespace std;
const int N=1e6+10;
int f[N][N];
int n,V;
int w[N],s[N],v[N];
int main(){
	cin>>n>>V;
	for(int i=0;i<n;i++){
		int a,b,c;
		cin>>w[i]>>s[i]>>v[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=V;j++){
			for(int k=0;k<=s[i];k++){
				if(j-k*v[i]>=0){
				f[i][j]=max(f[i-1][j],f[i-1][j-k*v[i]]+k*w[i]);
				}
				f[i][j]=f[i-1][j];
			}
		}
	}
	cout<<f[n][V]<<endl;
}
//单调队列优化的部分
for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i] >> s[i];
    for (int i = 1; i <= n; ++ i)
    {
        for (int r = 0; r < v[i]; ++ r)//余数为r的同余系
        {
            de_queue<int> q;
            for (int j = r; j <= m; j += v[i])//除得的结果为j
            {//窗口长度不超过s（我们一共拥有的数量）
                while (!q.empty() && j - q.front() > s[i] * v[i]) q.pop_front();//(j-q.front)/v[i]>s[i];
                //我们的新值比旧值的更有价值，更大
                while (!q.empty() && f[i - 1][q.back] + (j - q.back) / v[i] * w[i] <= f[i - 1][j]) q.pop_back();
                q[ ++ tt] = j;
                q.push(j);
                f[i][j] = f[i - 1][q.front()] + (j - q.front()) / v[i] * w[i];//用前面的最长更新我们的现在的值
            }
        }
    }

```
# 备注
	