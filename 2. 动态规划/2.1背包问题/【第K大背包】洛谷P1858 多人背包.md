# 多人背包

## 题目描述

求 01 背包前 k 优解的价值和

DD 和好朋友们要去爬山啦！

他们一共有 K 个人，每个人都会背一个包。这些包的容量是相同的，都是 V。可以装进背包里的一共有 N 种物品，每种物品都有给定的体积和价值。

在 DD 看来，合理的背包安排方案是这样的： 每个人背包里装的物品的总体积恰等于包的容量。每个包里的每种物品最多只有一件，但两个不同的包中可以存在相同的物品。 

任意两个人，他们包里的物品清单不能完全相同。在满足以上要求的前提下，所有包里的所有物品的总价值最大是多少呢？

## 输入格式

第一行三个数 K、V、N

接下来每行两个数，表示体积和价值

## 输出格式

前 k 优解的价值和

## 样例 #1

### 样例输入 #1

```
2 10 5
3 12
7 20
2 4
5 6
1 1
```

### 样例输出 #1

```
57
```

## 提示

对于 100%的数据, $K\le 50,V\le 5000,N\le 200$

## 题解
本题的思路是：修改我们背包数组中的 $dp$，原本他是表示我们的最优解，现在我们修改意义，让他表示我们的前 $k$ 优解，于是，我们就可以采用一个类似于单调队列的思路，每一次就把我们的对应的比当前元素还要小的元素弹出去，直到我们我们假如这一个元素后我们的结果还是比我们的 $k$ 要优秀的。

我们注意到，我们每一次假如，最多最多只会删除掉我们的最后一个元素，于是，我们就可以通过我们的暴力中的暴力，每一次加入后排序来进行。

所以究其本质，其实我们的第 $k$ 大背包和我们的背包并没有什么不同，只是我们的条件转换的过程中，可能需要用一种或者用一类新的方法来存储我们的对应数据。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long 
signed main(){
	int k,vv,n;
	cin>>k>>vv>>n;
	vector<vector<int>> dp(vv+1);
	dp[0].push_back(0); 
	for(int i=0;i<n;i++){
		int val,cost;
		cin>>cost>>val;
		for(int j=vv-cost;j>=0;j--){
			sort(dp[j].rbegin(),dp[j].rend());
			if(dp[j].size()>k){
				dp[j].resize(k);
			}
			for(auto u:dp[j]){
				dp[j+cost].push_back(u+val);
			} 
		}
	}
	sort(dp[vv].rbegin(),dp[vv].rend());//为什么是rbegin 
	if(dp[vv].size()>k){
		dp[vv].resize(k);
	}
	cout<<accumulate(dp[vv].begin(),dp[vv].end(),0)<<endl;
	return 0;
}
```
