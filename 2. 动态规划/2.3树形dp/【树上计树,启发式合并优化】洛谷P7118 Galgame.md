# Galgame

## 题目背景

众所周知，as_lky 喜欢 Galgame。

## 题目描述

As_lky 搞到了很多 Galgame（真的很多！）。一款 Galgame 可以被描述为很多场景（Scene）的结合，它们形成了一棵 **以 1 为根** 的二叉树，每一个结点都是一个场景，一个结点的左儿子和右儿子分别对应在该场景选 A 选项和 B 选项能够到达的场景（可能会到达空场景，即游戏结束），我们称其为 A 场景和 B 场景。

As_lky 如下定义了两个不同的 Galgame 场景哪个更有趣（两款 Galgame 谁更为有趣也就取决于它们的初始场景谁更有趣）：

1. 如果这两个场景能够到达的场景总数（即通过任意选择能够到达的不同场景总数，包括该场景本身）不一样，那么能到达的场景数更多的那个更有趣；
2. 如果这两个场景的 A 场景不一样有趣，那么 A 场景更有趣的场景更有趣；
3. 否则这两个场景谁更有趣完全等价于他们 B 场景谁更有趣。

值得注意的是，空场景能到达的场景数被定义为 0。

![示例](https://cdn.luogu.com.cn/upload/image_hosting/4d2208qd.png)

例如，对于上图给出的例子（若无法正常查看请 `右键 -> 查看图像`），我们这样判定 1 和 7 这两个场景谁更有趣：

- 首先，1 和 7 能到达的场景数都是 6，因此我们首先尝试比较其 A 场景：2 和 8。
- 由于 2 和 8 能到达的场景数不同（分别是 3 和 2），则 2 场景比 8 场景更有趣；继而可以得到 1 场景比 7 场景更有趣。

As_lky 定义两个 Galgame 场景本质相同，当且仅当这两个场景都为空场景，或者它们的 A 场景本质相同且 B 场景本质相同。

as_lky 认为一款 Galgame 的有趣度是所有可能的、本质不同的、不及这款 Galgame 有趣的 Galgame 数量。现在 as_lky 给了你一款 Galgame，请告诉他这款 Galgame 的有趣度是多少。As_lky 觉得这个数字可能有些大，所以他想让你输出这个数字对 $998244353$ 取模的结果。

## 输入格式

第一行一个正整数 $n$，代表这款 Galgame 中共有多少场景。

接下来 $n$ 行，每行两个非负整数 $a_i$ 和 $b_i$，分别代表该场景的 A 场景和 B 场景，0 代表空场景。保证数据合法。

## 输出格式

一行一个非负整数，代表有趣度对 $998244353$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
3
0 2
3 0
0 0
```

### 样例输出 #1

```
4
```

## 样例 #2

### 样例输入 #2

```
7
2 3
4 5
6 7
0 0
0 0
0 0
0 0
```

### 样例输出 #2

```
410
```

## 样例 #3

### 样例输入 #3

```
9
2 3
4 5
0 0
0 0
6 7
0 0
8 9
0 0
0 0
```

### 样例输出 #3

```
5206
```

## 提示

### 样例解释

样例一：下图分别给出了 as_lky 给你的 Galgame（左）和所有四种没有该 Galgame 有趣的 Galgame（右）：（若无法正常查看请 `右键 -> 查看图像`）

![示例](https://cdn.luogu.com.cn/upload/image_hosting/oxer1eac.png)

### 测试点约束

**本题采用捆绑测试。**

对于全部数据，有 $1\le n\le 10^6$，$0\le a_i,b_i\le n$。

每个子任务的具体限制见下表：

| 子任务编号 | 分值 | $n\le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| 1 | 10 | $10$ | $\times$ |
| 2 | 20 | $5000$ | $\times$ |
| 3 | 30 | $10^6$ | $\surd$ |
| 4 | 40 | $10^6$ | $\times$ |

特殊性质：保证数据均匀随机生成，即 $n$ 给定时，若所有场景数为 $n$ 的本质不同 Galgame 共有 $S$ 种，则每种本质不同的 Galgame 出现概率均为 $\frac{1}{S}$。

**本题读入量较大，请使用较快的读入方式。**

## 题解
我们不难发现，我们本体来说，我们的计数**只和我们的子树大小相关**。于是，我们可以考虑对于一个已经确定形态的树，通过枚举我们的子树大小和我们的根节点的大小来进行我们的处理。

我们首先已经有，我们的根节点的数目为 $k$,那么这个时候，我们**显然，所有小于 k 的子树都可以选**。那么我们首先就有：$ans+=\sum_{k=1}^{n-1} f[k]$。

在这之后，我们考虑节点数目相同的情况，这种情况下，我们可以采用的方案应该有：
$ans+=\sum_{k=1}^{sz[l]-1}f[k]*f[n-k]$

上述式子表示我们给我们的左节点固定选 $k$ 个，我们的右节点任意选的情况。当我们的左节点数目相同的情况下，我们再去低轨道我们的右子树来求解。也就是说，我们综上我们就有下面的式子：$ans=\sum_{k=1}^{n-1}f[k]+\sum_{k=1}^{sz[l]-1}f[k]*f[n-1]+solve(sz[r])$。**这里我们的 solve 函数要求我们的总数保持不变**。其中我们的 $f[k]$ 显然就是我们的**卡特兰数**，

遗憾的是，我们的上述做法，我们的时间复杂度最后会达到我们的 $o(n^2)$

我们发现瓶颈在于 $\sum_{j=0}^{m-1}f_j\times f_{n-i-1}$,这个东西就是卡特兰数的递推式少了几项。不难发现 $\sum_{j=0}^{m-1}f_j\times$ $f_{n-i-1}=f_n-\sum_{j=0}^{n-m}f_j\times f_{n-i-1}$,于是每个子问题的操作次数都可以控制在 $\left\lceil\frac n2\right\rceil$ 以内 ($n$ 为子任务规模), 使用启发式合并，时间复杂度降到 $O(n\log n)$。

代码：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+10,p=998244353;
int n,ans,ls[maxn],rs[maxn],sz[maxn],inv[maxn],cat[maxn],f[maxn];
void init()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>ls[i]>>rs[i];
	for(int i=1;i<=n+1;i++)
	{
		if(i==1) inv[i]=1;
		else inv[i]=(p-p/i)*inv[p%i]%p; 
	}
	cat[0]=1;
	for(int i=1;i<=n;i++) cat[i]=cat[i-1]*(4*i-2)%p*inv[i+1]%p;
	for(int i=1;i<n;i++) ans=(ans+cat[i])%p;
}
void dfs1(int u)
{
	sz[u]=1;
	if(ls[u]) dfs1(ls[u]);
	if(rs[u]) dfs1(rs[u]);
	sz[u]+=sz[ls[u]]+sz[rs[u]];
}
void dfs(int u)
{
	if(ls[u]) dfs(ls[u]);
	if(rs[u]) dfs(rs[u]);
	f[u]=(f[ls[u]]*cat[sz[rs[u]]]%p+f[rs[u]])%p;
	if(sz[ls[u]]*2<sz[u])//左儿子比较小，我们只枚举左儿子
		for(int i=0;i<sz[ls[u]];i++) f[u]=(f[u]+cat[i]*cat[sz[u]-i-1]%p)%p;
	else
	{//右儿子比较小，我们改为枚举我们的右儿子
		f[u]=(f[u]+cat[sz[u]])%p;
		for(int i=sz[ls[u]];i<=sz[u];i++) f[u]=(f[u]-cat[i]*cat[sz[u]-i-1]%p+p)%p;
	}
}
signed main()
{
	init(); 
	dfs1(1);
	dfs(1); 
	cout<<(f[1]+ans)%p;
	return 0;
}
```