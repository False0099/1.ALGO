# [ABC 309 E] Family and Insurance

## 题面翻译

有一个家族，由 $1$ 号人，$2$ 号人，$\cdots$，$n$ 号人组成。对于 $i\geq2$ 的情况下，第 $i$ 号人的父亲是 $p_i$ 号人。

这个家族的成员购买了 $M$ 次保险。第 $i$ 次保险的投保人是 $x_i$ 号人，本人及其往后 $y_i$ 代子孙都是受保对象。

请计算一共有多少人成为了至少 $1$ 个保险的受保对象。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc309/tasks/abc309_e

人 $ 1 $、人 $ 2 $、$ \ldots $、人 $ N $ からなる家系があります。$ i\geq\ 2 $ に対し、人 $ i $ の親は人 $ p_i $ です。

この家系の人たちは $ M $ 回保険に加入しました。$ i=1,2,\ldots, M $ に対し、$ i $ 番目の保険の加入者は人 $ x_i $ で、本人及びその $ y_i $ 代先までの子たちが補償対象者です。

$ 1 $ 個以上の保険の補償対象者になっている人が何人いるかを求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ p_2 $ $ \ldots $ $ p_N $ $ x_1 $ $ y_1 $ $ \vdots $ $ x_M $ $ y_M $

## 输出格式

答えを出力せよ。

## 样例 #1

### 样例输入 #1

```
7 3
1 2 1 3 3 3
1 1
1 2
4 3
```

### 样例输出 #1

```
4
```

## 样例 #2

### 样例输入 #2

```
10 10
1 1 3 1 2 3 3 5 7
2 1
5 1
4 3
6 3
2 1
7 3
9 2
1 2
6 2
8 1
```

### 样例输出 #2

```
10
```

## 提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ p_i\ \leq\ i-1 $
- $ 1\ \leq\ x_i\ \leq\ N $
- $ 1\ \leq\ y_i\ \leq\ 3\ \times\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 番目の保険について、人 $ 1 $ の $ 1 $ 代先の子たちは人 $ 2 $ と人 $ 4 $ なので人 $ 1,2,4 $ が補償対象者です。 $ 2 $ 番目の保険について、人 $ 1 $ の $ 1 $ 代先の子たちは人 $ 2 $ と人 $ 4 $、$ 2 $ 代先の子は人 $ 3 $ なので人 $ 1,2,3,4 $ が補償対象者です。 $ 3 $ 番目の保険について、人 $ 4 $ の $ 1,2,3 $ 代先の子は存在しないので人 $ 4 $ が補償対象者です。以上より、$ 1 $ 個以上の保険の補償対象者になっている人は人 $ 1,2,3,4 $ の $ 4 $ 人です。

## 题解
我们考虑一种类似于“前缀和的思想”，考虑用 $dfs(u,x)$ 表示我们以 u 为根节点，向下传递 x 代后我们的人数和是多少。或者我们更直接的设置 $f_{x}$ 表示我们对应节点向下穿 x 代。然后我们就可以采用类似于“懒标记”的方法计算。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=2e6+5;
LL n,m,x,y,f[N],ans;
vector<LL>v[N];
void dfs(LL x)
{
	if(f[x]!=-1)ans++;
	for(LL i:v[x])
	{
		f[i]=max(f[i],f[x]-1);
		dfs(i);
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	f[1]=-1;
	for(int i=2;i<=n;i++)
	{
		f[i]=-1;
		scanf("%lld",&x);
		v[x].push_back(i);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);
		f[x]=max(f[x],y);
	}
	dfs(1);
	printf("%lld",ans);
}
```