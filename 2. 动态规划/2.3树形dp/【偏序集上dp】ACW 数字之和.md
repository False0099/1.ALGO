# 知识点
  ## [[动态规划]] [[树形DP]]
# 题目
 如果一个数 $x$ 的约数之和 $y$（不包括他本身）比他本身小，那么 $x$  可以变成 $y$ ，$y$  也可以变成 $x$ 。

例如，4 可以变为 3，1可以变为 7。

限定所有数字变换在不超过 $n$  的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。

#### 输入格式

输入一个正整数 n。

#### 输出格式

输出不断进行数字变换且不出现重复数字的最多变换步数。

#### 数据范围

$1≤n≤50000$ 

#### 输入样例：

```
7
```

#### 输出样例：

```
3
```

#### 样例解释

一种方案为：4→3→1→74→3→1→7。

# 思路
·我们首先将数字之和转换为求最长路径的问题。对于每一个数字，他所构成的约数之和是固定的，那么我们只需要从 0 开始初始化一个约数之和相关的数组，并且根据这个数组转化出来一颗树。
·之后我们就在这一片树中找到一个最大的距离，因为他们不一定都有着同一个根节点。
·其实上面的是无关紧要的，因为是不是根节点并不会影响我们每一次 dfs 后求得的结果。
# AC 代码
```cpp
#include <iostream>
using namespace std;
const int N=1e6+10；
int sum[N];
int dfs(int u){
	st[u]=true;
	int dist=0,d1=0,d2=0;
	for(int i=h[u];i！=-1；i=ne[i]){
		int j=e[i]
		if(!st[j]){
			int d=dfs(j);
			dist=max(dist,d);
			if(d>d1){
				d2=d1;
				d1=d;
			}else if(d>d2){
				d2=dist
			}
		}
	}
	ans=max(ans,d1+d2);
	return dist+1;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=2;j*i<n;j++){
			sum[i*j]+=i;	
		}
	}
	for(int i=2;i<n;i++){
		if(sum[i]<i){
			add(sum[i],i);//约数之和和这一个数的关系
		}
	}
	for(int i=0;i<n;i++){
		if(!st[i]){
			dfs(i);
		}
	}
	cout<<ans<<endl;
	return 0;
	
}
```
# 备注
	如果我们把约数之和改为约数，这个题目又要怎么做呢？