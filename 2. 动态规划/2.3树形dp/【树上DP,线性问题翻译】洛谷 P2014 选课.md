# 知识点
  ## [[树上dp]]
# 题目
 # [CTSC 1997] 选课

## 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？

## 输入格式

第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \leq N \leq 300$ , $1 \leq M \leq 300$ )

接下来的 $N$ 行, 第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第 I 门课的直接先修课，$s_i$ 表示第 I 门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \leq {k_i} \leq N$ , $1 \leq {s_i} \leq 20$）。

## 输出格式

只有一行，选 $M$ 门课程的最大得分。

## 样例 #1

### 样例输入 #1

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 样例输出 #1

```
13
```

# 思路
本题是树上背包的**典型题目**，我们用我们的 $f[i][j]$ 表示我们在 $i$ 这个结点，总背包容量剩余为 $j$,并且**强制选择 i**，能够获得的最大价值是多少。

显然，我们对于本题存在下面的转移 $f[i][j]=\max(f[v][w[i]]+v[i]+f[i][j-w[i]])$。于是，我们只需要按照我们的顺序去枚举我们的对应的价值即可。同时需要注意，我们的对应的初始化。
# AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
const int N=500;
const int M=500;
int f[N][M];
int h[N],ne[N],e[N],idx;
int w[N];
void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}
void dfs(int u){//
	
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		dfs(j);//
		for(int k=m+1;k>=1;k--){//从大到小枚举 ，否则错误 
			for(int l=0;l<k;l++){//从小到大枚举给子树分配的大小 
				f[u][k]=max(f[u][k],f[j][l]+f[u][k-l]);
			}
		}
	}
}
int main(){
	cin>>n>>m;
	memset(h,-1,sizeof h);
	for(int i=1;i<=n;i++){
		int a,b;
		cin>>a>>b;
		f[i][1]=b;
		add(a,i);//
	}
	dfs(0);
	cout<<f[0][m+1]<<endl;// 
}
```
# 备注
