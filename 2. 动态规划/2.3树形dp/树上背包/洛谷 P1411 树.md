# 树

## 题目背景

L 发明了一种与树有关的游戏。

## 题目描述

他从树中删除任意数量（可以为 $0$）的边，计算删除后所有连通块大小的乘积，L 将得到这么多的分数。

你的任务就是对于一颗给定的树，求出 L 能得到的最大分数。

## 输入格式

第一行一个整数 $n$，表示树的节点个数。

接下来 $(n-1)$ 行，每行两个整数 $u, v$，代表存在一条连接 $u, v$ 的边。

## 输出格式

输出一行一个整数，表示 L 能得到的最大分数。

## 样例 #1

### 样例输入 #1

```
5
1 2
2 3
3 4
4 5
```

### 样例输出 #1

```
6
```

## 样例 #2

### 样例输入 #2

```
8
1 2
1 3
2 4
2 5
3 6
3 7
6 8
```

### 样例输出 #2

```
18
```

## 样例 #3

### 样例输入 #3

```
3
1 2
1 3
```

### 样例输出 #3

```
3
```

## 提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 5$。
- 对于 $30\%$ 的数据，保证 $n \leq 100$。
- 另有 $30\%$ 的数据，保证给出的树是一条链。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 700$，$1 \leq u, v \leq n$。

## 题解
我们这一题考虑我们的一个树形 dp。
我们按照 dp 的三个步骤来进行思考：
我们的操作是什么？我们的操作是每次可以删除一条边.

我们每一次操作后，对于我们的状态有什么影响？我们每一次操作后，我们就被分为了两个部分，一个部分是我们的子树部分，另外的记作其他部分。

我们是否满足最优性？我们满足的，如果我们让我们的一个子节点取到了我们的最优，那么我们的剩下的部分一定也能取到最优。

我们能否从我们的 dp 结果还原出我们每一个位置的答案？

于是我们考虑下面的一种 dp 方法：我们令 $dp[i][j]$ 为我们以 i 为根节点，与他相连的**向下的**连通块大小为 j 的时候，我们的结果是多少。
$f(u,i)=max\{f(u,i),f(e,j)∗f(u,i−j)\}$

特别的，对于我们的 $f[u][0]$ 表示切断该节点与父亲节点的连边的最大贡献。


```cpp
int dfs(int u,int fa){
    sz[u]=1;dp[u][0]=1;dp[u][1]=1;
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        if (v!=fa){
            dfs(v,u);
            sz[u]+=sz[v];
            for (int j=sz[u];j>=0;j--)
                for (int k=min(j,sz[u]-sz[v]);k>=max(1,j-sz[v]);k--)//这个分组背包有很多种写法
                    ChkMax(dp[u][j],dp[u][k]*dp[v][j-k]);
        }
    }
    for (int i=1;i<=sz[u];i++)
        ChkMax(dp[u][0],dp[u][i]*i);
}
```