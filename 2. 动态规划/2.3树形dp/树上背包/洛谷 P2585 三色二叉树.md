# 知识点
  ## [[树形DP]]
# 题目
 # [ZJOI 2006]三色二叉树

## 题目描述

一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：

$$S=
\begin{cases}
0& \text表示该树没有子节点\\
1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\
2S_1S_2& 表示该树由两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列
\end{cases}$$

例如，下图所表示的二叉树可以用二叉树序列 $S=\texttt{21200110}$ 来表示。

![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)

你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。

## 输入格式

输入只有一行一个字符串 $s$，表示二叉树序列。

## 输出格式

输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。

## 样例 #1

### 样例输入 #1

```
1122002010
```

### 样例输出 #1

```
5 2
```

## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq |s| \leq 5 \times 10^5$，$s$ 中只含字符 `0` `1` `2`。

# 思路
·我们的转移方程是比较显然的，我们首先按照根节点的儿子个数分类，如果有一个儿子
$Dp[x][0] = max (dp[x+1][1], dp[x+1][2])+1$;
$Dp[x][1] = max (dp[x+1][0], dp[x+1][2]);$
$Dp[x][2] = max (dp[x+1][0], dp[x+1][1])$
·如果有两个儿子
$dp[x][0] = max (dp[x+1][1] + dp[k][2], dp[x+1][2] + dp[k][1]) + 1$;
$dp[x][1] = max(dp[x+1][0] + dp[k][2], dp[x+1][2] + dp[k][0])$;
$dp[x][2] = max(dp[x+1][0] + dp[k][1], dp[x+1][1] + dp[k][0]);$
求最小值同理
另外还有一点就是我们要求怎么把文中的一串恶心的数字转换为我们的二叉树。
这一步我们可以采用 dfs 的方法，因为原文中给的就是 dfs 的方法构建的，我们代码如下
```cpp
void dfs(int root){//root表示几号节点
    tot++;//表示总共访问了几个节点。
    if (s[root]=='0') return;//叶子节点退出
    if (s[root]=='1') {
        tree[root][0]=root+1;//下一个访问的节点的编号一定是这个节点编号+1
        dfs(root+1);//向下搜
    }
    if (s[root]=='2') {
        tree[root][0]=root+1;
        dfs(root+1);
        tree[root][1]=tot+1;//右节点一定是总共访问的编号+1
        dfs(tot+1);
    }
}
```
# AC 代码
```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 500050;
char s[N];
int dp[N][4], f[N][4], cnt;
int ans1 = 1;
void dfs(int x) {
	if (s[x] == '0') {//叶节点
		f[x][0] = dp[x][0] = 1;
		return;
	}
	dfs(++cnt);
    //左儿子编号为x+1
	if (s[x] == '1') { //一个儿子
		dp[x][0] = max(dp[x+1][1], dp[x+1][2])+1;
		dp[x][1] = max(dp[x+1][0], dp[x+1][2]);
		dp[x][2] = max(dp[x+1][0], dp[x+1][1]);
        	//儿子染另外一种颜色
		// 上方代码完全是复制一遍到下面
		f[x][0] = min(f[x+1][1], f[x+1][2])+1;
		f[x][1] = min(f[x+1][0], f[x+1][2]);
		f[x][2] = min(f[x+1][0], f[x+1][1]);
	}
	else {
        //右儿子编号为k
		int k = ++cnt;
		dfs(k);
		dp[x][0] = max(dp[x+1][1] + dp[k][2], dp[x+1][2] + dp[k][1]) + 1;
		dp[x][1] = max(dp[x+1][0] + dp[k][2], dp[x+1][2] + dp[k][0]);
		dp[x][2] = max(dp[x+1][0] + dp[k][1], dp[x+1][1] + dp[k][0]);
		
		f[x][0] = min(f[x+1][1] + f[k][2], f[x+1][2] + f[k][1]) + 1;
		f[x][1] = min(f[x+1][0] + f[k][2], f[x+1][2] + f[k][0]);
		f[x][2] = min(f[x+1][0] + f[k][1], f[x+1][1] + f[k][0]);
	}
	ans1 = max(ans1, dp[x][0]);
}
int main() {
	scanf ("%s", s + 1);
	dfs(++cnt);
	cout << ans1 << ' ' << min(f[1][0], min(f[1][1], f[1][2])) << endl;
	return 0;
}
```
```

