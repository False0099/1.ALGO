# 知识点
  ## [[动态规划]] [[unsolved]] [[树形DP]] [[求最值]]
# 题目
小d是“红易”外卖的一名配送员，负责派送S城的外卖，S城非常奇特，这个城市是一个树形结构——道路均为双向道路并且没有环，并且每一条道路长度为1，其中1号结点也就是根节点是外卖的中转站，题目保证该结点不会有外卖配送的需求（所有的外卖均要由小d从这里取，然后派送给其他用户）。  
  
小d负责派送蔬菜等物资，上午由用户在软件上下单成功以后，下午由他统一派送，因此他知道哪家会有订单。但是由于“红易”是一个员工至上的商家（没错，不是顾客至上），他可以因不想配送为由从而拒绝配送m份订单，作为补偿，被拒接的订单不仅全额退款，还可以线上送他们一份赛博蔬菜。  
  
他的外卖卡车可以满足所有的订单配送，也就是仅需一开始装载好所有的货物，然后再去配送，所有送餐地址可以按任意顺序访问，直到他配送完成全部的外卖订单，**送完全部的外卖订单以后需要返回中转站结算工钱**。  
  
由于他希望尽快回家陪女朋友，他希望走过的所有路程最短（访问所有接受申请的订单地点至少一次即可送达），现在给出你哪一些用户在“红易”平台下单，请你输出他的配送路程最短距离和。

## 输入描述:
  
第一行输入结点数 n $(3≤n≤105)$  和可以取消的外卖订单份数 m $(1≤m≤50)$ 。  
  
接下来 $n−1$ 行每一行输入两组数据，a、b $(1≤a,b≤n)$ ，分别代表编号为 a 和 b 的两地连一条边。  
  
接下来一行输入一个数 k $(1≤k≤n−1)$ ，代表有 k 份订单。  
  
接下来一行输入 k 个数 $(2≤bi≤n)$ ，第 i 个数代表编号为 $b_{i}$ ​的地点有外卖订单的配送需求，测试数据保证对于任意 $i≠j,(1≤i,j≤k),bi≠bj而且 i≠j$
# 思路
我们将需要送外卖的点标记为 `need`。

然后我们的答案就是我们考虑我们的 $dp[i][j]$ 表示我们以 i 为根节点，且使用了 j 个免单后我们的可以减少的最大值是多少。

对于我们的每个点，我们根据我们给我们子节点用多少个免单来转移，而这里我们的转移也是有讲究的：如果我们每一个地方的免单后，他可以不去经过这个点，那么我们的贡献就直接变为 0，因此我们还需要一个 $s[x]$ 记录我们根节点为 x 的节点子树中的**需求量之和**。

在转移刚开始的时候，`dp[x]` 是不完整的，它仅包含 `x` 这一个点的信息，设 `x` 的儿子分别为 `y1,y2,y3`，在将 y1转移给 x 之后，`dp[x]` 表示的范围就是 `x点` 和 `y1子树`，以此类推，将 `y2, y3` 一个个合并，最后 `dp[x]` 表示的信息就是以 `x` 为根的子树的信息。

思考一下如何更新`dp[x][k]`，我们可以将`k`分解成`i + (k - i)`，然后有`dp[x][k] = max(dp[x][i], dp[y][k - i])`。

我们更新`dp[x]`需要用到`dp[x]`本身的信息，所以我们需要开一个临时的数组`f[]`来表示`dp[x]`更新完再将`f[]`复制给`dp[x]`。

首先，如果`s[y] == 0`，说明y子树对答案完全没有影响，可以直接跳过。

如果`k - i == s[y]`，说明我们把`y`子树的所有需求点都删了，那么`x -> y`这条边可以删除，所以对答案贡献为2（表示最终路程可以减少2），其余情况贡献都为0。

更新完`dp[x]`后还要更新一下`s[x]`，直接加上`s[y]`即可。

同时顺便计算一下不删除边的情况下的总路程`tot`，当`s[y]`不为0，就必须往下走了。



·也就是在树上做了个分组背包问题。

# AC 代码
```cpp
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 9;
int dp[N][60], s[N];//dp[i][j]表示在i为根的子树中删除j个点的最大贡献
//s[i]表示以i为根的子树中的需求量
vector<int> g[N];
bitset<N> need;
int tot, n, m;;
void dfs(int x, int p)
{
    s[x] = need[x];
    for(auto &y : g[x])
    {
        if(y == p)continue;
        dfs(y, x);
        if(s[y] == 0)continue;

        static int f[60];
        memset(f, 0, sizeof f);
        for(int k = 0;k <= min(m, s[x] + s[y]); ++ k)
        {
            //x树中取i个，注意此时x树并不完整
            //在y中取k - i个，此时y树为完整的
            for(int i = 0;i <= min(m, s[x]); ++ i)
            {
                if(k - i <= s[y] && k - i >= 0)
                    f[k] = max(f[k], dp[x][i] + dp[y][k - i] + (k - i == s[y] ? 2 : 0));
            }
        }
        s[x] += s[y];
        tot += 2;//此时已经保证s[y] != 0，注意看上面的continue
        for(int i = 0;i <= min(m, s[x] + s[y]); ++ i)dp[x][i] = f[i];
    }
}

signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for(int i = 1;i < n; ++ i)
    {
        int x, y;cin >> x >> y;
        g[x].push_back(y), g[y].push_back(x);
    }

    int k;cin >> k;
    for(int i = 1;i <= k; ++ i)
    {
        int x;cin >> x;
        need[x] = true;
    }

    dfs(1, -1);
    cout << tot - dp[1][m] << '\n';
    return 0;
}
```
```
# 备注
