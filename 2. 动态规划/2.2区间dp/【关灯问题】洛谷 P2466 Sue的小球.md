# [SDOI 2008] Sue 的小球

## 题目描述

Sue 和 Sandy 最近迷上了一个电脑游戏，这个游戏的故事发在美丽神秘并且充满刺激的大海上，Sue 有一支轻便小巧的小船。然而，Sue 的目标并不是当一个海盗，而是要收集空中漂浮的彩蛋，Sue 有一个秘密武器，只要她将小船划到一个彩蛋的正下方，然后使用秘密武器便可以在瞬间收集到这个彩蛋。然而，彩蛋有一个魅力值，这个魅力值会随着彩蛋在空中降落的时间而降低，Sue 要想得到更多的分数，必须尽量在魅力值高的时候收集这个彩蛋，而如果一个彩蛋掉入海中，它的魅力值将会变成一个负数，但这并不影响 Sue 的兴趣，因为每一个彩蛋都是不同的，Sue 希望收集到所有的彩蛋。

然而 Sandy 就没有 Sue 那么浪漫了，Sandy 希望得到尽可能多的分数，为了解决这个问题，他先将这个游戏抽象成了如下模型：

将大海近似的看做 $x$ 轴，以 Sue 所在的初始位置作为坐标原点建立一个竖直的平面直角坐标系。

一开始空中有 $N$ 个彩蛋，对于第 $i$ 个彩蛋，他的初始位置用整数坐标 $(x_{i}, y_{i})$ 表示，游戏开始后，它匀速沿 $y$ 轴负方向下落, 速度为 $v_{i}$ 单位距离/单位时间。Sue 的初始位置为 $(x_{0}, 0)$，Sue 可以沿 $x$ 轴的正方向或负方向移动，Sue 的移动速度是 $1$ 单位距离/单位时间，使用秘密武器得到一个彩蛋是瞬间的，得分为当前彩蛋的 $y$ 坐标的千分之一。

现在，Sue 和 Sandy 请你来帮忙，为了满足 Sue 和 Sandy 各自的目标，你决定在收集到所有彩蛋的基础上，得到的分数最高。

## 输入格式

第一行为两个整数 $N$, $x_{0}$ 用一个空格分隔，表示彩蛋个数与 Sue 的初始位置。

第二行为 $N$ 个整数 $x_{i}$，每两个数用一个空格分隔，第 $i$ 个数表示第 $i$ 个彩蛋的初始横坐标。

第三行为 $N$ 个整数 $y_{i}$，每两个数用一个空格分隔，第 $i$ 个数表示第 $i$ 个彩蛋的初始纵坐标。

第四行为 $N$ 个整数 $v_{i}$，每两个数用一个空格分隔，第 $i$ 个数表示第 $i$ 个彩蛋匀速沿 $y$ 轴负方向下落的的速度。

## 输出格式

一个实数，保留三位小数，为收集所有彩蛋的基础上，可以得到最高的分数。

## 样例 #1

### 样例输入 #1

```
3 0
-4 -2 2
22 30 26
1 9 8
```

### 样例输出 #1

```
0.000
```

## 提示

对于 $30\%$ 的数据， $N\leq 20$。

对于 $60\%$ 的数据， $N\leq 100$。

对于 $100\%$ 的数据，$-10^4 \leq x_{i},y_{i},v_{i} \leq 10^4$，$N \leq 1000$

## 题解
### Solution
当前“行动”的费用的一部分需要在之前决策时被计算并以状态的形式对当前状态造成影响。造成这一独特的计算的原因就是当前的决策会对未来的“行动”费用造成影响。
那么简单来说就是**现在的决策内容会对之后的计算价值产生影响**

先考虑如果我们时间对于我们的答案没有影响，我们可以考虑使用我们的线性 dp 去求解我们的答案。

$1.$ 先把所有的点包括起点按 $x$ 值排序，这样题目就变成从起点出发，每次可以向左或向右走到最近的某个彩蛋，将其射落，**这样的操作一定是最优的**，这样，我们就把原来的问题转换为了：我们每一次可以选择向左或者向右合并与我们当前元素相邻的元素，然后问我们最大价值是多少。

在确定了我们的区间 dp 后，我们考虑计算我们每一次合并后，我们的答案会被更新为多少。假设我们现在的答案是 $dp[i][j]$,表示我们把我们的 $i，j$ 区间全部合并后，我们的**浪费的最小代价**是多少。

这里我们计算我们浪费的最小代价，是因为我们如果直接计算我们的答案，我们是很难去对于每一个点算出我们有多少个

但是，我们如果合并完 $i,j$，是有两种可能的情况的，一种是把我们的 $i,j$ 给完全合并了，我们现在在 $i$ 点，另一种就是我们在 $j$ 点。于是我们还需要加设一个维度表示我们现在在左端点还是右端点。

设每个彩蛋第一次走到的时刻为 $t_i$，答案就是 $$∑(y_i-t_i*v_i)max$$
于是我们的合并就可以写成：
```
f[i][j][0]=f[i+1][j][1]+dist(j,i)
f[i][j][0]=f[i+1][j][0]+dist(i+1,i)
f[i][j][1]=f[i][j-1][0]+dist(i,j);
f[i][j][1]=f[i][j-1][1]+dist(j-1,j);
```

与我们的答案对比：
```
f[l][r][0]=f[l+1][r][0]+(a[l+1].x-a[l].x)*(a[l].v+a[n].v-a[r].v)
f[l][r][0]=f[[l+1][r][1]+(a[r].x-a[l].x)*(a[l].v+a[n].v-a[r].v));
f[l][r][1]=f[l][r-1][0]+(a[r].x-a[l].x)*(a[l-1].v+a[n].v-a[r-1].v)
f[l][r][1]=f[l][r-1][1]+(a[r].x-a[r-1].x)*(a[l-1].v+a[n].v-a[r-1].v));
```

其中：
```
(a[r].x-a[r-1].x)*(a[l-1].v+a[n].v-a[r-1].v))
```

就表示我们这一段时间内，我们的其他位置浪费了的权值是多少。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N=1010;
struct node{
    int x,y,v;
    bool operator < (node b) const {
        return x<b.x;
    } 
}a[N];
int n,x0,ans,f[N][N][2];

int main(){
    scanf("%d%d",&n,&x0),a[n+1].x=x0;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].x);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].y),ans+=a[i].y;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].v);
    n++;
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
        if(a[i].x==x0){
            f[i][i][0]=f[i][i][1]=0;
            break;
        }
    for(int i=1;i<=n;i++)
        a[i].v+=a[i-1].v;
    for(int i=1;i<=n;i++)
        for(int l=1,r=l+i;r<=n;l++,r++){
            f[l][r][0]=min(f[l+1][r][0]+(a[l+1].x-a[l].x)*(a[l].v+a[n].v-a[r].v),
                            f[l+1][r][1]+(a[r].x-a[l].x)*(a[l].v+a[n].v-a[r].v));
            f[l][r][1]=min(f[l][r-1][0]+(a[r].x-a[l].x)*(a[l-1].v+a[n].v-a[r-1].v),
                            f[l][r-1][1]+(a[r].x-a[r-1].x)*(a[l-1].v+a[n].v-a[r-1].v));
        }
    printf("%.3lf\n",(ans-min(f[1][n][0],f[1][n][1]))/1000.0);
    return 0;
}
```