# 关路灯

## 题目描述

某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。

为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。

现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。

请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。

## 输入格式

第一行是两个数字 $n$（表示路灯的总数）和 $c$（老张所处位置的路灯号）；

接下来 $n$ 行，每行两个数据，表示第 $1$ 盏到第 $n$ 盏路灯的位置和功率。数据保证路灯位置单调递增。

## 输出格式

一个数据，即最少的功耗（单位：$J$，$1J=1W\times s$）。

## 样例 #1

### 样例输入 #1

```
5 3
2 10
3 20
5 20
6 30
8 10
```

### 样例输出 #1

```
270
```

## 提示

### 样例解释

此时关灯顺序为 `3 4 2 1 5`。

### 数据范围

$1\le n\le50$，$1\le c\le n$，$1\le W_i \le 100$。

## 题解
本题我们也是一个双端扩展，因为我们满足下面的一个性质：**我们如果假设现在已经走过的路径是[i, j]，那么如果我们希望下一次能够更优**，我们一定要从我们的当前位置向我们的左右走，并且走的一定是要 $<i$ 或者 $>j$ 的。于是，我们就可以通过我们的双端扩展转移模型来进行处理，**同时，因为我们还要计算我们的距离，所以我们还需要记录我们的断点**。因此，我们就有我们的 $f[i][j][0]$ 表示我们已经走完 $[i,j]$ 并且现在在 i 点的方案，$f[i][j][1]$ 表示我们已经走完 $[i,j]$ 并且现在在 $j$ 点的方案。
```
#include <bits/stdc++.h>

#define int long long

int INF=0x3f3f3f3f3f;

using namespace std;

struct node

{

    int x;

    int w;

    /* data */

};

const int N=50;

int f[N][N][2];

void solve(){

    int n,c;

    cin>>n>>c;

    vector<node> a(1+n);

    memset(f,INF,sizeof f);

    vector<int> sum(n+1,0);

    for(int i=1;i<=n;i++){

        cin>>a[i].x>>a[i].w;

        sum[i]=sum[i-1]+a[i].w;

    }

    f[c][c][0]=f[c][c][1]=0;

    for(int len=2;len<=n;len++){

        for(int i=1;i+len-1<=n;i++){

            int j=i+len-1;

            f[i][j][0]=min(f[i+1][j][0]+(a[i+1].x-a[i].x)*(sum[i]+sum[n]-sum[j]),//继续走下去会更快吗？

               f[i+1][j][1]+(a[j].x-a[i].x)*(sum[i]+sum[n]-sum[j]));//还是从j点折返回来会更快？（此时假设[i+1][j]被关，i亮，从j端点往回赶去关i）

//要注意的一点是sum[n]-(sum[j]-sum[i])是包括了i这一点的电能的，因为走过来的过程中灯i也会耗电

            f[i][j][1]=min(f[i][j-1][0]+(a[j].x-a[i].x)*(sum[i-1]+sum[n]-sum[j-1]),//同上

                f[i][j-1][1]+(a[j].x-a[j-1].x)*(sum[i-1]+sum[n]-sum[j-1]));

        }

    }

    cout<<min(f[1][n][0],f[1][n][1]);

}

signed main(){

    ios::sync_with_stdio(false),cin.tie(0);

    int t;

 //   cin>>t;

    t=1;

    while(t--){

        solve();

    }

}
```