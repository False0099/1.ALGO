# 知识点
  ## [[区间DP]]
# 题目
 # [CSP-S 2021] 括号序列

## 题目描述

小 w 在赛场上遇到了这样一个题：一个长度为 $n$ 且符合规范的括号序列，其有些位置已经确定了，有些位置尚未确定，求这样的括号序列一共有多少个。

身经百战的小 w 当然一眼就秒了这题，不仅如此，他还觉得一场正式比赛出这么简单的模板题也太小儿科了，于是他把这题进行了加强之后顺手扔给了小 c。

具体而言，小 w 定义“超级括号序列”是由字符 `(`、`)`、`*` 组成的字符串，并且对于某个给定的常数 $k$，给出了“符合规范的超级括号序列”的定义如下：

1. `()`、`(S)` 均是符合规范的超级括号序列，其中 `S` 表示任意一个仅由**不超过** ${k}$ **个**字符 `*` 组成的非空字符串（以下两条规则中的 `S` 均为此含义）；
2. 如果字符串 `A` 和 `B` 均为符合规范的超级括号序列，那么字符串 `AB`、`ASB` 均为符合规范的超级括号序列，其中 `AB` 表示把字符串 `A` 和字符串 `B` 拼接在一起形成的字符串；
3. 如果字符串 `A` 为符合规范的超级括号序列，那么字符串 `(A)`、`(SA)`、`(AS)` 均为符合规范的超级括号序列。
4. 所有符合规范的超级括号序列均可通过上述 3 条规则得到。

例如，若 $k = 3$，则字符串 `((**()*(*))*)(***)` 是符合规范的超级括号序列，但字符串 `*()`、`(*()*)`、`((**))*)`、`(****(*))` 均不是。特别地，空字符串也不被视为符合规范的超级括号序列。

现在给出一个长度为 $n$ 的超级括号序列，其中有一些位置的字符已经确定，另外一些位置的字符尚未确定（用 `?` 表示）。小 w 希望能计算出：有多少种将所有尚未确定的字符一一确定的方法，使得得到的字符串是一个符合规范的超级括号序列？

可怜的小 c 并不会做这道题，于是只好请求你来帮忙。

## 输入格式

第一行，两个正整数 $n, k$。

第二行，一个长度为 $n$ 且仅由 `(`、`)`、`*`、`?` 构成的字符串 $S$。

## 输出格式

输出一个非负整数表示答案对 ${10}^9 + 7$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
7 3
(*??*??
```

### 样例输出 #1

```
5
```

## 样例 #2

### 样例输入 #2

```
10 2
???(*??(?)
```

### 样例输出 #2

```
19
```

## 样例 #3

### 样例输入 #3

```
见附件中的 bracket/bracket3.in
```

### 样例输出 #3

```
见附件中的 bracket/bracket3.ans
```

## 样例 #4

### 样例输入 #4

```
见附件中的 bracket/bracket4.in
```

### 样例输出 #4

```
见附件中的 bracket/bracket4.ans
```

## 提示

**【样例解释 #1 】**

如下几种方案是符合规范的：

```plain
(**)*()
(**(*))
(*(**))
(*)**()
(*)(**)
```

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 3$ | $15$ | 无 |
| $4 \sim 8$ | $40$ | 无 |
| $9 \sim 13$ | $100$ | 无 |
| $14 \sim 15$ | $500$ | $S$ 串中仅含有字符 `?` |
| $16 \sim 20$ | $500$ | 无 |

对于 $100 \%$ 的数据，$1 \le k \le n \le 500$。

## 题解
我们考虑一种自然的想法：我们设 $dp[i][j]$ 表示我们把区间 $i,j$ 变为合法所有可能的方案，但是，我们主要到，这样去转移会有重复状态，并且我们的转移是存在瓶颈的。

但是因为我们是区间 DP，区间 DP 的优势就在于，我们可以通过枚举我们区间的两个端点的状态，让我们的转移更加的简单。

我们不妨从最简单的开始设计，这一类方案显然可以通过我们的我们假设哦我们的状态为下面的四种：
1. 左端点为 `(`,右端点为 `)`,并且左右端点对应的括号都是匹配的
2. 左端点为 `(`,右端点为 `*`，且左端点对应的括号是匹配的
3. 左端点为 `*`,右端点为 `)`,且右端点对应的括号是匹配的
4. 左端点为 `*`,右端点为 `*`

对于第一种状态，我们注意到，存在 `(...)...（）...（）` 会导致我们进行重复计算。

所以我们还需要添加一个状态，表示我们左右是“完全匹配”的，我们记为状态 A，也就是我们的左端点是 `（`，右端点是 `)` 并且必须是左端点和右端点两者之间匹配。例如：` (...）` 就是完全匹配的，而 ` (...)() ` 就不是完全匹配的。

于是，我们的转移就有：
```
dp[i][j][1]=dp[i][j][A]*dp[i][j][1];
```

这样，我们就能让哦我们的转移不会重复。

对于我们的第二种状态，我们同样注意到，存在 `(...)***()***()***` 会导致我们重复计算。

因此，我们还需要添加一种状态 B, 表示我们一整个区间全都是 `*` 的方案数。

于是我们对于我们状态 2的转移就有：
```
dp[i][j][2]=sum(dp[i][k][1]*dp[k][j][B])
```

同样的，对于我们的第三种状态，我们主要到：也是和我们类似的情况，但是我们通过我们的状态 A 和状态 B 就已经能够解决我们的问题，于是，我们就有：
```
dp[i][j][3]=sum(dp[i][k][B]*dp[k][j][1])
```

我们对所有合法状态序列的状态进行讨论:
 · $p= 0$: 区间内字符全为 `*`。
 · $p=1$: 左右端点是一组单区间匹配的括号。
 · $p=2$: 左端点为 (, 右端点为 *
 · $p=3$: 左右端点是一组匹配的括号。
 · $p=4$: 左端点为 * ,右端点为 )。
 
 其中，$p=1$ 的状态包含于 $p=3$ 的状态。显然，对于 $S$ 的整个区间 $[1,n]$, $p=3$ 的状态即为答案。

 初始化边界：对于 $\forall i$ ,有 $dp_{i,i-1,0}=1$。

状态转移：
$dp_{i,j,0}=1$ （当且仅当 $dp_{i,j-1,0}=1$ 且 $S_j$ 可以为 * 且 $j-i+1<k$, ）否则 $dp_{i,j,0}=0$。

$dp_{i,j,1}=dp_{i+1,j-1,0}+dp_{i+1,j-1,2}+dp_{i+1,j-1,3}+dp_{i+1,j-1,4}$ （当且仅当 $S_i$ 和 $S_j$ 为一组匹配的括号，否则 $dp_{i,j,1}=0$。）

$dp_{i,j,2}=\sum_{t=i}^{j-1}dp_{i,t,3}\times dp_{t+1,j,0}\text{。}$

$dp_{i,j,3}=dp_{i,j,1}+\sum_{t=i}^{j-1}(dp_{i,t,2}+dp_{i,t,3})\times dp_{t+1,j,1}$

$dp_{i,j,4}=\sum_{t=i}^{j-1}dp_{i,t,0}\times dp_{t+1,j,3}$


# AC 代码
```cpp
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=550,mo=1e9+7;
LL dp[N][N][5];
int n,k;
char S[N];
signed main()
{
	scanf("%d%d",&n,&k);
	scanf("%s",S+1);
	for(int i=1;i<=n;++i) 
		dp[i][i-1][0]=1;//初始化边界 
	for(int len=1;len<=n;++len)//枚举区间长度 
		for(int i=1,j=i+len-1;j<=n;++i,++j)//枚举左右端点 
		{ 
			if(len<=k&&dp[i][j-1][0]&&(S[j]=='*'||S[j]=='?')) dp[i][j][0]=1;
			if(len>=2)//用小于2的子区间转移没有意义 
			{
				if((S[i]=='('||S[i]=='?')&&(S[j]==')'||S[j]=='?'))//判断左右端点是否为匹配的括号 
					dp[i][j][1]=(dp[i+1][j-1][0]+dp[i+1][j-1][2]+dp[i+1][j-1][3]+dp[i+1][j-1][4])%mo;
				for(int t=i;t<=j-1;++t)//枚举子区间的断点 
				{
					dp[i][j][2]=(dp[i][j][2]+dp[i][t][3]*dp[t+1][j][0])%mo;
					dp[i][j][3]=(dp[i][j][3]+(dp[i][t][2]+dp[i][t][3])*dp[t+1][j][1])%mo;
					dp[i][j][4]=(dp[i][j][4]+dp[i][t][0]*dp[t+1][j][3])%mo;
				}
			}
            dp[i][j][3]=(dp[i][j][3]+dp[i][j][1])%mo;
		}
	printf("%lld",dp[1][n][3]);
	return 0;
}
```
```
# 备注
