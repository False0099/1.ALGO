# [春季测试 2023] 圣诞树

## 题目描述

众所周知，3202 年的圣诞节快要到了，因此小 Ω 买了一棵圣诞树和一根挂满了彩灯的电线，并打算把这根电线缠绕在圣诞树上。

圣诞树可以视作一个二维平面上有 $n$ 个顶点的**凸多边形**。这 $n$ 个顶点可以用于固定电线，且按**逆时针顺序**依次编号为 $1, \ldots, n$。其中第 $i$ 个顶点的坐标为 $(x_i, y_i)$，记其中 **$y$ 坐标最大**的顶点的编号为 $k$（若有多个满足条件的顶点，则取**编号最小**的）。不保证编号为 $1$ 的顶点的 $x$ 坐标最小。

下图左侧展示了一棵圣诞树的轮廓，其中 **$y$ 坐标最大**的顶点的编号为 $k = 5$。

![图 2：一棵圣诞树及一种可能的挂电线的方案](https://cdn.luogu.com.cn/upload/image_hosting/ayjegrhj.png)

小 Ω 希望用挂满了彩灯的电线装饰这棵圣诞树。出于美观性考虑，她希望这根电线**经过所有顶点恰好一次**；为了连接电源，这根电线需要**从 $(x_k, y_k)$ 出发**。形式化地，她需要决定一个 $1, \cdots, n$ 的**排列** $p_1, \cdots, p_n$，满足 $p_1 = k$，随后这根电线从 $(x_{p_1}, y_{p_1})$ 出发，依次经过 $(x_{p_2}, y_{p_2}), \cdots, (x_{p_n}, y_{p_n})$。此时，电线长度为 $\sum_{i=1}^{n-1}{\operatorname{d}((x_{p_i}, y_{p_i}), (x_{p_{i+1}}, y_{p_{i+1}}))}$。

- 其中 $\operatorname{d}$ 为平面上的**欧几里得距离**，即 $\operatorname{d}((x, y), (x', y')) = \sqrt{(x - x')^2 + (y - y')^2}$。

上图右侧展示了一种可能的方案，此时对应的排列为 $5, 4, 8, 6, 3, 9, 1, 7, 2$。

为了节省成本，她希望你能在所有可能的方案中，给出一种使电线长度**最短**的方案。如果使电线长度最短的方案不唯一，你只需要求出其中**任意**一种。

**考虑到浮点数产生的误差，你输出的方案与最优方案的线段长度的相对误差或绝对误差不超过 $10^{-10}$ 时即认为答案正确**。

## 输入格式

第一行包含一个正整数 $n$，表示圣诞树的顶点数。

接下来 $n$ 行，其中第 $i$ 行包含两个精确到小数点后 $9$ 位的实数 $x_i, y_i$ 表示编号为 $i$ 的顶点的坐标。

数据保证这 $n$ 个点**两两不同**，并且依次连接 $(x_1, y_1), (x_2, y_2), \cdots, (x_n, y_n)$ 将形成一个**凸多边形**。

## 输出格式

输出一行包含 $n$ 个由单个空格隔开的正整数 $p_1, p_2, \cdots, p_n$，表示一个 $1, \cdots, n$ 的排列，满足 $p_1 = k$，且电线的长度 $\sum_{i=1}^{n-1}{\operatorname{d}((x_{p_i}, y_{p_i}), (x_{p_{i+1}}, y_{p_{i+1}}))}$ 在所有可能的方案中**最短**。如果这样的方案不唯一，请输出其中任意一种方案。

## 样例 #1

### 样例输入 #1

```
3
0.000000000 0.000000000
3.000000000 0.000000000
1.000000000 1.000000000
```

### 样例输出 #1

```
3 1 2
```

## 提示

**【样例 1 解释】**

这一样例中只有下图所示的两种方案，对应排列分别为 $3, 1, 2$ 或 $3, 2, 1$，电线长度分别为 $3 + \sqrt{2}$ 和 $3 + \sqrt{5}$，而 $3 + \sqrt{2} < 3 + \sqrt{5}$。

因此答案对应的排列为 $3, 1, 2$。

![图 3：样例 1 的全部两种可能的方案](https://cdn.luogu.com.cn/upload/image_hosting/tcwvp72y.png)

**【数据范围】**

对于所有数据，保证 $3 \le n \le 1000$；$|x_i|, |y_i| \le 10^7$。

|测试点编号| $n \le$ |特殊性质|
|:-:|:-:|:-:|
|1, 2| $4$ |无|
|3, 4, 5, 6| $9$ |无|
|7, 8, 9, 10, 11, 12| $18$ |无|
|13, 14| $10^3$ |A|
|15, 16| $10^3$ |B|
|17, 18, 19, 20| $10^3$ |无|

特殊性质 A：保证存在正整数 $m \ge n$，使得输入的 $n$ 个顶点对应正 $m$ 边形中连续的一段顶点。

特殊性质 B：保证 $x_1 < x_2 < \cdots < x_n$，且 $y_1 > y_2 > \cdots > y_n$。


## 题解
题意：
给定平面内凸包，最小化从其最高点开始的任意哈密尔顿路径 (认为任意两点之间均可到达) 的欧几里得距离，输出最小化的方案。存在 SPJ。

首先，我们可以发现，我们再最优路径上，**任意两条路径之间不可能存在交点**，也就是说，我们每一次如果要取我们的最短路径，我们一定是取我们的相邻的量和我们的原来的进行合并。
于是，我们就可以采用区间 DP 的思路来计算，又因为我们从左或是从右存在区别，所以我们需要开一个变量表示我们现在在左端点或是我们现在在右端点。
于是，我们就可以用我们的区间 DP 来转换：
```
f[l][r][0]=f[l+1][r][0]+dist(l+1,l);
f[l][r][0]=f[l+1][r][1]+dist(l,r);
f[l][r][1]=f[l][r-1][0]+dist(l,r-1)
f[l][r][1]=f[l][r-1][1]+dist(r,r-1);
```


并且我们还可以用一个简单的数组来记录我们的变量。
```cpp
pre[i][j][1]=1;
```

最终，我们打印方案的打印函数：
```cpp
void print(int l,int r,int op)
{
    if(l==r) return cout<<a[l].id<<' ',void();
    if(op) cout<<a[r].id<<' ',print(l,r-1,pre[l][r][op]);
    else cout<<a[l].id<<' ',print(l+1,r,pre[l][r][op]);
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1005;
struct node{double x,y;int id;}a[maxn],tmp[maxn];
double f[maxn][maxn][2];
int pre[maxn][maxn][2];

double dis(int i,int j){return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));}

void print(int l,int r,int op)
{
    if(l==r) return cout<<a[l].id<<' ',void();
    if(op) cout<<a[r].id<<' ',print(l,r-1,pre[l][r][op]);
    else cout<<a[l].id<<' ',print(l+1,r,pre[l][r][op]);
}

int main()
{
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y,a[i].id=i,tmp[i]=a[i];
    int k=1;
    for(int i=2;i<=n;i++) if(a[i].y>a[k].y) k=i;
    for(int i=1;i<=k;i++) a[i+n-k]=tmp[i];
    for(int i=k+1;i<=n;i++) a[i-k]=tmp[i];
    for(int len=2;len<n;len++)
        for(int i=1,j=len;j<n;i++,j++)
        {
            f[i][j][0]=f[i][j][1]=1e18;
            if(f[i][j][0]>f[i+1][j][0]+dis(i,i+1)) f[i][j][0]=f[i+1][j][0]+dis(i,i+1),pre[i][j][0]=0;
            if(f[i][j][0]>f[i+1][j][1]+dis(i,j)) f[i][j][0]=f[i+1][j][1]+dis(i,j),pre[i][j][0]=1;
            if(f[i][j][1]>f[i][j-1][0]+dis(j,i)) f[i][j][1]=f[i][j-1][0]+dis(i,j),pre[i][j][1]=0;
            if(f[i][j][1]>f[i][j-1][1]+dis(j,j-1)) f[i][j][1]=f[i][j-1][1]+dis(j,j-1),pre[i][j][1]=1;
        }
    cout<<a[n].id<<' ';
    if(f[1][n-1][0]+dis(1,n)>f[1][n-1][1]+dis(n-1,n)) print(1,n-1,1);
    else print(1,n-1,0);
    return 0;
}
```