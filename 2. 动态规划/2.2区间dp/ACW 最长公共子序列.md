# 知识点
  ## [[动态规划]]
# 题目
 给定两个长度分别为 N和 M的字符串 A和 B，求既是 A的子序列又是 B的子序列的字符串长度最长是多少。

## 输入格式
第一行包含两个整数 N和 M。

第二行包含一个长度为 N 的字符串，表示字符串 A
。

第三行包含一个长度为 M 的字符串，表示字符串 B
。

字符串均由小写字母构成。

## 输出格式
输出一个整数，表示最大长度。

## 数据范围
1≤N, M≤1000
## 输入样例 ：
4 5
Acbd
Abedc
## 输出样例 ：
3

# 思路
***典中点的动态规划题，对于任何动态规划，我们要弄清楚两点，我们要表示什么，表示的东西要怎么转移
本题中，我们用 f【i】【j】, 表示我们将第一个字符串的前 i 个位置和第二个字符串的前 j 个位置想比较所能获得的最长的序列的长度。
转移可以写为 $f[i][j]=f[i-1][j-1]+1(如果i位置和j位置相同)$
$f[i][j]=max(f[i-1][j],f[i]][j-1])(如果两个位置不相同)$

# AC 代码
```cpp
#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main() {
  cin >> n >> m >> a + 1 >> b + 1;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i] == b[j]) {
        f[i][j] = f[i - 1][j - 1] + 1;
      } else {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
      }
    }
  }
  cout << f[n][m] << '\n';
  return 0;
}


```
# 备注





一种奇怪的优化
我们根据字符串 2 中每个字符的位置，来给 1 中的每一个字符来赋值，如果有重复的，就把所有可能的位置都倒序排列一遍，构建 1 的数值需要用到二分操作，总的复杂度就为 nlogn，但如果有很多的重复，该算法会退化为 o（n^2 logn）