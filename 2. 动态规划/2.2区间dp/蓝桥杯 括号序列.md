# 知识点
  ## [[区间DP]]
# 题目
 

# 思路
·$cntl， cntr$  原括号序列想要合法所需填充的左、右括号数

$Pos 1， pos 2$  原括号序列所含有的左 (右)、右 (左)括号数

$Dp[ i ][ j ]$  Dp 数组，数值表示第 i 个左 (右)括号位置前一共填充 j 个右 (左)括号的方案数。

$Pre[ i ]$ 前缀和维护数组，填充括号数小于等于 i 的总方案数。

$Minn[ i ]$ 最小填充数组，表示第 i 个左(右)括号位置前面至少要填充的右(左)括号数

·我们先考虑一种只加左括号的方案，如果一个状态是合法的，那么我们就需要得到 $f[n][j],j\leq n$
·
***同时，对于这一题，我们需要一种思想，即无论什么情况考虑，最后因为错误的状态不会对我们的答案做贡献，所以我们就可以考虑一个更广义的转移。

遇到 –‘(’– : 我们只考虑在 –‘)’– 前添加 –‘(’– 使这个右括号之前的括号序列合法。遇到左括号的时候，证明在这个左括号之前的括号序列已经被判断过如何使其合法了，那么加上这个左括号依然合法，所以我们不需要管这个左括号。也就是在他前面的括号序列添加左括号使其合法的种数等于加上这个左括号之后这个序列需要添加的左括号种数。
$Dp[i][j]=dp[i-1][j-1]$；

遇到 –‘)’– ：如果这个加上这个右括号的序列本身合法，那么我们仅需添加0个左括号就能使其合法，如果不合法就需要添加刚好使得其合法的左括号甚至可以更多。
要得到前 i 个字符的序列左括号比右括号多 j 个的合法情况
前 i-1 个字符的序列左括号比右括号多 0 个（刚好合法）的情况，再在这个右括号前面加 j+1 个左括号得到
前 i-1 个字符的序列左括号比右括号多 1 个的情况，再在这个右括号前面加 j 个左括号得到
前 i-1 个字符的序列左括号比右括号多 j+1 个的情况，再在这个右括号前面加 0 个左括号得到
$dp[i][j] = dp[i-1][0] + dp[i-1][1] + … + dp[i-1][j] + dp[i-1][j+1]$
然后注意到
$Dp[i][j-1] = dp[i-1][0] + dp[i-1][1] + … dp[i-1][j]$
所以有
$dp[i][j] = dp[i-1][j+1] + dp[i][j-1]$

# AC 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stdio.h>
using namespace std;

typedef long long LL;
const int MOD=1000000007;
const int N=5010;
LL dp[N][N];
char str[N];
int len;
LL func()
{
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<=len;i++)//一个括号一个括号的判断
    {
        if(str[i]=='(')
        {
            for(int j=1;j<=len;j++)
            {
                dp[i][j]=dp[i-1][j-1];//不用考虑dp[i][0] 因为dp[i-1][-1]是不合法的情况 不存在 为0
            }
        }
        else
        {
            dp[i][0]=(dp[i-1][0]+dp[i-1][1])%MOD;//特判防止越界 这里数据短，用的是优化前的推断
            for(int j=1;j<=len;j++)
            {
                 dp[i][j]=(dp[i-1][j+1] + dp[i][j-1])%MOD;
            }
        }
    }
    for(int i=0;i<=len;i++)
        if(dp[len][i]) return dp[len][i];//我们需要的就是长度为len添加括号的合法情况，而从前往后遍历出现的第一个有可能的情况就是需要括号数最少的情况，因为左括号可以加很多个，我们仅需添加最少的情况
        return -1;
}
int main()
{
    scanf("%s",str+1);//从下标为1开始
    len=strlen(str+1);
    LL l=func();
    reverse(str+1,str+len+1);
    for(int i=1;i<=len;i++)
    {
        if(str[i]=='(') str[i]=')';
        else str[i]='(';
    }
    LL r=func();
    cout<<l*r%MOD;
    return 0;
}
```
# 备注
