# [yLCPC 2024] D. 排卡

## 题目背景

经过千辛万苦，扶苏终于到达了机厅。但是她很快发现机厅排起了大 b 队 ~~（不是省选的 B 队）~~。

舞萌玩家们在人多的时候经常采取排卡的方式决定谁下一个上机。因为人实在是太多了，他们在排卡的时候，便注意到了卡上的编号。

他们向扶苏提了一个问题，你能解决吗？

## 题目描述

扶苏有一个双端队列 $a$。这个队列与计算机科学中队列的概念类似，不同的是，这个队列既可以从队列头读取和弹出元素，也可以在队列尾部读取和弹出元素，因此被称为『双端队列』。

这个队列中有 $n$ 个数。扶苏将通过 $n$ 次操作构造一个长度为 $n$ 的序列 $b$，第 $i$（$1 \leq i \leq n$）次操作会可以进行如下两个过程之一：

1. 令 $b_i$ 为 $a$ 的队列头，并在 $a$ 的头部弹出一个元素。
2. 令 $b_i$ 为 $a$ 的队列尾，并在 $a$ 的尾部弹出一个元素。

我们定义一个数对 $(i, j)$ 的得分为：

$$\mathrm{score}(i,j) = i^j \bmod 998244353$$

即 $i$ 的 $j$ 次幂对 $998244353$ 取余数的结果。特别的，在本题中我们规定 $0^0 = 0$。

现在，扶苏想用最优的策略构造 $b$ 序列，最大化如下式子的值：

$$\sum_{i = 1}^{n - 1} \mathrm{score}(b_i, b_{i + 1})$$

即 $b$ 所有相邻两项按原顺序计算的得分之和。

注意，我们仅在计算一个数对的时候将得分对 $998,244,353$ 取模，在计算求和时不再将这个和取余。

## 输入格式

**本题单个测试点内有多组测试数据**。第一行是一个正整数，表示数据组数 $T$。对每组数据：

第一行是一个整数 $n$（$2 \leq n \leq 10^3$），表示序列的长度。  
第二行有 $n$ 个整数 $a_1, a_2, \dots a_n$（$0 \leq a_i < 998,244,353$），按从头到尾的顺序表示队列 $a$ 里每个数字的值。

数据保证单个测试点内 $n$ 的和不超过 $10^3$。

## 输出格式

对每组测试数据，输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
2
5
5 3 1 4 2
6
6 5 1 4 2 3
```

### 样例输出 #1

```
1168
15655
```

## 题解
我们本题一眼顶针鉴定为区间 DP，我们先考虑最暴力的方法：$dp[i][j][k]$ 表示我们现在处理到 $l,r$ 且我们上一次选择的点是 $k$ 的取值是多少，
我们显然有转移：$dp[i+1][j][i]=max(,dp[i][j][k]+k^i)$
$dp[i][j-1][j]=max(,dp[i][j][k]+k^j)$

考虑优化，
显然我们的 $k$ 的取值只有可能是我们的 $i-1,j+1$ 的其中一个。因此，我们可以考虑所见我们的 $k$ 的取值为 $0/1$，来缩小我们的枚举。这个时候，我们的答案就有：

$$
\begin{aligned}f_{l,r,0}&=\max\left\{f_{l+1,r,0}+a_l^{a_{l+1}},f_{l+1,r,1}+a_l^{a_r}\right\}\\f_{l,r,1}&=\max\left\{f_{l,r-1,0}+a_r^{a_l},f_{l,r-1,1}+a_r^{a_{r-1}}\right\}\end{aligned}
$$


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1010;
int dp[N][N][2];
const int p=998244353;
int qmi(int a,int b){
	if(a==0&&b==0){
		return 0;
	}
	int ret=1;
	while (b)
	{
		if (b & 1) ret = (ret * a) %p;
		a = (a*a)%p, b >>= 1;
	}
	return ret;
}
void solve(){
	int n;
	cin>>n;
	int ans=0;
	vector<int> a(n+1,0);
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			dp[i][j][0]=0;
			dp[i][j][1]=0;
		}
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			dp[l][r][0]=max(dp[l+1][r][0]+qmi(a[l],a[l+1]),dp[l+1][r][1]+qmi(a[l],a[r]));
			dp[l][r][1]=max(dp[l][r-1][0]+qmi(a[r],a[l]),dp[l][r-1][1]+qmi(a[r],a[r-1]));
		}
	}
	cout<<max(dp[1][n][1],dp[1][n][0])<<endl;
} 
signed main(){
	int t;
	cin>>t;
	while(t--){
		solve();
	}
}

```