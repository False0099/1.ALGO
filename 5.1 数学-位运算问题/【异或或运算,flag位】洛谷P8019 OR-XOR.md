# [ONTAK 2015] OR-XOR

## 题目描述

给定一个长度为 $n$ 的序列 $a_1, a_2, \cdots, a_n$，请将它划分为 $m$ 段连续的区间，设第 $i$ 段的费用 $c_i$ 为该段内所有数字的异或和，则总费用为 $c_1 \operatorname{or} c_2 \operatorname{or} \cdots \operatorname{or} c_m$。请求出总费用的最小值。

## 输入格式

第一行，两个整数 $n, m$；

第二行，$n$ 个整数 $a_1, a_2, \cdots, a_n$。

## 输出格式

一行，一个整数，表示所求的值。

## 样例 #1

### 样例输入 #1

```
3 2
1 5 7
```

### 样例输出 #1

```
3
```

## 提示

对于 $100\%$ 的数据，$1 \leq m \leq n \leq 5 \times 10^5$，$0 \leq a_i \leq 10^{18}$。

## 题解
我们本题是要求出我们的异或或和的最小值，首先我们肯定不能使用我们第 9 喜欢的 dp，因为我们的 dp 复杂度能够到达 $o(n^3)$ 显然不是我们一般的数据范围能够承受得了的。

我们考虑我们有没有类似的题，我们注意到：[[【异或或运算,flag位】CF1946D Birthday Gift]]，和我们本题的题面不说是完全一样吧，至少也可以说是共轭父子。我们考虑能否采用相似的做法。

**考虑下面的性质，如果我们高位划分和低位划分有冲突，我们一定要优先满足我们的高位**。

对我们的第 $j$ 位，我们从前向后异或，统计 0 出现的次数，如果小于 M，那么就说明，我们不管怎么分，我们最后结果一定是 1. 

我们考虑怎么去**存储我们的每一个划分**，我们对于每一个划分，我们通过我们的 $1$ 表示我们的这些位置是连接在一起的。例如：我们的 $1111110$ 就表示我们的 $1-5$ 作为一个完整的断来进行处理。同样的，我们的 0 就表示我们的这一个位置是一个单独的断。


考虑怎么对我们的每一位进行**最优划分**，如果我们碰到一个位置，这个地方在这一位的前缀异或和恰好为 1，那么就说明，我们在这个位置之前一定是已经有偶数个 1 了，那么我们就应该把这个位置设置为 $并$，表示我们应该把我们的前面的位置都给进行合并。**这么操作能够保证我们得到的结果是正确的**，例如：$10001$,最后的结果就是让我们的 $1-5$ 全部合并为一个。否则，我们最后得到的答案一定不优。

如果我们碰到一个位置，这个地方在这以为的异或和恰好为 0，那么我们就应该根据我们这个位置的结果是 $并$ 还是 $切$ 来判断我们这个位置对我们的段数是否有贡献，如果有贡献，我们就直接让我们的答案++即可。

另外，如果我们处理到最后一位时，我们这一位的结果都仍然是 1，那么我们这一位就直接不需要处理，因为不管怎么处理都是 1.

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define N 500010
ll n,m,a[N],flag[N],ans;
//flag数组为断点标记数组
int main(){
	ll i,j;
	cin>>n>>m;
	for(i=1;i<=n;i++){
		cin>>a[i];
	}
	for(j=62;j>=0;j--){
		ll tmp=0,sum=0;
		for(i=1;i<=n;i++){
			tmp ^= (a[i]>>j) & 1;
  			//判断第j位的异或和是否为1
			if(!tmp && !flag[i]) sum++;
  			//同时要保证不与高位冲突，那么我们就再切一段
		}
		if((tmp&1) || (sum<m)){
         //如果该位最终结果为1，或者不能分成超过M段
			ans+= 1ll<<j;
			continue;
		}
		tmp=0;
      //将第j位的分割结果加上去
		for(i=1;i<=n;i++){
			tmp^= (a[i]>>j) & 1;
			if(tmp && !flag[i]) flag[i]=1;
		}
	}
	cout<<ans;
	return 0;
}
```


