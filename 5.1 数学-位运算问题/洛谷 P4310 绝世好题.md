# 绝世好题

## 题目描述

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$， $\&$ 表示位运算取与。

## 输入格式

输入文件共 2 行。
第一行包括一个整数 $n$。
第二行包括 $n$ 个整数，第 $i$ 个整数表示 $a_i$。

## 输出格式

输出文件共一行。
包括一个整数，表示子序列 $b_i$ 的最长长度。

## 样例 #1

### 样例输入 #1

```
3
1 2 3
```

### 样例输出 #1

```
2
```

## 提示

对于 100%的数据，$1\leq n\leq 100000$，$a_i\leq 10^9$。

## 题解
我们可以考虑用我们的最长上升子序列方法来计算，然后我们因为我们条件不同，所以我们需要用一个二进制优化来帮助我们快速转移。
因为我们要求的是与运算，所以我们只要有两位二进制都为 1，那么结果就不会位 0。那么我们就好办了，我们如果一个全是 0-1 串，那么我们只需要判断这一个 0-1 串的 1 个数，那么就是我们的最后这一位的答案。而因为我们每一位对答案的贡献是等价的，所以我们直接计算即可。
四舍五入一下，我们就相当于拆位然后对于每一位计算我们这一位上一共有多少个 1，然后在所有的答案中取最值。之后最值就是我们的答案。
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=35;
int n,ans,f[N],Max;
int main(){
    scanf("%d",&n);
    for(int j=1;j<=n;j++){//枚举每个数
        unsigned int x;//注意了,这里最好用unsigned int
        scanf("%ud",&x);//读入时为%ud
        Max=0;//最大值赋值为0
        for(int i=0;(1<<i)<=x;i++){//枚举这个数的每一位
            if(x&(1<<i)){//重点:如果这一位是1!!!
                Max=max(Max,f[i]+1);//长度++,并取最大进行f值的转移
            }
        }
        for(int i=0;(1<<i)<=x;i++){
            if(x&(1<<i)){//重点:如果这一位是1!!!
                f[i]=Max;//转移
            }
        }
    }
    for(int i=0;i<32;++i){
        ans=max(ans,f[i]);//ans为最长的
    }
    printf("%d\n", ans);
    return 0;
}~~~
```