# 【模板】线性基

## 题目背景

这是一道模板题。

## 题目描述

给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。

## 输入格式

第一行一个数 $n$，表示元素个数

接下来一行 $n$ 个数

## 输出格式

仅一行，表示答案。

## 样例 #1

### 样例输入 #1

```
2
1 1
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2

```
4
1 5 9 4
```

### 样例输出 #2

```
13
```

## 提示

$ 1 \leq n \leq 50, 0 \leq S_i < 2 ^ {50} $

## 题解
对于我们的线性基，我们通常采用我们的贪心法来构造我们的线性基，我们的线性基构造按照下面的方法来插入进行。

第一步：我们从高到低枚举，如果我们的插入的这一位是 1，并且对应的位置没有构造出线性基，那么我们就直接进行处理即可。反之，我们就把我们的答案抑或上我们的线性基再去进行处理。

然后就是我们的线性基的几个典型操作：
1. 查找某个数是否可以被构造？
我们通过从高到低和我们的对应的数字进行异或，如果对应位异或结果为 0 就认为这个数字存在，直接退出，如果到最后都没有为 0 我们认为不存在。

2. 查找我们的最大数：
我们通过从高到低将我们的每一个线性基异或，异或的时候看我们异或能否让我们的结果变大，能变大就异或，不能就不异或。就能得到我们的最大答案

3. 查询我们的第 K 大数：
我们考虑进一步简化线性基。显然，一个线性基肯定可以表示为若干个形如 $2^\iota$ 的数。从高到低处理线性基每一位，对于每一位向后扫，如果当前数第 $i$ 位为 0，且线性基第 $i$ 位不为 0，则将当前数异或上 $a_i$。这一操作可以在 $O(\log_2^2n)$ 的时间内解决。

经过这一步操作后，设线性基内共有 cnt 个数，则它们共可以表示出 $2^cnt$ 个数。当然，对于 0 必须特殊考虑。如果插入的总数 $n$ 与 cnt 相等，就无法表示0了。同样，考虑最小值时，也必须要考虑到 0 的情况。事实上，如果插入时出现了未被加入的元素，就肯定可以表示出 0。
随后，我们考虑将 $k$ 二进制拆分，用与快速幂类似的方法就可以求出第 $k$ 大值。学过线性代数的同学应该可以看出，这个过程就是对一个矩阵求解异或意义下的秩的过程。因此， $cnt\leq\lceil\log_2N\rceil$ 一定成立。而最终，线性基中保存的也是异或意义下的一组极小线性无关组。同样，有关线性基的一切运算都可以看做矩阵的初等行列变换，也就可以将其看做线性规划问题。同样，可以离线使用高斯消元来构造极小线性基。

```cpp
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
```

```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
int INF=0x3f3f3f3f3f3f3f3f;
using namespace std;
typedef pair<int,int> PII;
void init(){
    
}
const int N=66;
int d[N];
void insert(int x){
    for(int i=62;i>=0;i--){
       if(x&(1ll<<i)){
            if(!d[i]){
                d[i]=x;
                break;
            }else{
                x^=d[i];
            }
       }
    }
}
int get_max(){
    int ans=0;
    for(int i=62;i>=0;i--){
        ans=max(ans,ans^d[i]);
    }
    return ans;
}
void solve(){
    int n;
    cin>>n;
    vector<int> a(n+1);
    for(int i=1;i<=n;i++){
        cin>>a[i];
        insert(a[i]);
    }  
    cout<<get_max()<<endl;
    
}
signed main(){
    ios::sync_with_stdio(false),cin.tie(0);
    int t;
    t=1;
//    cin>>t;
    init();
    while(t--){
        solve();
    }
}
```