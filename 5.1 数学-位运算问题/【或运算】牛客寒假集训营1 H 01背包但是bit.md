## 题目描述
共有 $n$ 件物品，每件物品有价值 $v_i$ 与重量 $w_i$ 两个属性。但特别地，所选物品的总重量并不是每件物品的重量和，而是所有所选物品的重量进行按位或运算的结果。  
  
请你计算，在所选物品总重量不超过 $m$ 的情况下，所选物品的最大价值之和是多少（价值之和正常定义为所选物品价值的加和）。

## 输入：
第一行包括一个正整数 $T(1\leq T\leq 10^4)$,表示用例组数。  
  
每组用例的第一行包括两个整数 $n,m(1\leq n\leq 10^5, 0\leq m\leq 10^8)$，含义如题面所述。接下来的 $n$ 行，每行包括两个整数 $v_i,w_i(0\leq v_i\leq 10^8,0\leq w_i\leq 10^8)$，含义如题面所述。  
  
保证所有用例的 $\Sigma n\leq 10^5$。

## 输出：
对每组样例，输出一个正整数，表示所选物品的最大价值之和。

## 示例：

```
3
4 11
1 8
1 4
1 5
1 1
4 11
5 8
1 4
1 5
1 1
4 0
2 0
0 0
3 0
4 1```
```


```
3
6
5
```

## 题解
我们朴素的想法是：我们让我们的每一个位进行比较，如果我们一个位置是我们的结果对应二进制的真子集，那么我们就直接加入这一个物品。

但是，通过我们的样例 1，我们发现，我们这个答案是错误的，我们考虑新的方法。

我们上面的做法的问题，在于：忽略了我们的集合之和小于我们答案的情况，例如：011,011,011 三个加起来，就能和我们的 100 匹配，但按照上面的做法是做不出来的。

于是，我们就可以通过我们的 lowbit 求出，我们所有中的某一个数不选时，我们的最大值是多少。

于是，我们就可以写出我们的最后的答案。

```cpp
#include "bits/stdc++.h"

using namespace std;
using i64 = long long;

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> v(n), w(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i] >> w[i];
    }

    auto get = [&](int x) {
        i64 res = 0;
        for (int i = 0; i < n; i++) {
            if ((x & w[i]) == w[i]) {
                res += v[i];
            }
        }
        return res;
    };

    i64 ans = get(m);
    for (int i = m; i; i -= i & -i) {
        ans = max(ans, get(i - 1));
    }
    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```