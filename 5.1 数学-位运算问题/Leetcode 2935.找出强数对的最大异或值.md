给你一个下标从 **0** 开始的整数数组 `nums` 。如果一对整数 `x` 和 `y` 满足以下条件，则称其为 **强数对** ：

- `|x - y| <= min(x, y)`

你需要从 `nums` 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（`XOR`）值是在该数组所有强数对中的 **最大值** 。

返回数组 `nums` 所有可能的强数对中的 **最大** 异或值。

**注意**，你可以选择同一个整数两次来形成一个强数对。

**示例 1：**

**输入：**nums = [1,2,3,4,5]
**输出：**7
**解释：**数组 `nums` 中有 11 个强数对：(1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) 和 (5, 5) 。
这些强数对中的最大异或值是 3 XOR 4 = 7 。

**示例 2：**

**输入：**nums = [10,100]
**输出：**0
**解释：**数组 `nums` 中有 2 个强数对：(10, 10) 和 (100, 100) 。
这些强数对中的最大异或值是 10 XOR 10 = 0 ，数对 (100, 100) 的异或值也是 100 XOR 100 = 0 。

**示例 3：**

**输入：**nums = [500,520,2500,3000]
**输出：**1020
**解释：**数组 `nums` 中有 6 个强数对：(500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) 和 (3000, 3000) 。
这些强数对中的最大异或值是 500 XOR 520 = 1020 ；另一个异或值非零的数对是 (5, 6) ，其异或值是 2500 XOR 3000 = 636 。

**提示：**

- `1 <= nums.length <= 5 * 104`
- `1 <= nums[i] <= 220 - 1`

## 题解
我们这一题要求我们求出强数对的异或最大值，我们有下面的思路：求出我们的每一个强数对，然后求出各自的异或最大值。
我们发现，我们的**顺序对我们的结果没有影响**，于是我们就可以先将我们的整个数字进行一个排序，然后我们可以离线的求出满足条件的 x 的范围，(这里我们可以通过我们的**滑动窗口**来解决）然后，通过一个 0-1 TRIE，我们就能求出满足条件的异或最大值是多少。
或者更暴力一点，我们可以直接根据我们是否满足条件，来直**接在我们的 trie 树上进行我们的删除操作**
```cpp
class Solution {
public:
    struct node {
        int cnt;
        node* nxt[2];
        node() {
            cnt = 0;
            nxt[0] = nxt[1] = nullptr;
        }
    };
    node *tr;
    void insert(int x, int d) { // 将x 从高位到低位 插入字典树
        node *cur = tr;
        for (int i = 20; i >= 0; --i) {
            int val = 1 & (x >> i);
            if (!cur->nxt[val]) {
                cur->nxt[val] = new node();
            }
            cur = cur->nxt[val];
            cur->cnt += d; // cnt用于统计当前节点的元素个数
        }
    }
    int find1(int x) {
        node *cur = tr;
        int res = 0;
        for (int i = 20; i >= 0; --i) { // 从高位枚举，贪心选取异或值为1的节点
            int val = 1 & (x >> i);
            val ^= 1; // 需要找是否存在和val异或为1的节点  
            // 节点cur->nxt[val] 不存在，或者元素已经被移除(cnt==0)
            if (!cur->nxt[val] || !cur->nxt[val]->cnt) {
                cur = cur->nxt[val^1];
            } else { // 节点cur->nxt[val]存在元素
                res |= (1 << i);
                cur = cur->nxt[val];
            }
        }
        return res;
    }
    int maximumStrongPairXor(vector<int>& nums) {
        tr = new node();

        sort (nums.begin(), nums.end());
        int n = nums.size();
        int ans = 0;
        for (int i = -1, j = 0; j < n; ++j) {
            insert(nums[j], 1);
            while (i < j && nums[i+1] * 2 < nums[j]) {//如果我们不满足条件了，我们就删除这个点
                ++i;
                insert(nums[i], -1);
            }
            ans = max(ans, find1(nums[j]));
        }
        return ans;
    }
};
```