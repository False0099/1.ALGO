# Sushi

## 题面翻译

现有 $N(1 ≤ N ≤ 300)$ 个盘子，编号为 $1,2,3,…,N$。第 $i$ 个盘子中放有 $a_i(1≤a_i ≤3)$ 个寿司。

接下来每次执行以下操作，直至吃完所有的寿司。从第 $1,2,3,…,N$ 个盘子中任选一个盘子，吃掉其中的一个寿司。若没有寿司则不吃。

若将所有寿司吃完，请问此时操作次数的数学期望是多少？

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_j

$ N $ 枚の皿があります。皿には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。最初、各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について、皿 $ i $ には $ a_i $ ($ 1\ \leq\ a_i\ \leq\ 3) $ 個の寿司が置かれています。

すべての寿司が無くなるまで、太郎君は次の操作を繰り返し行います。

- $ 1,\ 2,\ \ldots,\ N $ の目が等確率で出るサイコロを振り、出目を $ i $ とする。皿 $ i $ に寿司がある場合、皿 $ i $ の寿司を $ 1 $ 個食べる。皿 $ i $ に寿司が無い場合、何も行わない。

すべての寿司が無くなるまでの操作回数の期待値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ a_1 $ $ a_2 $ $ \ldots $ $ a_N $

## 输出格式

すべての寿司が無くなるまでの操作回数の期待値を出力せよ。相対誤差が $ 10^{-9} $ 以下ならば正解となる。

## 样例 #1

### 样例输入 #1

```
3
1 1 1
```

### 样例输出 #1

```
5.5
```

## 样例 #2

### 样例输入 #2

```
1
3
```

### 样例输出 #2

```
3
```

## 样例 #3

### 样例输入 #3

```
2
1 2
```

### 样例输出 #3

```
4.5
```

## 样例 #4

### 样例输入 #4

```
10
1 3 2 3 3 2 3 2 1 3
```

### 样例输出 #4

```
54.48064457488221
```

## 提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ a_i\ \leq\ 3 $

### Sample Explanation 1

$ 1 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1 $ です。 その後、$ 2 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1.5 $ です。 その後、$ 3 $ 個目の寿司を食べるまでの操作回数の期待値は $ 3 $ です。 よって、全体の操作回数の期待値は $ 1\ +\ 1.5\ +\ 3\ =\ 5.5 $ です。

### Sample Explanation 2

例えば、`3.00`, `3.000000003`, `2.999999997` などを出力しても正解となります。】

## 题解
我们本题的状态设置可以先非常直接的设置我们的 $f[i][j][k]$ 表示我们有 i 个 1 寿司，j 个 2 寿司，k 个 3 寿司时，我们的操作的数学期望值是多少。然后我们就有：
1. $\dfrac{n-i-j-k}{n}$ 的概率仍然停留在原状态，这个时候，我们的 $f[i][j][k]+=p_{1}*(f[j][j][k]+1)$

2. $\dfrac{i}{n}$ 的概率吃掉一个 1 寿司：$f[i][j][k]+=p_{2}*(f[i-1][j][k]+1)$
3. $\dfrac{j}{n}$ 的概率吃掉一个 2 寿司: $f[i][j][k]+=p_{2}*(f[i+1][j-1][k]+1)$
4. $\dfrac{k}{n}$ 的概率吃掉一个 3 寿司：$f[i][j][k]+=p_{3}(f[i][j+1][k-1]+1)$

整合之后，我们就有：
$$dp[b][c][d]=\frac n{b+c+d}+\frac b{b+c+d}dp[b-1][c][d]+\frac c{b+c+d}dp[b+1][c-1][d]+\frac d{b+c+d}dp[b][c+1][d-1]$$

```cpp
```cpp
#include <bits/stdc++.h>
#define ll long long
#define pb push_back
#define pii pair<int,int>
#define mp make_pair
#define F first
#define S second
using namespace std;
int n,cnt[5];//计数
double mem[305][305][305];//dp 数组
double dfs(int i,int j,int k)//记忆化搜索
{//dfs(i,j,k）表示当前情况需要的期望步数
	if (i==0&&j==0&&k==0)
		return 0.0;
	if (mem[i][j][k]!=0.0)
		return mem[i][j][k];
	double res=(n*1.0)/((i+j+k)*1.0);//下面是转移
	if (i>0)res+=(dfs(i-1,j,k))*(i*1.0/((i+j+k)*1.0));//吃1个寿司的盘
	if (j>0)res+=(dfs(i+1,j-1,k))*(j*1.0/((i+j+k)*1.0));//吃2个寿司的盘
	if (k>0)res+=(dfs(i,j+1,k-1))*(k*1.0/((i+j+k)*1.0));////吃3个寿司的盘
	return mem[i][j][k]=res;
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		int a;
		cin>>a;
		cnt[a]++;
	}
	double ans=dfs(cnt[1],cnt[2],cnt[3]);
	printf("%.10f\n",ans);
	return 0;
}
```
```

