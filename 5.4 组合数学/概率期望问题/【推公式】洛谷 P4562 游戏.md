# [JXOI 2018] 游戏

## 题目背景

九条可怜是一个富有的女孩子。

## 题目描述

她长大以后创业了，开了一个公司。但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。

可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数 (包括 $i$ )的办公室的员工会认真工作。

可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。

可怜想知道所有 $t(p)$ 的和。

但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。

## 输入格式

第一行输入两个整数 $l,r$ 表示编号范围，题目中的 $n$ 就是 $r-l+1$ 。

## 输出格式

一个整数，表示所有 $t(p)$ 的和。

## 样例 #1

### 样例输入 #1

```
2 4
```

### 样例输出 #1

```
16
```

## 提示

### 样例解释

考虑所有办公室被检查的相对顺序:

{2 3 4} ,时间是 2 。
{3 2 4} ,时间是 2 。
{4 2 3} ,时间是 3 。
{4 3 2} ,时间是 3 。
{2 4 3} ,时间是 3 。
{3 4 2} ,时间是 3 。

和是 $16$ 。

### 数据范围

对于 20% 的数据，$r-l+1\leq 8$。  
对于另 10% 的数据，$l=1$。  
对于另 10% 的数据，$l=2$。  
对于另 30% 的数据，$l\leq 200$。  
对于 100% 的数据，$1\leq l\leq r\leq 10^7$。

## 题解
首先不难想到枚举 $t(p)$ 的取值来计算贡献。设 $t(p)=i$,如果顺序枚举走的办公室，比较困难，可以考虑**枚举第 $i$ 个走到的办公室**。由于之后走的办公室都已经被提醒过，那么第 $i$ 次走到的办公室一定不会被 $[l,r]$ 中的任意一个办公室提醒，换言之，第 $i$ 次走的办公室在 $[l,r]$ 区间中不存在约束。可以直接用埃氏筛预处理出这部分数字，设一共有 $m$ 个这样的数。这里需要我们进行预处理。

 第 $i$ 个办公室可以在 $m$ 中任意取，方案数为 $m$。第 $i$ 个办公室之后走的办公室，显然就不能是这 $m$ 个办公室其中之一，那么这一部分的方案数就为 $A_{n-m}^{n-i}$ ,
 第 $i$ 个办公室之前走的办公室，由于我们已经将 $i\sim n$ 的顺序确定好了，那么这一部分的方案数就是 $A_{i-1}^{i-1}$ 最后别忘了乘以贡献 $i$。最终的表达式为：

 $ans=\sum_{i=1}^ni\times m\times\binom{n-m}{n-i}\times(n-i)!\times(i-1)!$。

或者我们有下面的理解方式：
分析一波题意，$t(p)$ 就是对于排列 $p$,没有因子的数出现的最后位置那么我们将所有数分为
 $div_1{: }$ 无因子的数的数量
 $div_2{: }$ 有因子的数的数量这个可以通过埃氏筛求得对于答案，考虑贡献，即为对于每一个位置 $i$,求它能作为 $t(p)$ 的排列数量 $num$

 那么答案便是 $\sum_i(i\times num)$
 对于 $num$ 的求法：
 ·我们让 $div_1$ 其中一个卡在第 $i$ 个位置
 ·其余的 $div_1-1$ 个数在 $[1,i)$ 里面任意分布
 · 这里我们只是考虑了位置。还要考虑方案数所以 $div_1,div_2$ 也都要全排列一下
 那么 $num=1\times\begin{pmatrix}i-1\\div_{1-1}\end{pmatrix}\times(div_{1}!)\times(div_{2}!)$
 由于前 $i$ 个位置要存放完 $div_1$ 个数，所以 $i\in[div_1,n]$
 所以答案为

$$
\sum_{i=div_1}^n(1\times\binom{i-1}{div_1-1}\times(div_1!)\times(div_2!)\times i)
$$



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e7+10,mod=1e9+7;
int fac[N],infac[N],inv[N],l,r,m,ans;bool vis[N];
void init()
{
	fac[0]=infac[0]=fac[1]=infac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=r;i++) fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=2;i<=r;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2;i<=r;i++) infac[i]=1ll*infac[i-1]*inv[i]%mod;
	for(int i=l;i<=r;i++)
    {
        if(vis[i]) continue;m++;
        for(int j=i;j<=r;j+=i) vis[j]=1;
    }
}
int C(int n,int m){if(n<0||m<0||n<m) return 0;return 1ll*fac[n]*infac[m]%mod*infac[n-m]%mod;}
void add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
int main()
{
	scanf("%d%d",&l,&r);init();int n=r-l+1;
	for(int i=1;i<=n;i++) add(ans,1ll*i*m%mod*C(n-m,n-i)%mod*fac[n-i]%mod*fac[i-1]%mod);printf("%d\n",ans);
	return 0;
}

```