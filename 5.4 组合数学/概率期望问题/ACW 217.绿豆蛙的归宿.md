## 题目描述
给出一个有向无环的连通图，起点为 1，终点为 N，每条边都有一个长度。

数据保证从起点出发能够到达图中所有的点，图中所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。

到达每一个顶点时，如果有 K 条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 1/K。

现在绿豆蛙想知道，从起点走到终点所经过的路径总长度的期望是多少？

#### 输入格式

第一行: 两个整数 N，M，代表图中有 N 个点、M 条边。

第二行到第 1+M 行: 每行 33 个整数 a,b,c，代表从 a 到 b 有一条长度为 c 的有向边。

#### 输出格式

输出从起点到终点路径总长度的期望值，结果四舍五入保留两位小数。

#### 数据范围

$$1≤N≤10^5,  
1≤M≤2N$$

## 输入格式
第一行: 两个整数 N，M，代表图中有 N 个点、M 条边。

第二行到第 1+M 行: 每行 33 个整数 a,b,c，代表从 a 到 b 有一条长度为 c 的有向边。


## 输出格式
输出从起点到终点路径总长度的期望值，结果四舍五入保留两位小数。

#### 数据范围


## 样例 #1

### 样例输入 #1

```
4 4
1 2 1
1 3 2
2 3 3
3 4 4
```

### 样例输出 #1

```
7.00
```

## 题解
由期望的线性性，我们可以记 $f[i]$ 为从 i 到 N 的期望长度，那么我们的公式就可以推导为 $E(i)=E\left( \frac{w_{1}+x_{1}}{k} +\frac{w_{2}+x_{2}}{k}+\dots\right)$,转化后就可以变为 $f[i]=\sum \frac{1}{k} (w[i]+f(s[i])$,其中 $s[i]$ 表示为原来的第 i 个孩子。

**注：本题与游走的区别在于，本题中是有向无环图，所以我们可以用拓扑排序而不产生矛盾，如果在一个有向无环图中，就要采用游走的思路！**

## 代码
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010 , M = 2 * N;

double f[N];
int e[M] , ne[M] , w[M] , h[N] , idx;
int n ,m;
int d[N];

void add(int a , int b , int c)
{
    e[idx] = b , ne[idx] = h[a] ; w[idx] = c , h[a] = idx++;
}

double dp(int u)//记忆化搜索
{
    if(f[u] >= 0) return f[u];
    f[u] = 0;
    for(int i = h[u] ; ~i ; i = ne[i])
    {
        int j = e[i];
        f[u] += (w[i] + dp(j)) / d[u];
    }
    return f[u];
}


int main()
{
    cin >> n >> m;
    memset(h , -1 , sizeof h);

    while(m--)
    {
        int a , b , c;
        cin >> a >> b >> c;
        add(a , b , c);
        d[a]++;
    }

    memset(f , -1 , sizeof f);//初始化成一个不存在的数

    printf("%.2lf\n" , dp(1));
    return 0;
}

```