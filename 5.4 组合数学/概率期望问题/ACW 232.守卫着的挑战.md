# 
## 题目描述
打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押 applepi 的监狱的所在地。

突然，眼前一道亮光闪过，“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”。

瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为 K 的包包。

擂台赛一共有 N项挑战，各项挑战依次进行。

第 i 项挑战有一个属性 ai，如果 ai≥0，表示这次挑战成功后可以再获得一个容量为 ai 的包包；如果 ai=−1，则表示这次挑战成功后可以得到一个大小为 1 的地图残片。

地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑，只需要完成所有 N 项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。

并且他们至少要挑战成功 L 次才能离开擂台。

队员们一筹莫展之时，善良的守卫者 Nizem 帮忙预估出了每项挑战成功的概率，其中第 i 项挑战成功的概率为 pi%。

现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。

## 输入格式
第一行三个整数 N,L,K。

第二行 N 个实数，第 i 个实数 pi 表示第 i 项挑战成功的概率的百分比。

第三行 N 个整数，第 i 个整数 ai 表示第 i 项挑战的属性值。


## 输出格式

一个实数，表示所求概率，四舍五入保留 6 位小数。

## 样例 #1

### 样例输入 #1

```
3 1 0
10 20 30
-1 -1 2
```

### 样例输出 #1

```
0.3000000
```

## 提示
我们记 $f(i,j,k)$ 表示考虑前 i 场挑战，成功了 j 次，剩余容量为 k 的概率，我们的转移可以通过概率来计算
$f(i,j-1,k)*p_{i}\to f(i,j+1,k+a[i])$,这是成功
$f(i-1,j,k)*(1-p_{i})\to f(i,j,k)$,那么我们就可以通过直接搜索来转移即可。
![[Pasted image 20230827214535.png]]

## 代码
```cpp
#define MAXN 211
double f[MAXN][MAXN][MAXN<<1|1],p[MAXN];
int main()
{
    int n=read(),L=read(),k=read();
    if(k>n)k=n;
    double ans=0;
    f[0][0][n+k]=1;
    for(int i=1;i<=n;++i)scanf("%lf",&p[i]),p[i]/=100;
    for(int i=1;i<=n;++i)
    {
        int x=read();
        for(int j=0;j<i;++j)
            for(int k=0;k<=n+n;++k)
                if(k+x>=0)
                    f[i][j+1][min(n+n,k+x)]+=p[i]*f[i-1][j][k],f[i][j][k]+=(1-p[i])*f[i-1][j][k];
    }
    for(int j=L;j<=n;++j)
        for(int k=n;k<=(MAXN<<1);++k)ans+=f[n][j][k];
    printf("%.6lf",ans);
    return 0;
}

```