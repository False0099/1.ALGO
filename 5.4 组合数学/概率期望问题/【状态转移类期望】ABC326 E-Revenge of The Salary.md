# [ABC 326 E] Revenge of "The Salary of AtCoder Inc."

## 题面翻译

青木是 AtCoder 公司的一名员工，他本月的工资由整数 $N$ 和长度为 $N$ 的序列 $A$ 决定，具体如下。  
首先，给他一个 $N$ 面的骰子，该骰子以相等的概率显示从 $1$ 到 $N$ 的整数，以及一个变量 $x=0$。

然后，重复以下步骤直到结束。

- 掷一次骰子，让 $y$ 成为结果。
    - 如果是 $x\lt y$，付给他 $A_y$ 日元，让 $x=y$。
    - 否则，终止该过程。

青木这个月的工资就是通过这个过程支付的总额。  
求青木本月工资的对 $998244353$ 取模后的结果。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc326/tasks/abc326_e

AtCoder 社の社員である青木さんの今月の給料は、整数 $ N $ と長さ $ N $ の数列 $ A $ を用いて以下のように決められます。  
 まず、青木さんに $ 1 $ から $ N $ までの整数が等確率で出る $ N $ 面ダイスと変数 $ x=0 $ を渡します。

その後、以下の手順を終了まで繰り返します。

- ダイスを $ 1 $ 度振り、出た目を $ y $ とする。
  - もし $ x\ <\ y $ なら $ A_y $ 円支給し、 $ x=y $ と更新する。
  - そうでないなら終了する。
 
青木さんの今月の給料は、この手順によって支給された金額の合計です。  
 青木さんの今月の給料の期待値を $ {}\bmod{998244353} $ で求めてください。

 期待値 $ {}\bmod{998244353} $ の定義 この問題で求める期待値は必ず有理数になることが証明できます。 また、この問題の制約下では、求める期待値を既約分数 $ \frac\ yx $ で表したときに $ x $ が $ 998244353 $ で割り切れないことが保証されます。 このとき、$ y\equiv\ xz\pmod{998244353} $ を満たす $ 0\leq\ z\lt 998244353 $ がただ一つ存在するので、$ z $ を出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \dots $ $ A_N $

## 输出格式

答えを出力せよ。

## 样例 #1

### 样例输入 #1

```
3
3 2 6
```

### 样例输出 #1

```
776412280
```

## 样例 #2

### 样例输入 #2

```
1
998244352
```

### 样例输出 #2

```
998244352
```

## 样例 #3

### 样例输入 #3

```
9
3 14 159 2653 58979 323846 2643383 27950288 419716939
```

### 样例输出 #3

```
545252774
```

## 提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 0\ \le\ A_i\ <\ 998244353 $
 
### Sample Explanation 1

手順の一例は、以下の通りです。 - 最初、 $ x=0 $ である。 - ダイスを $ 1 $ 度振り、出た目が $ 1 $ であった。 $ 0\ <\ 1 $ であるため、 $ A_1\ =\ 3 $ 円支給し、 $ x=1 $ とする。 - ダイスを $ 1 $ 度振り、出た目が $ 3 $ であった。 $ 1\ <\ 3 $ であるため、 $ A_3\ =\ 6 $ 円支給し、 $ x=3 $ とする。 - ダイスを $ 1 $ 度振り、出た目が $ 1 $ であった。 $ 3\ \ge\ 1 $ であるため、終了する。 この例では、青木さんの今月の給料は $ 9 $ 円です。 なお、青木さんの今月の給料の期待値は $ \frac{49}{9} $ 円と求めることができ、これを $ {}\bmod{998244353} $ 上で表現すると $ 776412280 $ となります。
## 题解
根据期望的线性性，总工资的期望等于在每一个 $i$ 处获得的工资的期望之和，而在 $i$ 处获得的工资的期望 $E(i)=A_i\times p(i)$,其中 $p(i)$ 表示掷骰子掷到 $i$ 且有效的概率。

初始 $p(0)=1$,则只有从 $0\sim i-1$ 掷骰子掷到 $i$ 时才有效，显然每一种情况掷到 $i$ 的概率均为 $\frac1n$,因
此有转移方程：

$$
p(i)=\frac1n\sum_{j=0}^{i-1}p(j)
$$

使用前缀和优化即可做到 $O(n)$。


```cpp
#include<bits/stdc++.h>

using namespace std;

#define mod 998244353
#define FACSIZE 1048576

long long power(long long a,long long b){
  long long x=1,y=a;
  while(b>0){
    if(b&1ll){
      x=(x*y)%mod;
    }
    y=(y*y)%mod;
    b>>=1;
  }
  return x%mod;
}

long long modular_inverse(long long n){
  return power(n,mod-2);
}

int main(){
  long long n;
  cin >> n;
  long long invn=modular_inverse(n);
  long long p=invn,res=0;
  for(long long i=0;i<n;i++){
    long long a;
    cin >> a;
    res+=p*a;res%=mod;
    p+=p*invn;p%=mod;
  }
  cout << res << "\n";
  return 0;
}

```