## 题目描述
Freda 发明了传呼机之后，rainbow 进一步改进了传呼机发送信息所使用的信号。

由于现在是数字、信息时代，rainbow 发明的信号用 N 个自然数表示。

为了避免两个人的对话被大坏蛋 VariantF 偷听，rainbow 把对话分成 A、B、C 三部分，分别用 a、b、c 三个密码加密。

现在 Freda 接到了 rainbow 的信息，她的首要工作就是解密。

Freda 了解到，这三部分的密码计算方式如下：

在 1∼N 这 N 个数中，等概率地选取两个数 l、r，如果 l>r，则交换 l、r。

把信号中的第 l 个数到第 r 个数取出来，构成一个数列 P。

A 部分对话的密码是数列 P 的 xor 和的数学期望值，xor 和就是数列 P 中各个数异或之后得到的数； xor 和的期望就是对于所有可能选取的 l、r，所得到的数列的 xor 和的平均数。

B 部分对话的密码是数列 P 的 and 和的期望，定义类似于 xor 和。

C 部分对话的密码是数列 P 的 or 和的期望，定义类似于 xor 和。

请你帮忙计算这三个密码。

## 输入格式

第一行一个正整数 N。

第二行 N 个自然数，表示 Freda 接到的信号。

## 输出格式
一行三个实数，分别表示 xor 和、and 和、or 和的期望，四舍五入保留 3 位小数，相邻两个实数之间用一个空格隔开。

## 样例 #1

### 样例输入 #1

```
2
4 5
```

### 样例输出 #1

```
2.750 4.250 4.750
```

## 题解
对于我们选择的 $l,r$，如果 $l=r$，则对于某个值选中的概率为 $\frac{2}{n^2}$,如果 $l\neq r$,那么对于两个固定的 $l,r$ 一个数被选中的概率为 $\frac{2}{n}$

我们按照期望的线性性，把一段转换为二进制上每一位的期望之和。我们记每一位上的贡献为他们作为右端点时的贡献，那么我们的贡献就可以按照如下方式来计算：

如果是 or 和且当前位为 1，则前面的所有数都可以选，我们的贡献就是当前的位置前面所有数的个数，如果当前位为 0，我们的贡献就可以设置为前面第一个一出现的位置到这个位置。

如果是 and 和，如果当前为 1，则计算前面有多少个连续数位位 1，这样的连续数就是我们的贡献。如果为 0，那么贡献就只能是 0 了。

如果是计算 xor 和，我们就需要分别统计每个数奇数和偶数的贡献，如果当前位为 1，则应该加上前一个数偶数的贡献+1, 否则加上前一个数奇数的贡献。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int a[N],n,last[2];
long double ans_xor,ans_or,ans_and;
void solve()
{
	for(int i=0;i<31;i++)
	{
		last[1]=last[0]=0;
		int c1=0,c2=0;
		for(int j=1;j<=n;j++)
		{
			int t=(a[j]>>i)&1;
			if(t==1)
			{
				ans_or+=(1<<i)*2.0/n/n*(j-1);		
				ans_or+=(1<<i)*1.0/n/n;
				ans_and+=(1<<i)*2.0/n/n*(j-(last[0]+1));
				ans_and+=(1<<i)*1.0/n/n;
				ans_xor+=(1<<i)*2.0/n/n*c1; 
				ans_xor+=(1<<i)*1.0/n/n;
			}
			else 
			{
				ans_or+=(1<<i)*2.0/n/n*last[1];
				ans_xor+=(1<<i)*2.0/n/n*c2;
			}
			last[t]=j;
			c1++;
			if(t==1) swap(c1,c2);
			
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);	
	solve();
	printf("%.3Lf %.3Lf %.3Lf",ans_xor,ans_and,ans_or);
	return 0;
} 

```