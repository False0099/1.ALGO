# 知识点
  ## [[动态规划]] [[概率问题]] [[求最值]]
# 题目
 

炸鸡块君想要买一款 steam 游戏，由于不可抗力，这款游戏将在 n 天后下架。  
  
该游戏的价格每天都会变动，通过内部消息，炸鸡已经知道该游戏第 i 天的价格等概率的为 ai​和 bi​之一，在每一天的最开始，steam 会公布该游戏当天的价格（为 ai和 bi​）之一，然后炸鸡可以决定在这一天是否买该游戏。  
  
现在，炸鸡想知道如果他采取最优（花费最少）的购买策略，在保证能买到该游戏的前提下，期望会花多少钱。  
  
（可以观看样例获得进一步理解）

## 输入描述:

输入第一行是一个整数 T $(1\leq T\leq 10^5)$ ，表示用例组数。  
  
每组用例第一行是一个整数 n  $(1\leq n\leq 10^5)$ ，含义如题所述。  
  
每组用例的第二行是 n 个正整数，第 i 个数字为  $a_i(1\leq a_i \leq 10^6)$ ，含义如题所述。  
  
每组用例的第三行是 n 个正整数，第 i 个数字为  $b_i(1\leq b_i \leq 10^6)$ ，含义如题所述。  
  
保证测试数据 n 的和 $\sum n\leq 10^5$。
# 思路

考虑倒着的期望 dp； $dp[i]$ 表示前 $i-1$ 天都没有买，只考虑从第 $i$ 天开始直到第 $n$ 天这段，期望的最低购买价格；
 在第 $i$ 天，有 0.5 概率价格为 $a[i]$,此时要比较 $\alpha[i]$ 和 $dp[i+1]$,谁小选谁；还有 0.5 概率价格为 $b[i]$,同
 理：
 因此写出转移式子，按 $i$ 从 $n$ 到 1 顺序转移：

$$
dp[i]=0.5*min(a[i],dp[i+1])+0.5*min(b[i],dp[i+1])
$$

# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
double dp[N];
double a[N],b[N];
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    dp[n+1]=1e7;
    for(int i=n;i>=1;i--)
        dp[i]=0.5*min(dp[i+1],a[i])+0.5*min(dp[i+1],b[i]);
    cout<<dp[1]<<'\n';}
    return 0;
}
```
# 备注
