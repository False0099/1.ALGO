# OSU!

## 题目背景

原《产品排序》参见 P 2577

## 题目描述

Osu 是一款群众喜闻乐见的休闲软件。 

我们可以把 osu 的规则简化与改编成以下的样子: 

一共有 $n$ 次操作，每次操作只有成功与失败之分，成功对应 $1$，失败对应 $0$，$n$ 次操作对应为 $1$ 个长度为 $n$ 的 01 串。在这个串中连续的  $X$ 个 $1$ 可以贡献 $X^3$ 的分数，这 $x$ 个 $1$ 不能被其他连续的 $1$ 所包含（也就是极长的一串 $1$，具体见样例解释） 

现在给出 $n$，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留 $1$ 位小数。

## 输入格式

第一行有一个正整数 $n$，表示操作个数。接下去 $n$ 行每行有一个 $[0,1]$ 之间的实数，表示每个操作的成功率。

## 输出格式

只有一个实数，表示答案。答案四舍五入后保留 $1$ 位小数。

## 样例 #1

### 样例输入 #1

```
3 
0.5 
0.5 
0.5
```

### 样例输出 #1

```
6.0
```

## 提示

【样例说明】

$000$ 分数为 $0$，$001$ 分数为 $1$，$010$ 分数为 $1$，$100$ 分数为 $1$，$101$ 分数为 $2$，$110$ 分数为 $8$，$011$ 分数为 $8$，$111$ 分数为 $27$，总和为 $48$，期望为 $\dfrac{48}8 = 6.0$。

$n \leq 1 \times 10 ^ 5$。

## 题解
我们先考虑一个暴力的想法，我们假设目前生成的 0-1 串中有 j 个 1 是连续的，那么我们的结果就是
	$\sum_{i=0}^n \sum_{j=1}^i p_{ij}j^3$ 其中 $p_{ij}$ 表示我们结束位置为 i 的连续 0-1 串，他的长度为 j 的概率。其中，我们的 $p[i][j]$ 是可以进行预处理的。

接下来，我们考虑对我们的原式进行等价变化来简化我们的答案。
我们考虑到差分操作：我们令 $f_{i}=\sum_{j=1}^n p_{ij}-\sum_{j=i+1}^n p_{ij}$,我们 $f_{i}$ 的意义为：结束位置为 i 的连续 01 串，其长度>=j 的概率。



对原本的求和式子进行一次**abel变换**，我们就可以得到下面的式子，其中 $f_{ij}$ 如上所示
$$
ANS=\sum_{i=1}^n \sum_{j=1}^i [3(j-1)^2+3(j-1)+1]f_{i,j}
$$
我们首先记 $y_{i}=\sum_{j=1}^i j^2p_{ij}$ = $\sum_{j=1}^i [2\times(j-1)+1]f_{ij}$,于是 
$y_{i}-y_{i-1}*pi=2*x_{i-1}p_{i}+p_{i}$,

同理我们的递推式就有
$ANS_{i}=(ANS_{i-1}+3*y_{i-1}+3*x_{i-1}+1)\times p_{i}$.


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;dd a[N],x[N],y[N],dis[N];
int main()
{
    n=read();
    for(RG int i=1;i<=n;i++){
        scanf("%lf",&a[i]);
        x[i]=(x[i-1]+1)*a[i];
        y[i]=(y[i-1]+2*x[i-1]+1)*a[i];
        dis[i]=dis[i-1]+(3*y[i-1]+3*x[i-1]+1)*a[i];
    }
    printf("%.1lf\n",dis[n]);
    return 0;
}
```