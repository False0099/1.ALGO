# [HNOI 2015] 亚瑟王

## 题目描述

小 K 不慎被 LL 邪教洗脑了，洗脑程度深到他甚至想要从亚瑟王邪教中脱坑。他决定，在脱坑之前，最后再来打一盘亚瑟王。既然是最后一战，就一定要打得漂亮。众所周知，亚瑟王是一个看脸的游戏，技能的发动都是看概率的。

作为一个非洲人，同时作为一个前 OIer，小 K 自然是希望最大化造成伤害的期望值。但他已经多年没写过代码，连 Spaly 都敲不对了，因此，希望你能帮帮小 K，让他感受一下当欧洲人是怎样的体验。

本题中我们将考虑游戏的一个简化版模型。玩家有一套卡牌，共 $n$ 张。游戏时，玩家将 $n$ 张卡牌排列成某种顺序，排列后将卡牌按从前往后依次编号为 $1 -  n$。本题中，顺序已经确定，即为输入的顺序。每张卡牌都有一个技能。第 $i$ 张卡牌的技能发动概率为 $p_i$，如果成功发动，则会对敌方造成 $d_i$ 点伤害。也只有通过发动技能，卡牌才能对敌方造成伤害。基于现实因素以及小 K 非洲血统的考虑，$p_i$ 不会为 $0$，也不会为 $1$，即 $0 < p_i < 1$。一局游戏一共有 $r$ 轮。在每一轮中，系统将从第一张卡牌开始，按照顺序依次考虑每张卡牌。在一轮中，对于依次考虑的每一张卡牌：

1. 如果这张卡牌在这一局游戏中已经发动过技能，则

1.1. 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌）；否则（是最后一张），结束这一轮游戏。

2. 否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第 $i$ 张

2.1. 将其以 $p_i$ 的概率发动技能。

2.2. 如果技能发动，则对敌方造成 $d_i$ 点伤害，并结束这一轮。

2.3. 如果这张卡牌已经是最后一张（即 $i$ 等于 $n$），则结束这一轮；否则，考虑下一张卡牌。

请帮助小 K 求出这一套卡牌在一局游戏中能造成的伤害的期望值。

## 输入格式

输入文件的第一行包含一个整数 $T$，代表测试数据组数。 

接下来一共 $T$ 组数据。 

每组数据的第一行包含两个用空格分开的整数 $n$ 和 $r$，分别代表卡牌的张数和游戏的轮数。

接下来 $n$ 行，每行包含一个实数和一个整数，由空格隔开，描述一张卡牌。第 $i$ 行的两个数为 $p_i$ 和 $d_i$，分别代表第 $i$ 张卡牌技能发动的概率（实数）和技能发动造成的伤害（整数）。保证 $p_i$ 最多包含 $4$ 位小数，且为一个合法的概率。

## 输出格式

对于每组数据，输出一行，包含一个实数，为这套卡牌在这一局游戏中造成的伤害的期望值。对于每一行输出，只有当你的输出和标准答案的相对误差不超过 $10^{-8}$ 时——即 $\frac{|a-o|}{a} \leq 10^{-8}$ 时 (其中 $a$ 是标准答案， $o$ 是输出)，你的输出才会被判为正确。建议输出 $10$ 位小数。

## 样例 #1

### 样例输入 #1

```
1
3 2
0.5000 2
0.3000 3
0.9000 1
```

### 样例输出 #1

```
3.2660250000
```

## 提示

一共有 $13$ 种可能的情况：

1.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.15$，伤害为 $5$。

2.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.315$，伤害为 $3$。

3.  第一轮中，第 $1$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.035$，伤害为 $2$。

4.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.075$，伤害为 $5$。

5.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.0675$，伤害为 $4$。

6.  第一轮中，第 $2$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.0075$，伤害为 $3$。

7.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.1575$，伤害为 $3$。

8.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.04725$，伤害为 $4$。

9.  第一轮中，第 $3$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.11025$，伤害为 $1$。

10.  第一轮不发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.0175$，伤害为 $2$。

11.  第一轮不发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.00525$，伤害为 $3$。

12.  第一轮不发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.011025$，伤害为 $1$。

13.  第一轮不发动技能；第二轮亦不发动技能；

概率为 $0.001225$，伤害为 $0$。

造成伤害的期望值为概率与对应伤害乘积之和，为 $3.266025$。


对于所有测试数据， $1 \leq T \leq 444， 1 \leq n \leq 220， 0 \leq r \leq 132， 0 < p_i < 1， 0 \leq d_i \leq 1000$。

除非备注中有特殊说明，数据中 $p_i$ 与 $d_i$ 均为随机生成。

请注意可能存在的实数精度问题，并采取适当措施。

本题使用 `special_judge`。

## 题解
假设我们的轮数无限，那么可以先按照我们的种类来归纳，因为每一种只能造成至多一次伤害，所以我们只需要按照我们的卡牌种类来计算即可。**在每一轮中，出了一张卡的时候立即结束该轮**

我们考虑计算我们每一张牌在 $r$ 轮中被打出的概率，显然打出的概率等于 $1-没有被打出的概率$，于是我们转而计算我们进行了 $r$ 轮，第 $i$ 张牌还没有被打出去的概率是多少。

我们考虑收完两把：我们第二张牌经过 $r$ 轮都没出去的概率，显然就可以分为两种情况：
1. 我们的第一张牌完全没有发动过，那么我们有可能发动第二张牌的次数就有 $r$ 次，因此我们的概率就是 $1-(1-p[i])^r$
2. 我们的第一张牌发动过一次，那么我们有可能发动第二章牌的次数就有 $r-1$ 次，因此我们的概率就是 $1-(1-p[i])^{r-1}$,再乘上我们第一张牌发动过一次的概率。

我们考虑三张牌经过 $r$ 轮都没出去的概率，显然可以分为下面的几种情况：
1. 第一种我们前面的所有牌都没有发动过，那么我们有可能发动第 2 张牌的次数就有 $r$ 次，因此我们的概率就是 $(1-(1-p[i]^r))$
2. 我们的第一次牌发动一次，第二张牌没有发动，后者第一张牌没有发动，第二张牌发动一次，那么我们的概率就是 $(1-(1-p[i])^{r-1})*p$
3. 


```cpp
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;
const int MAXN = 223;
const int MAXR = 135;

int n, r, d[MAXN];
double p[MAXN], fp[MAXN];

double pow1p[MAXN][MAXN]; // pow1p[i][j]表示(1-p[i])^j
void prelude() {
    for( int i = 0; i < n; ++i ) {
        pow1p[i][0] = 1;
        for( int j = 1; j <= r; ++j )
            pow1p[i][j] = pow1p[i][j-1] * (1-p[i]);
    }
}

double f[MAXN][MAXR];
double solve() {
    memset( f, 0, sizeof(f) );
    memset( fp, 0, sizeof(fp) );
    f[0][0] = pow1p[0][r]; // 边界
    f[0][1] = fp[0] = 1-f[0][0];
    for( int i = 1; i < n; ++i ) {
        for( int j = 0; j <= r; ++j ) {
            fp[i] += f[i-1][j] * (1 - pow1p[i][r-j]); // 根据f计算fp
            f[i][j] += f[i-1][j] * pow1p[i][r-j]; // 不选第i张
            if( j ) f[i][j] += f[i-1][j-1] * (1 - pow1p[i][r-j+1]); // 选第i张
        }
    }
    double rtn = 0;
    for( int i = 0; i < n; ++i ) {
        // printf( "fp[%d] = %lf\n", i, fp[i] );
        rtn += d[i] * fp[i];
    }
    return rtn;
}

int main() {
    int T; scanf( "%d", &T );
    while( T-- ) {
        scanf( "%d%d", &n, &r );
        for( int i = 0; i < n; ++i ) scanf( "%lf%d", p+i, d+i );
        prelude();
        printf( "%.10lf\n", solve() );
    }
    return 0;
}
```