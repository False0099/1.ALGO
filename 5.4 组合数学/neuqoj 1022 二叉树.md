[[非当前学期/2023秋主要学科/数据结构习题/树/线索二叉树|线索二叉树]]
#组合计数 #树遍历
### 题目描述

众所周知，遍历一棵二叉树就是按某条搜索路径巡访其中每个结点，使得每个结点均被访问一次，而且仅被访问一次。最常使用的有三种遍历的方式：

１．前序遍历：若二叉树为空，则空操作；否则先访问根结点，接着前序遍历左子树，最后再前序遍历右子树。

２．中序遍历：若二叉树为空，则空操作；否则先中序遍历左子树，接着访问根结点，最后再前中遍历右子树。

３．后序遍历：若二叉树为空，则空操作；否则先后序遍历左子树，接着后序遍历右子树，最后再访问根结点。

现在的问题是给定前序遍历和后序遍历的顺序，要求出总共有多少棵不同形态的二叉树满足这样的遍历顺序。

### 输入描述

输入有多组数据，每组数据两行，第一行给出前序遍历的访问顺序，第二行给出后序遍历的访问顺序。

二叉树的结点用一个大写字母表示，不会有两个结点标上相同字母。输入数据不包含空格，且保证至少有一棵二叉树符合要求。

### 输出描述

输出一个整数，为符合要求的不同形态二叉树的数目。

#### 样例输入

ABCD
CBDA

#### 样例输出

2

## 题解
我们只知道二叉树的前序遍历结果和后序遍历结果是不能求出我们的唯一的一颗二叉树，原因在于，如果一个结点只有一个孩子时，无论他是左孩子或者是右孩子，那么他们的前序和后续结果是一样的，
于是，现在我们就需要找到只有一个孩子的二叉树：也就是：前序遍历是 AB，后序遍历是 BA 的这种情况。这里，我们的思路是通过一个

```cpp
`#include<iostream>`

`#include<string>`

`using` `namespace` `std;`

`int` `main()`

`{`

    `string pre,post;`

    `cin>>pre>>post;`

    `int` `count=1;`

    `int` `temp=post.size()-1;`     `//对于前序遍历与后序遍历，前序的第一个结点与后序的最后一个结点是一样的`

    `int` `size=post.size();`

    `for``(``int` `i=1;i<size;i++)`

    `{`

        `int` `j=post.find(pre[i]);`

        `if``(j==temp-1)count*=2;`

        `temp=j;`

    `}`

    `cout<<count;`

    `return` `0;`

`}`
```