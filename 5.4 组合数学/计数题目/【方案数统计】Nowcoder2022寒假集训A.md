## 题目描述
一个数字的数字根是指：将数字各数位上的数字相加得到一个新的数，直到得到的数字小于 10 为止，例如，149 的数字根为 149=1+4+9=14，1+4=5，所以我们 149 的数字根为 5. 我们约定，小于 10 的数字，其数字根就为其本身。现在给你 n 个数，问最后和的数字根为 $(1-9)$ 的组合有多少种。

## 题解
我们这一题发现，如果我们正向推我们的数字根是很简单，那么我们能否根据我们最后数字根是多少来推导. $f(a+b)=f(a)+f(b)$,所以，我们就可以先计算出我们这 n 个数字对应的数字根分别是多少，我们记作一个桶，然后我们把对应的数字直接加到我们的桶当中去。之后，我们就可以用我们的 $dp[i][j]$ 来解决。我们设 $dp[i][j]$ 表示我们前 i 个数字和为 j 的组合方案有多少种。

然后我们的转移就有：$dp[i][j]+=dp[i-1][j-w[i]]$
```cpp
```cpp
int d(int n) {
	if (n < 10)return n;
	int res = 0;
	while (n)res += n % 10, n /= 10;
	return d(res);
}
int n;
int a[maxnum];
int f[maxnum][10];
void slove() {
	cin >> n;
	for (int i = 1; i <= n; i++)cin >> a[i];
	for (int i = 1; i <= n; i++) {
		f[i][d(a[i])]++;
		for (int j = 1; j <= 9; j++)(f[i][j] += f[i - 1][j])%=mod;
		for (int j = 1; j <= 9; j++) (f[i][d(d(a[i]) + j)] += f[i - 1][j])%=mod;
	}
	for (int i = 1; i <= 9; i++)cout << f[n][i] << " ";
	cout << endl;
}
```
```