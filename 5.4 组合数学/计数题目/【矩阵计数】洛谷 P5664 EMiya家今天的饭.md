# [CSP-S 2019] Emiya 家今天的饭

## 题目描述

Emiya 是个擅长做菜的高中生，他共掌握 $n$ 种**烹饪方法**，且会使用 $m$ 种**主要食材**做菜。为了方便叙述，我们对烹饪方法从 $1 \sim n$ 编号，对主要食材从 $1 \sim m$ 编号。

Emiya 做的每道菜都将使用**恰好一种**烹饪方法与**恰好一种**主要食材。更具体地，Emiya 会做 $a_{i,j}$ 道不同的使用烹饪方法 $i$ 和主要食材 $j$ 的菜（$1 \leq i \leq n$、$1 \leq j \leq m$），这也意味着 Emiya 总共会做 $\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} a_{i,j}$ 道不同的菜。

Emiya 今天要准备一桌饭招待 Yazid 和 Rin 这对好朋友，然而三个人对菜的搭配有不同的要求，更具体地，对于一种包含 $k$ 道菜的搭配方案而言：
- Emiya 不会让大家饿肚子，所以将做**至少一道菜**，即 $k \geq 1$
- Rin 希望品尝不同烹饪方法做出的菜，因此她要求每道菜的**烹饪方法互不相同**
- Yazid 不希望品尝太多同一食材做出的菜，因此他要求每种**主要食材**至多在**一半**的菜（即 $\lfloor \frac{k}{2} \rfloor$ 道菜）中被使用

这里的 $\lfloor x \rfloor$ 为下取整函数，表示不超过 $x$ 的最大整数。

这些要求难不倒 Emiya，但他想知道共有多少种不同的符合要求的搭配方案。两种方案不同，当且仅当存在至少一道菜在一种方案中出现，而不在另一种方案中出现。

Emiya 找到了你，请你帮他计算，你只需要告诉他符合所有要求的搭配方案数对质数 $998,244,353$ 取模的结果。

## 输入格式

第 1 行两个用单个空格隔开的整数 $n,m$。

第 2 行至第 $n + 1$ 行，每行 $m$ 个用单个空格隔开的整数，其中第 $i + 1$ 行的 $m$ 个数依次为 $a_{i,1}, a_{i,2}, \cdots, a_{i,m}$。

## 输出格式

仅一行一个整数，表示所求方案数对 $998,244,353$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
2 3 
1 0 1
0 1 1
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
3 3
1 2 3
4 5 0
6 0 0
```

### 样例输出 #2

```
190
```

## 样例 #3

### 样例输入 #3

```
5 5
1 0 0 1 1
0 1 0 1 0
1 1 1 1 0
1 0 1 0 1
0 1 1 0 1
```

### 样例输出 #3

```
742
```

## 提示

【样例 1 解释】

由于在这个样例中，对于每组 $i, j$，Emiya 都最多只会做一道菜，因此我们直接通过给出烹饪方法、主要食材的编号来描述一道菜。

符合要求的方案包括：
- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 2 的菜
- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 3 的菜
- 做一道用烹饪方法 1、主要食材 3 的菜和一道用烹饪方法 2、主要食材 2 的菜

因此输出结果为 $3 \bmod 998,244,353 = 3$。需要注意的是，所有只包含一道菜的方案都是不符合要求的，因为唯一的主要食材在超过一半的菜中出现，这不满足 Yazid 的要求。

【样例 2 解释】

Emiya 必须至少做 2 道菜。

做 2 道菜的符合要求的方案数为 100。

做 3 道菜的符合要求的方案数为 90。

因此符合要求的方案数为 100 + 90 = 190。

【数据范围】

| 测试点编号 | $n=$ | $m=$ | $a_{i,j}<$ | 测试点编号 | $n=$ | $m=$  | $a_{i,j}<$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $2$ | $2$ | $7$ | $10$ | $2$ | $10^3$ |
| $2$ | $2$ | $3$ | $2$ | $8$ | $10$ | $3$ | $10^3$ |
| $3$ | $5$ | $2$ | $2$ | $9\sim 12$ | $40$ | $2$ | $10^3$ |
| $4$ | $5$ | $3$ | $2$ | $13\sim 16$ | $40$ | $3$  | $10^3$ |
| $5$ | $10$ | $2$ | $2$ | $17\sim 21$ | $40$ | $500$ | $10^3$ |
| $6$ | $10$ | $3$ | $2$ | $22\sim 25$ | $100$ | $2\times 10^3$ | $998244353$ |

对于所有测试点，保证 $1 \leq n \leq 100$，$1 \leq m \leq 2000$，$0 \leq a_{i,j} \lt 998,244,353$。

## 题解
给出一个矩阵，要求每行只能选一个节点，每列选的节点不能超过所有选的节点的一半，不能不选，给出每个节点的选择方案数，求总方案数。
我们就可以设我们 $f[i][j][k]$ 表示前 i 行选 j 个结点，当前枚举到的列选 k 个节点的方案数，对于每一列，我们的复杂度都是 $o(n^3)$,于是我们总的复杂度就是我们的 $o(mn^3)$,

我们考虑进行优化：根据我们的限制条件，我们可以变形得到一个式子 $2k+n-j>n$,我们于是对于每个结点，选他时，当作该列选了两次，二我们对于某一行不选时，当作所有列选了一次，最后要找的就是当前列被选超过 n 次的方案。
```c++
f[j][k]=(f[j][k]+f[j-1][k]*(cnt[j]-w[j][i]))%P;//不选当前列
f[j][k+1]=(f[j][k+1]+f[j-1][k])%P;//不选当前行
f[j][k+2]=(f[j][k+2]+f[j-1][k]*w[j][i])%P;//选当前行当前列对应的节点
```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int N=200,M=3000,P=998244353;//FFT（雾
int n,m;
ll ans=1;
ll cnt[N],w[N][M],f[N][M];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			scanf("%lld",&w[i][j]),cnt[i]=(cnt[i]+w[i][j])%P;
		ans=(ans*(cnt[i]+1))%P;//计算全部答案
	}
	ans=(ans+P-1)%P;//减去全部不选的情况
	for(int i=1;i<=m;i++)
	{
		memset(f,0,sizeof(f));
		f[0][0]=1;//DP初值
		for(int j=1;j<=n;j++)
			for(int k=0;k<=2*(j-1);k++)
			{
				f[j][k]=(f[j][k]+f[j-1][k]*(cnt[j]-w[j][i]))%P;
				f[j][k+1]=(f[j][k+1]+f[j-1][k])%P;
				f[j][k+2]=(f[j][k+2]+f[j-1][k]*w[j][i])%P;
			}
		for(int j=n+1;j<=2*n;j++)
			ans=(ans+P-f[n][j])%P;//减去当前枚举到的不合法方案
	}
	printf("%lld",ans);
	return 0;
}
```

 148