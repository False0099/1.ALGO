# [Cnoi 2021] 数学练习

## 题目背景

「Cnoi 2021」Cirno's Easy Round II 热身赛开始了。

## 题目描述

为了让选手们重视文化课，Cirno 特意加入了一道 Kamishirasawa Keine 老师的数学练习：

> 求将一个集合 $\texttt{U}=\{1,2,3,\cdots,n\}$ 划分成两个子集 $S,T$，使得 $|S|\notin S,|T|\notin T$ 的方案数。

由于选手都不会高精度，所以答案只需要对 $998244353$ 取模即可。

## 输入格式

一行一个整数 $n$。

## 输出格式

一行，一个整数，表示答案。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
6
```

### 样例输出 #2

```
10
```

## 样例 #3

### 样例输入 #3

```
65535
```

### 样例输出 #3

```
459810767
```

## 提示

**样例解释** 

#1 : 两种合法的划分方案为 $\{1,3\},\{2\}$ 与 $\{2\},\{1,3\}$ 。

**数据范围**

对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$。

## 题解
首先本题，如果我们在一开始没有思路，我们不妨先去考虑像一点时间复杂度更高的方法，比如在这里，我们就可以枚举我们的子集的大小，然后再去考虑我们在这种划分下有多少可能的方案，这里由于我们的子集是有区别的，所有我们的枚举应该从我们的 $1-n$ 都要去枚举。

假设我们现在分出来的是一个 $1,n-1$,那么我们的 $n-1$ 一定不能再我们的第二个集合，所以他只能在我们的第一个集合，这种方法我们的方案数是 1

我们考虑 $(2,n-2)$,我们的 $n-2$ 不能放在第二个元素，我们的 $2$ 不能放在我们的第一个集合，于是我们现在还剩下 $(n-2)$ 个元素，我们现在要把我们这 $n-2$ 个元素分成 $(1,n-3)$ 的方案数，显然就是有 $(n-2)$ 种方案数

在考虑 $(3,n-3)$ ，这是我们有：$(n-2)$ 个元素，分为 $(2,n-4)$ 的方案数，显然就是 $C_{n-2}^2$。

以此类推，我们不难发现，最终我们的方案数就是 $\sum_{i=0}^{n-1} C_{n-2}^i$。于是由我们的组合数公式我们总计就有 $2^{n-2}$ 种方法

**但是我们对于我们的偶数时，我们的有一种状态会被重复计算**，就是我们的 $s_{1}=t_{1}$ 时候的对应情况。所以如果是偶数，我们还需要减去 $C_{n-2}^{n-2/2}$ 即可。

```cpp
#include<iostream>
#define int long long
using namespace std;
const int Mod=998244353;
int jc[100006];
void init()
{
	jc[0]=jc[1]=1;
	for(int i=1;i<=100005;i++)
		jc[i]=(jc[i-1]%Mod*i%Mod)%Mod; 
}//预处理阶乘
int qpow(int a,int b,int c)
{
	int res=1;
	while(b)
	{
		if(b&1)
			res=res*a%Mod;
		b>>=1;
		a=a*a%Mod;
	}
	return res%Mod;
}//快速幂
int C(int a,int b)
{
	return jc[a]%Mod*qpow(jc[b],Mod-2,Mod)%Mod*qpow(jc[a-b],Mod-2,Mod)%Mod;
}//计算组合数，详细见链接
signed main()
{
	int n;
	cin>>n;
    if(n==1)
    {
        cout<<0;
        return 0;
    }//特判，否则会WA on #4
	init();//预处理阶乘
	int ans=1;
	for(int i=1;i<=n-2;i++)
		ans=(ans*2)%Mod;//计算2的n-2次方
	if(n%2==0)//如果n为偶数
	{
		int m=n-2,j=C(m,m/2);//计算组合数
		ans-=j;//将答案减去组合数
		ans+=Mod;//因为减是模意义下的，可能出现负数如6>4但6%5<4%5。所以加一个Mod再取模。
	}
	cout<<ans%Mod;//输出
	return 0;
}

```