# 知识点
  ## [[字符串]] [[动态规划]]
# 题目
小红拿到了一个仅由数字字符组成的字符串。她准备选择一个非空子序列，使得该子序列中不包含连续的"61"子串。
小红想知道，有多少种不同的子序列选择方式？答案对$10^9+7$取模。

# 思路
·以后我们但凡遇到这种求子序列选择方式，而且对子序列有简单要求的，我们都可以用动态规划的方法去解
·遍历到 $s[i]$时，新的子串有两种选择，
1、直接在 $dp[i - 1]$ 表示的每一个子串后面加上 $s[i]$，这是第一种方法。
2、$s[i]$ 成为一个独立的子串。

由上面两种方法我们有： $dp[i] = dp[i - 1] * 2 + 1$

当 $s[i] = '1'$时，符合题意的子串数目应该等于当 $s[i] != '1'$时合法子串的数目再减去遍历到 $s[i]$时所有以6结尾的子串数目。

用 $dp6[i - 1]$表示遍历到 $s[i - 1]$时所有以6结尾的子串数目，可以得到
$dp[i] = dp[i - 1] * 2 + 1 - dp6[i - 1]$
显然，$dp[0] = 0, dp6[0] = 0$, 当且仅当 s[i] = '6'时，更新 dp6，$dp6[i] = dp6[i - 1] + dp[i - 1] + 1$，
且答案为 $dp[s.size() - 1]$。
# AC 代码
```cpp
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    string s;
    cin >> s;
    ll ans = 0, s6 = 0;
    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == '1')
            ans = (ans * 2 + 1 - s6 + mod) % mod;
        else
        {
            if (s[i] == '6')
                s6 = (s6 + ans + 1) % mod;
            ans = (ans * 2 + 1) % mod;
        }
    }
    cout << ans << endl;
    return 0;
}
```
# 备注
