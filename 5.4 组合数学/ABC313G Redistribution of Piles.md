# [ABC 313 G] Redistribution of Piles

## 题面翻译

你有从 $1$ 到 $N$ 编号的 $N$ 盘石子，第 $i$ 盘石子的个数为 $a_i$，同时你还有一个空背包。

你可以进行以下操作任意次：
1. 从有一个以上石头的盘子里各拿一个石头。取下的石头移动到背包里。
2. 当背包中有大于等于 $N$ 个石子时，从背包中拿出 $N$ 个石子，每盘各放入一个石子。

问最终得到的 $N$ 堆石子个数组成的序列有多少种，答案对 $998244353$ 取模。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_g

$ 1 $ から $ N $ までの番号がついた $ N $ 枚の皿があります。皿 $ i $ には $ a_i $ 個の石が載っています。また、空の袋があります。  
あなたは以下の 2 種類の操作を好きな順番で 0 回以上何度でも行うことができます。

- 石が $ 1 $ 個以上載っている皿全てから石を $ 1 $ 個ずつ取る。取った石は袋に移動する。
- 袋から石を $ N $ 個取り出し、全ての皿に $ 1 $ 個ずつ石を載せる。ただし、この操作は袋に石が $ N $ 個以上ある場合にのみ行うことができる。

操作後に皿 $ i $ に載っている石の個数を $ b_i $ とします。$ b_i $ を並べてできる長さ $ N $ の整数列 $ (b_1,\ b_2,\ \dots,\ b_N) $ としてあり得るものの個数を $ 998244353 $ で割った余りを求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ a_1 $ $ a_2 $ $ \dots $ $ a_N $

## 输出格式

$ (b_1,\ b_2,\ \dots,\ b_N) $ としてあり得るものの個数を $ 998244353 $ で割った余りを出力せよ。

## 样例 #1

### 样例输入 #1

```
3
3 1 3
```

### 样例输出 #1

```
7
```

## 样例 #2

### 样例输入 #2

```
1
0
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
5
1 3 5 7 9
```

### 样例输出 #3

```
36
```

## 样例 #4

### 样例输入 #4

```
10
766294629 440423913 59187619 725560240 585990756 965580535 623321125 550925213 122410708 549392044
```

### 样例输出 #4

```
666174028
```

## 提示

### 制約

- $1\ \leq\ N\ \leq\ 2\ \times\ 10^5$
- $0\ \leq\ a_i\ \leq\ 10^9$

### Sample Explanation 1

例えば以下の手順で操作を行うと $ b $ は $ (2,\ 1,\ 2) $ になります。 - 1 番目の操作を行う。$ b $ は $ (2,\ 0,\ 2) $ になる。 - 1 番目の操作を行う。$ b $ は $ (1,\ 0,\ 1) $ になる。 - 2 番目の操作を行う。$ b $ は $ (2,\ 1,\ 2) $ になる。操作後の $ b $ としてあり得る列は次の $ 7 $ 種類です。 - $ (0,\ 0,\ 0) $ - $ (1,\ 0,\ 1) $ - $ (1,\ 1,\ 1) $ - $ (2,\ 0,\ 2) $ - $ (2,\ 1,\ 2) $ - $ (2,\ 2,\ 2) $ - $ (3,\ 1,\ 3) $

### Sample Explanation 2

操作後の $ b $ としてあり得るものは $ (0) $ の $ 1 $ 種類です。

## 题解
第一点：我们最后的总共方案数，就等于我们的可行的操作数，于是我们原本计算方案数，就等价于计算我们有多少种不等价的操作，
现在我们就可以进行我们的排序，让我们的数组从大到小的进行，然后我们可以按照我们 $k_{1}$ 进行的次数进行分类，当我们的 $k_{1}<min)a_{i}$ 时，我们 $k_{2}$ 一定只能不进行，否则就等价于我们进行了 $k_{1}-1$ 次 1 操作，有重复。

于是，我们最后的形式一定是类似于我们的 $\mathcal{A}\mathcal{A}...AB\dots.B$ 的。因此，这个时候，我们考虑枚举我们 $A$ 的次数，然后看在这个次数下，我们能进行多少次 $B$，显然，这些是不可能有重复的。
我们的难点在于我们的 $k_{1}>a_{i}$ 时我们的每一个 $k_{1}$ 对应着多少个 $k_{2}$，这里我们先计算我们的背包中的石子数量为 $s$,那么我们的 $k_{2}$ 可行方案，最多就是我们的 $\dfrac{s}{n}$ 个操作。
现在考虑怎么计算我们的石子数量 s, 我们发现，我们最后石子数量的计算可以依据我们每一次 $k_{1}++$ 后，对我们石子数量的贡献来计算，假设我们现在已经进行到了第 $a_{i}$ 个，那么我们一次 k++, 我们的结果就会添加 $n-i+1$ 个石子，此时，于是我们就可以开一个全局变量 sum，来存储我们当前的背包中的石子总数，

所以，此时我们就可以直接进行一个暴力的计算，最后的

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=2e5+7,Mod=998244353;
ll n,a[Maxn],sum,ans,res;
int main() {
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	//sum表示我们石头总数
	//ans表示的总共方案数
	//res表示我们石头数除以n的结果
	ans=a[n]+1,res=a[1];
	for(ll i=2;i<=n;i++) 
		if(a[i]>a[i-1]){
		//j表示再额外选j个，我们一共有多少石头
			for(ll j=1;j<=a[i]-a[i-1];j++) {
				sum+=n-i+1;
				if(sum>=n) sum-=n,res++;
				ans+=res;
			}
		}
	printf("%lld",ans%Mod);
}
```