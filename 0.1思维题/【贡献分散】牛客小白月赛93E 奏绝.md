你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  
  
对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 $0$。  
  
区间长度定义为左端点到右端点的距离，比如 $i$ 到 $i + 1$ 的距离为 $1$。  
  
对于 $m$ 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  $998244353$ 取模。

## 输入
第一行一个整数 $n,m$ $(1\leq n,m \leq 2\times 10^5)$。  
  
接下来一行 $01$ 序列 $c_i$ $(c_i\in\{0, 1\})$ 表示黑之章白之章的排列顺序，其中 $1$ 表示黑之章，$0$ 表示白之章。  
  
接下来 $m$ 行，每行两个整数 $l,r$ $(1\leq l\leq r\leq n)$，表示一次询问的区间。

## 输出：
$m$ 行，每行一个整数，表示对于每次询问的答案对 $998244353$ 取模。

## 题解
我们本题的一个典型的 trick 是：把我们的**区间长度贡献**转换为我们的**两点的贡献**，然后分别考虑我们的两个点的贡献是多少。**这种思路对于我们计算最大值和总和都很有帮助**。

这个时候，我们再去考虑下面的思路：我们能不能把我们的原来区间和首先，我们就有计算 $sum[i]$，表示我们的 $1-i$ 的总和是多少，对于我们的 $sum[i]$,我们就有：$sum[i]=sum[i-1]+(i'颜色个数)*i+(i'颜色下标前缀和)$

之后，我们考虑怎么取出我们的重复贡献，我们发现，我们的重复部分，就是我们的**右端点在 $[l,r]$，但是左端点在 $[0,l)$ 的这一部分**。

而我们的这一部分的计算方法，我们显然可以有：
$calc(l,r)=[1,l-1]a个数*[l,r]a'数位和$

于是，我们就可以计算出我们的代码为：
```
#include<iostream>
using namespace std;
const int N = 200010,MOD = 998244353;
typedef long long LL;
int n,m;
char g[N];
LL c0[N],c1[N],s0[N],s1[N],sum[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m >> (g + 1);
    
    for(int i = 1;i<=n;i++)
    {
        if(g[i] == '0')
        {
            c0[i] = 1;
            s0[i] = i;
        }
        else
        {
            c1[i] = 1;
            s1[i] = i;
        }
        c0[i] = (c0[i] + c0[i - 1]) % MOD;
        c1[i] = (c1[i] + c1[i - 1]) % MOD;
        s0[i] = (s0[i] + s0[i - 1]) % MOD;
        s1[i] = (s1[i] + s1[i - 1]) % MOD;
    }
    
    for(int i = 1;i<=n;i++)
    {
        if(g[i] == '0') sum[i] = (sum[i - 1] + c1[i - 1] * i - s1[i - 1]) % MOD;
        else sum[i] = (sum[i - 1] + c0[i - 1] * i - s0[i - 1]) % MOD;
    }
    
    while(m -- )
    {
        int l,r;
        cin >> l >> r;
        LL a0 = (s0[r] - s0[l - 1]) * c1[l - 1] - s1[l - 1] * (c0[r] - c0[l - 1]) % MOD;
        LL a1 = (s1[r] - s1[l - 1]) * c0[l - 1] - s0[l - 1] * (c1[r] - c1[l - 1]) % MOD;
        // 这一步可能会变为负数
        cout << ((sum[r] - sum[l - 1] - a0 - a1) % MOD + MOD) % MOD << endl;
        
    }    
    return 0;
}
```