https://ac.nowcoder.com/acm/contest/90072/C
题目描述
tb 给了 fc 一张包含 n*n个格点的图。
图上每个格点上都写着一个数，第i行第j列的格点上写着的数字为i和j的最大公约数 (GCD)。

fc 需要从第1行第1列出发，去往第n行第n列处的格点，且 fc 可以通过以下两种方式进行移动：

1. 相邻格点移动：fc 每次可以消耗 1 点能量，移动到相邻的格点。相邻的格点包括：
    - (x+1, y) 下方的格点
    - (x-1, y) 上方的格点
    - (x, y+1) 右边的格点
    - (x, y-1) 左边的格点
2. 传送阵：如果 fc 所在格点的数字  x  不为 1，fc 可以传送到任何数字为  x 的格点，且此操作不消耗能量。
 问题目标
求 fc 到达第 n 行第 n 列所消耗的最少能量。
 输入描述
- 一个正整数 n，表示图的大小 n*n （1 ≤n≤ 10^6）。
 输出描述
- 一个非负整数，表示到达目标所需的最少能量。
 示例
 输入
```
2
```
 输出
```
2
```
额外信息

相邻：如果用 \((x, y)\) 表示第 \( x \) 行第 \( y \) 列的位置，\((x, y)\) 与 \((x+1, y)\)、\((x, y+1)\)、\((x-1, y)\)、\((x, y-1)\) 相邻。

题解：
找规律，把地图打出来很快就能发现规律。一直使用‘2’这个传送点即可。



int main()
{
    ll k,n;
    cin>>n;
    if(n==1){
        cout<<0;
    }else if(n==2){
        cout<<2;
    }else if(n==3){
        cout<<4;
    }else if(n%2==0){
        cout<<4;
    }else{
        cout<<6;
    }
    return 0;
}
