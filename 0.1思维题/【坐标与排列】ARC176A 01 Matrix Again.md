# [ARC 176 A] 01 Matrix Again

## 题面翻译

给定一个 $N \times N$ 的矩阵，你需要向其中填入 $0$ 或 $1$，使其满足以下条件：

- $(A_1,B_1),(A_2,B_2),...,(A_M,B_M)$ 处的值为 $1$。
- 第 $i$ 行的所有数字之和为 $M$ $(1 \le i \le N)$。
- 第 $i$ 列的所有数字之和为 $M$ $(1 \le i \le N)$。

#### 输入格式
第一行有两个整数 $N$ 和 $M$。

接下来有 $M$ 行，第 $i+1$ 行有两个整数 $A_i$ 和 $B_i$。

#### 输出格式
第一行输出矩阵中 $1$ 的个数 $k$。

接下来有 $k$ 行，第 $i+1$ 行输出两个整数 $x_i$ 和 $y_i$，表示 $(x_i,y_i)$ 处的值为 $1$。（顺序任意）

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc176/tasks/arc176_a

$ N\ \times\ N $ のマス目があります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i, j) $ と呼びます。

これから各マスに $ 0 $ か $ 1 $ を書き込みます。以下の条件を全て満たすように書き込む方法を一つ構築してください。

- $ M $ 個のマス $ (A_1, B_1), (A_2, B_2),\dots, (A_M, B_M) $ には $ 1 $ が書かれている。
- $ i $ 行目のマスに書かれた整数の総和は $ M $ である。$ (1\ \le\ i\ \le\ N) $
- $ i $ 列目のマスに書かれた整数の総和は $ M $ である。$ (1\ \le\ i\ \le\ N) $
 
本問題の制約下で、条件を満たす書き込み方が存在することが証明出来ます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ A_1 $ $ B_1 $ $ A_2 $ $ B_2 $ $ \vdots $ $ A_{M} $ $ B_{M} $

## 输出格式

$ 1 $ を書き込むマスをマス $ (x_1, y_1), (x_2, y_2),\dots, (x_k, y_k) $ としたとき、以下のように出力せよ。

> $ k $ $ x_1 $ $ y_1 $ $ x_2 $ $ y_2 $ $ \vdots $ $ x_k $ $ y_k $

なお、条件を満たす書き込み方が複数存在する場合その中のどれを出力しても正答となる。

## 样例 #1

### 样例输入 #1

```
4 2
1 4
3 2
```

### 样例输出 #1

```
8
1 2
1 4
2 1
2 4
3 2
3 3
4 1
4 3
```

## 样例 #2

### 样例输入 #2

```
3 3
3 1
2 3
1 3
```

### 样例输出 #2

```
9
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

## 样例 #3

### 样例输入 #3

```
7 3
1 7
7 6
6 1
```

### 样例输出 #3

```
21
1 6
2 4
4 1
7 3
3 6
4 5
6 1
1 7
7 6
3 5
2 2
6 3
6 7
5 4
5 2
2 5
5 3
1 4
7 1
4 7
3 2
```

## 提示

### 制約

- $ 1\ \le\ N\ \le\ 10^5 $
- $ 1\ \le\ M\ \le\ \min (N, 10) $
- $ 1\ \le\ A_i, B_i\ \le\ N $
- $ i\ \neq\ j $ ならば $ (A_i, B_i)\ \neq\ (A_j, B_j) $
 
### Sample Explanation 1

この出力では、マス目に以下のように整数を書き込んでいます。全ての条件を満たしているので、この出力は正答です。 ``` 0101 1001 0110 1010 ```

## 题解
我们首先不考虑我们的约束条件，我们只考虑下面的问题：给你一个 $N\times N$ 的矩阵，要求你给出一种构造方法，使得我们的每一行的和都为 $M$,每一列的和都为 $M$。

这个时候，我们注意到，我们最后的每一个和之间是没有冲突的，也就是说，我们每一次，只需要构造一个排列即可，这个排列需要满足和上一次的数字都**完全不同**。那么我们要求和为 $M$,那么我们就需要构造出 $M$ 个**完全不同的排列**。

这个时候，我们考虑这样去构造我们的**排列**，我们对于每一个元素，我们首先去构造 $1,2,\dots n$，然后我们再去构造 $2,3,\dots,n,1$。就这样，我们用一种**循环左移**的方法来构造，可以构造出 $N$ 个完全不同的排列。
**并且，我们还能够对我们的每一个排列进行标识：我们的标识可以用 $a[1]-1$**。

考虑到我们的原题中的限制要求：我们就可以把我们的原来的限制转换为:
```
#include <bits/stdc++.h>
using namespace std;
int main(){
  ll n,m;
  cin>>n>>m;
  vector<ll> b(n);
  for(int i=0;i<m;i++){
    ll x,y;
    cin>>x>>y;
    x--;
    y--;
    b[(x+y)%n]++;
  }
  vector<ll> c;
  for(int i=0;i<n;i++) if(b[i]) c.pb(i);
  for(int i=0;i<n;i++) if(b[i]==0&&c.size()<m) c.pb(i);
  cout<<n*m<<endl;
  for(int i=0;i<m;i++){
    for(int j=0;j<n;j++){
      ll x=j,y=(c[i]-j+n)%n;
      cout<<x+1<<" "<<y+1<<endl;
    }
  }
}
```