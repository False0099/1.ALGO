## 题目背景

Softmax($Q$ × $\frac{K^{T}}{\sqrt{ d }}$)×V 是 Transformer 中注意力模块的核心算式，其中 Q、K 和 V 均是 N 行 D 列的矩阵，

## 问题描述

为了方便计算，顿顿同学将 Softmax 简化为了点乘一个大小为 � 的一维向量 W：  
(W⋅(Q×K))×V  
点乘即对应位相乘，记 W(I) 为向量 W 的第 I 个元素，即将 (Q×KT) 第 I 行中的每个元素都与 W(I) 相乘。

现给出矩阵 Q、K 和 V 和向量 W，试计算顿顿按简化的算式计算的结果。

## 输入格式

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 N 和 D，表示矩阵的大小。

接下来依次输入矩阵 Q、K 和 V。每个矩阵输入 N 行，每行包含空格分隔的 D 个整数，其中第 I 行的第 J 个数对应矩阵的第 I 行、第 J 列。

最后一行输入 N 个整数，表示向量 W。

## 输出格式

输出到标准输出中。

输出共 N 行，每行包含空格分隔的 D 个整数，表示计算的结果。

## 样例输入

```data
3 2
1 2
3 4
5 6
10 10
-20 -20
30 30
6 5
4 3
2 1
4 0 -5
```

Data

## 样例输出

```data
480 240
0 0
-2200 -1100
```

Data

## 子任务

70 的测试数据满足：N≤100 且 D≤10；输入矩阵、向量中的元素均为整数，且绝对值均不超过 30。

全部的测试数据满足：N≤104 且 D≤20；输入矩阵、向量中的元素均为整数，且绝对值均不超过 1000。

## 提示

请谨慎评估矩阵乘法运算后的数值范围，并使用适当数据类型存储矩阵中的整数。

## 题解
对于 $70$ 的数据，我们只需要运用矩阵乘法的定义，直接计算即可。
```cpp
for(int i=0;i<=n;i++){
	for(int j=0;j<=n;j++){
		for(int k=0;k<=w;k++){
			c[i][j]+=a[i][k]*b[k][j];
		}
	}
}
```

但当我们的 n 较大时，我们注意到，我们的**空间会不足**，因此我们需要进行一下**空间优化**。注意到我们的某个中间结果 n* n 是在我们的 long long 返回内的，因此我们可以依次来**优化我们的中间结果**。

另外，我们可以采用我们的矩阵结合律，**先去成我们的后两个矩阵，依次来优化我们的时间复杂度**


```cpp
#include<bits/stdc++.h>
using namespace std;
 
int main(){
	int n, d;
	cin>>n>>d;
	//输入 
	map<int, map<int, int> > Q, K, V, W;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=d;j++)
	        cin>>Q[i][j];
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=d;j++)
	        cin>>K[j][i];
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=d;j++)
	        cin>>V[i][j];
	for(int i=1;i<=n;i++)
	    cin>>W[1][i];
	    
	//V*K
	map<long long, map<long long, long long> > ans;
	for(int i=1;i<=d;i++){
		for(int j=1;j<=d;j++){
			int x=0;
			for(int k=1;k<=n;k++) x+=K[i][k]*V[k][j];
			ans[i][j] = x;
		}
	}
	//Q*ans
	for(int i=1;i<=n;i++){
		for(int j=1;j<=d;j++){
			long long x=0;
			for(int k=1;k<=d;k++) x+=Q[i][k]*ans[k][j];
			x*=W[1][i];
			cout<<x<<' ';
		}
		cout<<endl;
	}
}
```

本题如果**数据非常大的条件下**可以转化为我们的**区间 D**P，因为我们的相乘顺序可以任意加括号，也是我们**区间 dp** 的套路之一。