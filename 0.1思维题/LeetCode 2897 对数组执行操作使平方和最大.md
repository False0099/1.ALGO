给你一个下标从 **0** 开始的整数数组 `nums` 和一个 **正** 整数 `k` 。

你可以对数组执行以下操作 **任意次** ：

- 选择两个互不相同的下标 `i` 和 `j` ，**同时** 将 `nums[i]` 更新为 `(nums[i] AND nums[j])` 且将 `nums[j]` 更新为 `(nums[i] OR nums[j])` ，`OR` 表示按位 **或** 运算，`AND` 表示按位 **与** 运算。

你需要从最终的数组里选择 `k` 个元素，并计算它们的 **平方** 之和。

请你返回你可以得到的 **最大** 平方和。

由于答案可能会很大，将答案对 `109 + 7` **取余** 后返回。

**示例 1：**

**输入：**nums = [2,6,5,8], k = 2
**输出：**261
**解释：**我们可以对数组执行以下操作：
- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。
- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。
从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。
261 是可以得到的最大结果。

**示例 2：**

**输入：**nums = [4,5,4,7], k = 3
**输出：**90
**解释：**不需要执行任何操作。
选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。
90 是可以得到的最大结果。

**提示：**

- `1 <= k <= nums.length <= 105`
- `1 <= nums[i] <= 109`

## 题解
我们本题，首先要统计我们每一个数位上有多少个一，然后我们每一次都尽可能多的选择 1，最后我们每一次的选择平方后取答案即可
例如：我们样例 2658，我们的二进制尾数和就分别是：1221，于是我们就可以构造出：1111 和 0110 两个数字，这个就是我们的答案。
```cpp
class Solution {
public:
    int maxSum(vector<int> &nums, int k) {
        const int MOD = 1'000'000'007;
        int cnt[30]{};
        for (int x: nums) {
            for (int i = 0; i < 30; i++) {
                cnt[i] += (x >> i) & 1;
            }
        }
        long long ans = 0;
        while (k--) {
            int x = 0;
            for (int i = 0; i < 30; i++) {
                if (cnt[i] > 0) {
                    cnt[i]--;
                    x |= 1 << i;
                }
            }
            ans = (ans + (long long) x * x) % MOD;
        }
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```