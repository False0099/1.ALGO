> $\sf Take\ that\ money,\ and\ watch\ it\ burn$
> 
>   
> 
> $\sf Sink\ in\ the\ river,\ the\ lessons\ I’ve\ learned$
> 
>   
> 
>        —— $Counting\ Stars,\ \text{OneRepublic}$

_氧气少年_有 $n$ 枚硬币，他将这 $n$ 枚硬币**围成一圈**，初始时所有硬币均为正面向上。

  
你每次可以进行下面的操作：  

-   选择连续的 $k$ 枚硬币，将它们翻转一次。即：对于这 $k$ 枚硬币中的每一枚硬币，如果该硬币目前正面向上，那它在操作后将变为反面向上，否则变为正面向上。

  
请判断能否经有限次操作使得所有硬币反面向上。如果能，请求出操作方案。

## 输入
第一行包含一个整数 $T(1\leq T\leq 2\cdot 10^5)$，表示测试用例的组数。  
  
对于每组测试用例：  
  
仅输入一行，包含两个整数 $n(1\leq n\leq 2\cdot 10^5),k(1\leq k\leq n)$。  
  
保证对于所有测试用例，$n$ 的总和不超过 $2\cdot 10^5$。

## 输出
对于每组测试用例：  
  
如果不能经有限次操作使得所有硬币反面向上，那么输出 $-1$。  
  
否则，第一行输出一个整数 $m(0\leq m\leq 2\cdot n)$，表示操作的次数。  
第二行包含 $m$ 个整数，第 $i$ 个整数 $p_i(1\leq p_i\leq n)$ 表示第 $i$ 次操作选择的连续 $k$ 枚硬币中，第一枚硬币的位置。  
  
可以证明，如果能经有限次操作使得所有硬币反面向上，那么一定有至少一种方案满足 $m\leq 2\cdot n$。  
请注意，你无需最小化操作次数。  
如果有多个可行的答案，请输出任意一个。

## 题解
首先，我们可以把我们的硬币反转，当作是区间异或 1，于是我们的原本的硬币反转问题就转变为了我们的下面的问题：给定你一个长为 $n$ 的循环队列，你可以选择一个长为 $k$ 的连续段异或一，问我们是否存在一种方案让我们的最后异或起来为 0. 

对于这一类问题，我们现在考虑一种思路：我们把我们的每一次选择连续长度为 $k$ 的连续异或段当成是我们的一个异或基，我们有 $n$ 个可能的操作，也就有 $n$ 个线性基。我们看我们能不能从我们的初始状态转换到我们的结尾状态，也就是看我们是否存在一种线性基的组合方式，能够构成我们的**结尾态异或上我们的初始态**。

我们可以构造出下面的一个异或方程组：
![[Pasted image 20240408150040.png]]

那么，我们如果扩展到我们的 $S$ 和 $P$ 任意给定的情况，都可以采用上面的方法来解决。我们现在就转变为有 $n$ 个未知数，$n$ 个变量的方程组。而这种情况下，我们想要求解我们是否存在可行解，需要的时间复杂度为 $o(n^3)$。显然对于本题来说是复杂了很多的。

但是，我们本题由于存在我们的特殊性质，也就是我们的每一个方程的右侧都一定是 1。
因此，如果我们右侧未知数对应的 $k$ 为奇数，我们一定可以构造一种方案，就是我们同时按 $n$ 次我们的长度就可以达到我们的要求。因为这么做，我们左侧的 op 一定出现的是奇数次，一定是等于我们的 1 的。

除此之外，我们考虑我们的 $k$ 为偶数的情况，首先，我们不难发现，我们如果 $k$ 为偶数的话，我们构造出来的操作应该满足：“相邻”的 k 个操作中，有且仅有奇数个被选中。于是我们现在就已经转换为了一道构造题。要求我们构造一个 01 序列，要求满足任意长度为 $k$ 的区间，区间异或结果都为 1.

如果我们的 k 是奇数，那么我们一定有解，我们每个位置都赋值为 1 即可，如果我们的 $\dfrac{k}{gcd(n,k)}$ 是偶数，那么我们无解，否则有解。如果有解，每段区间左端点间隔 $gcd(n,k)$ 即可

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1000005
#define MAXM 505
#define PII pair<int,int>
#define INF 1e18
#define MOD 1000000007
#define mod 998244353
int n,T,m,k,aa[MAXN];
string s;
void solve(){
    cin >> n >> m;
    int lc = n * m / __gcd(n , m);
    int x = lc / n;
    int num = lc / m;
    
    
    if(x % 2 == 1){
        cout << num << "\n";
        for(int i = 1; i <= num; i ++){
            int temp = (i - 1) * m;
            temp %= n;
            temp += 1;
            cout << temp << " ";
        }
        cout << "\n";
    }
    else{
        cout << -1 << "\n";
    }
    
    
}


signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> T;
	while(T--)solve();
	return 0;
}     
```