# 硬币翻转

## 题目描述

在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。

## 输入格式

一个自然数 $N$（$N$ 为不大于 $100$ 的偶数）。

## 输出格式

第一行包含一个整数 $S$，表示最少需要的操作次数。

接下来的 $S$ 行每行分别表示每次操作后桌上硬币的状态（一行包含 $N$ 个整数 $0$ 或 $1$，表示每个硬币的状态，$0$ 表示正面向上，$1$ 表示反面向上。不允许输出多余空格。

对于有多种操作方案的情况，则只需**操作的字典序**最小输出一种。

操作的字典序是指，对于一次操作中的每个位置，$1$ 表示翻转，$0$ 表示不反转。

但是需要你输出的是每一次操作完的状态，$0$ 表示正面朝上，$1$ 表示反面朝上。

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
4
0111
1100
0001
1111
```

## 题解
首先，我们本题属于我们的 [[长期项目/1.算法题目/0.1思维题/01串/【区间异或】牛客练习赛117 Kevin翻硬币]]的真子集，我们本题和上一题相比增加了两个限制：1. 我们的数字 $n=1$,2. 我们异或的次数 $k=n-1$。

这一题，我们的目标就是去证明我们的最后的操作次数就是我们的 $n$,我们的证明如下：我们考虑我们的等价问题，我们注意到，我们**每一次都反转 $n-1$ 个和我们每一次都反转 1 个，最后的操作是相同的**，所以，我们最后只需要按照我们的跪地那个要求来直接计算出我们的方案数是多少即可。

```
#include<iostream>
using namespace std;
const int maxn=101;
bool a[maxn];//a数组负责存储硬币的状态
int n;//n枚硬币
int main()
{
    cin>>n;
    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可
    for(int i=1;i<=n;i++){//i表示这是第几次翻
        for(int j=1;j<=n;j++){//表示当前翻得是第几枚硬币
            if(j!=i){//如果不为第i枚
                if(a[j])a[j]=0;//1变成0
                else a[j]=1;//0变成1
            }
            cout<<a[j];//输出当前状态
        }
        cout<<endl;//别忘了换行
    }
    return 0;
}
```