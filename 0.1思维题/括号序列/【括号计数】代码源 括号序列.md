#### 题目描述

合法括号序列的定义是：

1.空序列是合法括号序列。

2.如果S是合法括号序列，那么(S)是合法括号序列。

3.如果A和B都是合法括号序列，那么AB是合法括号序列。

现在有一个括号序列，现在要计算一下它有多少非空子段是合法括号序列。

PS: 为了方便给出了5个样例， 但是丢在一个框框里

#### 输入描述

一个字符串S

#### 输出描述

有多少个非空子段是合法括号序列

#### 输入样例

```
(
()
()()
(()
(())
```

#### 输出样例

```
0
1
3
1
2
```

#### 数据范围

1≤|S|≤106

## 题解
对于一个合法序列，右括号一定只能和一个左括号匹配，并且对应右括号匹配哪一个左括号，我们可以通过我们的栈来计算得出：
```cpp
for (int i = 1; i <= n; i++) {
    if (s[i] == '(')stk.push(i);
    else {
        if (stk.size()) {
            pos[i] = stk.top();
            stk.pop();
        }
    }
}
```

接下来，我们就可以定义我们的 $dp[i]$ 为，$s[i]$ 为右括号作为结尾的情况下，合法子串的个数。而我们又知道，哦我们的 $pos[i],i$ 是一个合法的子串，这个时候我们就需要看看我们的 $dp[pos[i]-1]$ 的值是多少了
所以我们有 $dp[i]=dp[pos[i]-1]+1$

```cpp
void slove() {
    cin >> tmp; s = "?" + tmp;//下标从1开始
    n = tmp.length();
    for (int i = 1; i <= n; i++) {
        if (s[i] == '(')stk.push(i);
        else {
            if (stk.size()) {
                pos[i] = stk.top();
                stk.pop();
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (pos[i]) {
            dp[i] = dp[pos[i] - 1] + 1;
            ans += dp[i];
        }
    }
    cout << ans << endl;
}
```