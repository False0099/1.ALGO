# [CSP-S 2023] 消消乐

## 题目描述

小 L 现在在玩一个低配版本的消消乐，该版本的游戏是一维的，一次也只能消除两个相邻的元素。

现在，他有一个长度为 $n$ 且仅由小写字母构成的字符串。我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，使之成为一个空字符串。

其中每次操作可以从字符串中删除两个相邻的相同字符，操作后剩余字符串会拼接在一起。

小 L 想知道，这个字符串的所有非空连续子串中，有多少个是可消除的。

## 输入格式

输入的第一行包含一个正整数 $n$，表示字符串的长度。

输入的第二行包含一个长度为 $n$ 且仅由小写字母构成的的字符串，表示题目中询问的字符串。

## 输出格式

输出一行包含一个整数，表示题目询问的答案。

## 样例 #1

### 样例输入 #1

```
8
accabccb
```

### 样例输出 #1

```
5
```

## 提示

**【样例 1 解释】**

一共有 $5$ 个可消除的连续子串，分别是 `cc`、`acca`、`cc`、`bccb`、`accabccb`。

**【样例 2】**

见选手目录下的 `game/game2.in` 与 `game/game2.ans`。

**【样例 3】**

见选手目录下的 `game/game3.in` 与 `game/game3.ans`。

**【样例 4】**

见选手目录下的 `game/game4.in` 与 `game/game4.ans`。

**【数据范围】**

对于所有测试数据有：$1 \le n \le 2 \times 10^6$，且询问的字符串仅由小写字母构成。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $10$ | 无 |
| $6\sim 7$ | $800$ | 无 |
| $8\sim 10$ | $8000$ | 无 |
| $11\sim 12$ | $2\times 10^5$ | A |
| $13\sim 14$ | $2\times 10^5$ | B |
| $15\sim 17$ | $2\times 10^5$ | 无 |
| $18\sim 20$ | $2\times 10^6$ | 无 |

特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。

特殊性质 B：字符串仅由 `a` 和 `b` 构成。

## 题解
本题类似于我们的 [[长期项目/1.算法题目/0.1思维题/括号序列/【括号计数,dp优化】洛谷P10115 Placer]]，我们需要通过我们的括号匹配相关性质来优化我们的 dp。

首先，我们可以列出来一个肥肠暴力的 dp 方程：$dp[i]=\sum[i,j] \cap dp[j]$,其中我们的含义是以 $i$ 结尾的合法字符串的长度是多少，显然，我们一个合法字符串可以由其他的合法字符串转移过来。

这里，我们的优化的点在于，如果我们能够快速的求出我们的每一个 $j$ 是多少，减少我们的枚举范围，我们就能够做到一个**均摊优化**。

考虑到，如果我们的 $i，j$ 匹配，那么我们考虑先求出我们的 $last[i]$ 表示我们的 i 的前一个匹配字符是什么，然后我们我们的转移就可以有：
$dp[i]=dp[last[i]-1]+1$。最后，我们对我们的 $dp$ 求和就能得到我们的答案。

而我们要怎么样求出我们的**last**数组，我们的 $last$ 数组转换为我们的人话就是：我们**与 i 对应**的**最靠右的**，**符合要求的**位置。由于 $g_i$ 是满足条件中最大的，因此必有 $s_i=s_{g_i}$,我们就可以按下图的方式从 $i$ 往前跳，初始时 $g_i=$ $i-1$, 之后不断令 $g_i\to g_{g_i}-1$, 直到满足 $s_i=s_{g_i}$ 。
![[Pasted image 20240424193350.png]]

但是我们这么做时间复杂度是 $o(n^2)$ 的，显然不可行，于是我们考虑优化：

我们注意到，我们每一次查找我们的可能的 $last[i]$ 的过程中，如果我们每一次都只是往前跳 1 个，显然是浪费了，我们最好的跳法显然是跳到我们的上一个和当前字符匹配的位置然后再向前走一个得到的位置。
![[Pasted image 20240424193510.png]]


```cpp
#include <iostream>
using namespace std;
const int N=5e6+10;
typedef long long ll;
ll n,a[N],p[N],c[N],dp[N];
char s[N];
int main(){
    scanf("%lld",&n);
    scanf("%s",s+1);
    //for(int i=1;i<=n;i++)scanf("%lld",a+i);
    for(int i=1;i<=n;i++){
    	for(int j=i-1;j>0;j=p[j]-1){
    		if(s[i]==s[j]){
    			p[i]=j;
    			break;	
			}
		}
	}
	ll ans=0;
    for(int i=1;i<=n;i++){
        if(p[i]){
            c[i]=(c[p[i]-1]+1);
            ans+=c[i];
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```