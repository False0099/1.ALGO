# [LMXOI Round 1] Placer

## 题目背景

LMX 最近迷上了括号序列，她尤其钟爱合法括号序列。

LMX 为了检验 HQZ 的真诚，于是她出一道题准备考验下 HQZ。

## 题目描述

LMX 给出了一个长度为 $n$ 括号序列 $S$，以及一个长度为 $n$ 的序列 $a_i$。

定义 $w (l, r)=\begin{cases}a_r-a_l, & S_{l..r} \text{为合法括号序列}\\\ 0 & \text{otherwise}\end{cases}$

你可以将序列分成若干非空子段，定义整个序列的美丽度为每段的 $w(l , r)$ 之和。

求美丽度最大为多少。

## 输入格式

第一行一个整数 $n$。

第二行一个字符串，代表括号序列。

第三行代表序列 $a$。

## 输出格式

第一行一个整数，表示最大的美丽度。

## 样例 #1

### 样例输入 #1

```
5
()(()
1 3 2 3 5
```

### 样例输出 #1

```
4
```

## 样例 #2

### 样例输入 #2

```
10
()((())())
2 4 1 7 3 2 8 4 9 5
```

### 样例输出 #2

```
8
```

## 提示

**样例解释 #1 **

原串可以划分成三个区间：$[1,2],[3,3],[4,5]$。贡献为 $(a_2-a_1)+0+(a_5-a_4)=(3-1)+0+(5-3)=4$

| 子任务编号 | $n$ | 特殊性质 | 分值 |
| :--------: | :--------: | :-------------: | :--: |
| Subtask #1 | $\le 5000$ | 无 | $30$ |
| Subtask #2 | $\le 10 ^ 5$ | 无 | $20$ |
| Subtask #3 | $\le 3 \times 10 ^ 6$ | 括号序列为 $()()\dots()$ | $15$ |
| Subtask #4 | $\le 3 \times 10 ^ 6$ | 无 | $35$ |

对于 $100\%$ 的数据，$1\le a_i \le 10^9$。

## 题解
首先，我们看到要求我们在括号匹配的前提下求我们的最值，我们不难想到，我们可以 $o(n)$ 的预处理出每一个右括号对应匹配的位置是什么。然后我们每一次计算权值的时候，只需要枚举我们的右端点，然后再计算这个右端点与这个右端点之前的那个点的贡献是多少，就可以完成我们的计算。

因此，我们可以设 $dp[i]$ 表示我们 $1-i$ 这一段对于我们答案的最大贡献是多少，显然，如果我们的 $i$ 是一个右括号，或者我们这一个位置不匹配，那么我们就有 $dp[i]=dp[i-1]$,如果我们这一个位置匹配了，那么我们就有 $dp[i]=max(dp[i],dp[j]+calc(j,last_{i}))$,其中我们的 $j$ 满足我们的 $(i,j)$ 这一段是完全匹配的。

其中，我们的 $j$ 可以通过我们的栈预处理得到。

综上，我们可以 $o(n^2)$ 的完成我们的 DP。考虑其他优化方法，发现，我们可以把我们的 $dp[j]+calc(j,i)$ 转换为：$dp[j]+a_{i}-a_{j+1}$,于是，我们分离不同的字母，就有 $c_{j}=dp[j]-a_{j+1}$, $a_i$ 两种，之后，我们考虑怎么能够快速的转移出我们的 $max(c_j)$,这里由于我们的 $S_{pre,j}$ 合法，那么我们的 $S_{i,j}$ 也一定合法，所以我们就可以有：

$$
c_i=\begin{cases}\max(c_{pre_i-1},dp_{pre_{i-1}}-a_{pre_i})&pre_i\neq0\\-a_{i+1}&\text{其他情况}\end{cases}
$$

我们预处理出我们的 $c_i$ 之后，再去处理我们的 $dp$ 数组即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e6+10;
typedef long long ll;
ll n,a[N],p[N],c[N],dp[N];
char s[N];
int main(){
    scanf("%lld",&n);
    scanf("%s",s+1);
    for(int i=1;i<=n;i++)scanf("%lld",a+i);
    stack<int> stk;
	for(int i=1;i<=n;i++){
        if(s[i]=='('){
        	stk.push(i);
		}else{
			if(stk.size()){
				p[i]=stk.top();
				stk.pop(); 
			}
		}
	}
    c[0]=-a[1];
    for(int i=1;i<=n;i++){
        dp[i]=dp[i-1];
        if(p[i]){
            c[i]=max(c[p[i]-1],dp[p[i]-1]-a[p[i]]);
            dp[i]=max(dp[i],a[i]+c[i]);
        }else c[i]=-a[i+1];
    }
    printf("%lld\n",dp[n]);
    return 0;
}

```
