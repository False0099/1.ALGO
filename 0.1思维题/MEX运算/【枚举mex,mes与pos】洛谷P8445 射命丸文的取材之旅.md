# 射命丸文的取材之旅

## 题目背景

射命丸文（Syameimaru Aya）是一只鸦天狗。她不定期制作名为「文文。新闻」的报纸，而为此，她需要对她收集到的新闻进行剪裁。

## 题目描述

射命丸文现在收集到了 $2n$ 条新闻。她想要将其刊登于自己的报刊之上。然而，自己的报刊最多只能刊登 $n$ 条新闻。

为了能在 $n$ 条新闻的篇幅中让自己的报刊得到最大的吸引力，她将这 $2n$ 条新闻**等分**成**两份**，即每一份中均有 $n$ 条新闻。

每一条新闻自然有着其吸引力。在**第一份**中，第 $i$ 条新闻有着吸引力 $a_i$，而在**第二份**中，第 $i$ 条新闻有着吸引力 $b_i$。这两份新闻的划分在输入时已经给定。

现在射命丸文要从中选取新闻放入自己的报刊。报刊上的第 $i$ 条新闻，将选择**第一份**新闻的第 $i$ 条或**第二份**新闻的第 $i$ 条。这样，报刊上的新闻就可以构成一个长度为 $n$ 的序列，第 $i$ 项也就是第 $i$ 条新闻有着吸引力 $c_i \in \{a_i,b_i\}$。

而这样的一份报刊有着其综合影响力。根据射命丸文的经验，对于她这样的一份含有 $n$ 条新闻的报刊，其综合影响力为：

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

其中 $\operatorname{mex}\{c_l,c_{l+1},\dots,c_{r-1},c_r\}$ 指的是 $c_l,c_{l+1},\dots,c_{r-1},c_r$ 中没有出现过的**最小非负整数**。

现在她希望知道，在进行这些操作之后，自己的报刊的**最大**的综合影响力会是多少呢？由于她还要继续取材，因此她把这个任务交付给了你。

【形式化题意】

给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

## 输入格式

第一行一个正整数 $n$，表示**每一份**新闻中的新闻条数。

第二行 $n$ 个**非负整数**表示第一份新闻中每一条新闻的吸引力，即 $a_1,a_2\dots ,a_{n-1},a_n$。

第三行 $n$ 个**非负整数**表示第二份新闻中每一条新闻的吸引力，即 $b_1,b_2\dots ,b_{n-1},b_n$。

## 输出格式

输出一个整数，表示报刊的**最大**的综合影响力会是多少。

## 样例 #1

### 样例输入 #1

```
5
0 1 0 1 2
0 2 0 1 0
```

### 样例输出 #1

```
3
```

## 提示

**【样例解释和说明】**

射命丸文可以让自己的 $5$ 条新闻分别取第二份的第 $1$ 条，第一份的第 $2$ 条，第一份的第 $3$ 条，第一份的第 $4$ 条和第二份的第 $5$ 条。这样一来，她的报刊每条新闻的吸引力 $c_i$ 分别为 $0,1,0,1,0$。令 $l=1,r=5$，则 $\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=2$，$r-l+1-\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=3$，不难证明其为数列 $c$ 的综合影响力，也是**所有的可能的** $c$ 的最大综合影响力。

**【数据范围】**

对于 $20\%$ 的数据，满足 $1 \leq n\leq 10$。

另外 $40\%$ 的数据满足 $a_i=b_i$。

对于 $100\%$ 的数据，满足 $1 \leq n\le 10^6$，$0
\leq a_i, b_i\leq n$。

## 题解
我们本题的优化的点首先不在于我们的枚举区间，这样做一定是超市的，我们考虑能否枚举我们的 $mex$ 是多少，如果枚举出了我们的 $mex$,然后我们再去扩展出这一个 $mex$ 对应的最大区间长度是多少。

首先，我们不难发现，如果我们在一个子区间内没有 $a[i]=b[i]=x$ 的情况出现，那么我们这一个区间的 $mex$ 值一定是小于我们的 $x$ 的。

因此，我们可以把 $a[i]=b[i]=x$ 的点看成一个针对于 x 的屏障，我们每一次能够扩展的最大长度，我们就暂时限定为只能扩展屏障内的长度，但是我们有一个问题，这个答案是正确的吗？

答案是肯定的，因为如果我们有一个更优的，那么他一定会在我们的 $mex$ 小于我们的 x 的时候被更新。所以我们这么做一定能够得到最优答案。

但是要注意，我们求出的只是全局答案，而不是我们某一个数字对应的真正答案。
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
using namespace std;

int n,a[N],ans=-1e9;
vector<int> pos[N];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1,b;i<=n;i++){
		b=read();
		if(b==a[i])pos[b].push_back(i); //记录x=b时的屏障的位置
	}
	for(int i=0;i<=n;i++){
		pos[i].push_back(n+1); //对所有的x在区间末尾加一个屏障，方便计算
		for(int j=0,before=1;j<pos[i].size();j++){
			ans=max(ans,pos[i][j]-before-i);
			before=pos[i][j]+1;
		}
	}
	cout<<ans;
	return 0;
}
```