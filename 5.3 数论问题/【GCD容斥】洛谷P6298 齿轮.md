# 齿轮

## 题目描述

Daniel 13265 从不知哪里找来了 $n$ 个齿轮，第 $i$ 个齿轮的齿数为不超过 $m$ 的正整数 $a_i$。他现在想把其中 $k$ 个齿轮按照一定的方式拼接在一起。

当齿轮使用一段时间后，就会产生损耗。一个齿轮组的损耗速率是由这个齿轮组的所有齿轮齿数的最大公约数决定的：最大公约数越大，相同的齿之间啮合的频率就会增高，从而损耗的速率就会变快。这个最大公约数又被称为损耗因子。

算出一个齿轮组的损耗因子是很容易的。可是现在 Daniel 13265 想要知道，对于可能拼接出的所有齿轮组的损耗因子。

Daniel 13265 知道拼接出损耗因子大于 $m$ 的齿轮组是不可能的，而且由于可能拼出的齿轮组的个数很多，你只需要反过来告诉他对于所有的 $t\in[1, m]$，能够拼接出的损耗因子为 $t$ 的齿轮组的个数对 $10^9+7$ 取模后的结果即可。

## 输入格式

输入共 $2$ 行。
  
第一行包含三个正整数 $n,m,k$，分别表示 Daniel 13265 拥有的齿轮个数，齿轮齿数的最大可能值与 Daniel 13265 期望的齿轮组的齿轮个数。  
第二行共 $n$ 个用单个空格隔开的正整数，第 $i$ 个数 $a_i$ 表示第 $i$ 个齿轮的齿数。

## 输出格式

输出一行 $m$ 个整数，第 $t$ 个数表示能够拼接出的损耗因子为 $t$ 的齿轮组的个数对 $10^9+7$ 取模后的结果。

## 样例 #1

### 样例输入 #1

```
5 6 2
1 2 3 4 6
```

### 样例输出 #1

```
6 3 1 0 0 0
```

## 提示

### 样例解释

损耗因子为 $1$ 的齿轮组有 $(1,2),(1,3),(1,4),(1,6),(2,3),(3,4)$ 共 $6$ 个；  
损耗因子为 $2$ 的齿轮组有 $(2,4),(2,6),(4,6)$ 共 $3$ 个；  
损耗因子为 $3$ 的齿轮组有 $(3,6)$ 共 $1$ 个。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^6$ | $10$ | $10$ |
| $2$ | $10^3$ | $10^3$ | $10^3$ | $20$ |
| $3$ | $10^6$ | $10^3$ | $2$ | $5$ |
| $4$ | $10^6$ | $10^6$ | $1$ | $5$ |
| $5$ | $10^6$ | $10^6$ | $2$ | $20$ |
| $6$ | $10^6$ | $10^6$ | $10^6$ | $40$ |

对于 $100\%$ 的数据，满足 $1\le k\le n\le10^6$，$1\le a_i\le m\le10^6$。

## 题解
我们本题如果直接表示我们的 $g[i]$ 表示我们 gcd 恰好为 $i$ 的方案，那么我们是很难计算的，但是，我们考虑换一个角度，如果我们用我们的 $g[i]$ 表示我们的 $gcd[i]$ 为 $i$ 的倍数的方案数是多少个，然后我们就可以通过我们的 gcd 容斥来计算出我们的答案。

$$
g_i=\begin{pmatrix}\sum_{i=1}^n[i|a_i]\\k\end{pmatrix}
$$

之后我们倒叙枚举我们的 $g[i]$,然后每一次我们让我们的 $g[i]-=g[2*i]+g[3*i]+g[4*i]\dots$
另一个问题是，我们怎么样才能快速的计算出我们的 cnt，这里我们的 cnt 存在下面的公式，如果我们一个数能够正数我们的 t, 那么这个数我们一定选。否则我们一定不选。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
int n,m,k,f[N],cnt[N],fac[N],inv[N];
int quickpow(int a,int b,int p)
{
	int ret=1;
	a%=p;
	while(b)
	{
		if(b%2==1)
		{
			ret=(ret*a)%p;
		}
		a=a*a%p;
		b/=2;
	}
	return ret;
}
int c(int x,int y)
{
//	cout<<x<<" "<<y<<endl;
	if(x<y)
	{
		return 0;
	}
//	cout<<fac[x]<<" "<<inv[y]<<" "<<inv[x-y]<<endl;
	return fac[x]*inv[y]%mod*inv[x-y]%mod;
}
signed main()
{
	int x,y;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		cnt[x]=(cnt[x]+1)%mod;
	}
	fac[0]=fac[1]=1;
	for(int i=2;i<N;i++)
	{
		fac[i]=fac[i-1]*i%mod;
	}
	inv[N-1]=quickpow(fac[N-1],mod-2,mod);
	for(int i=N-2;i>=0;i--)
	{
		inv[i]=inv[i+1]*(i+1)%mod;
	}
	for(int i=m;i;i--)
	{
		x=0;
		y=0;
		for(int j=i;j<=m;j+=i)
		{
			x=(x+cnt[j])%mod;
			y=(y+f[j])%mod;
		}
		f[i]=((c(x,k)-y)%mod+mod)%mod;
	}
	for(int i=1;i<=m;i++)
	{
		cout<<f[i]<<" ";
	}
}

```