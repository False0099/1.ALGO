# [ABC 355 E] Guess the Sum

## 题面翻译

### 注意事项

这道题是一道**交互题**，使用标准输入输出流进行交互。

请确认在每次输出后**刷新缓存区**，否则可能会得到 TLE 或 WA 等判定结果。

### 题目描述

给定正整数 $N$ 和整数 $L$、$R$，其中 $0\le L\le R<2^N$。交互库有一个长为 $2^N$ 的整数数列 $A$，**数列从 $0$ 开始编号**，数列 $A$ 中每个数都在 $0$ 到 $99$ 之间。（包括 $0$ 和 $99$）

**你无法直接输入数列 $A$。**

你的目标是求出 $(A_L+A_{L+1}+\cdots+A_R)\bmod100$ 的值。

你每次询问可以指定整数 $i$ 和 $j$，令 $l=2^ij$，$r=2^i(j+1)-1$。则交互库会回复 $(A_l+A_{l+1}+\cdots+A_r)\bmod100$ 的值。

设 $m$ 为最优解确定最终答案所需的询问次数，那么不能询问超过 $m$ 次。

### 交互格式

本题**使用标准输入输出流进行交互**而非调用函数进行交互。

**请确保交互格式正确**，否则将会得到 WA 或 TLE 等判定结果。

#### 基础信息

在一开始，你会读入一行三个整数，分别代表 $N$、$L$ 和 $R$。

#### 询问格式

你可以输出一行 `? i j` 进行询问，其中 $i$ 和 $j$ 的含义如题目描述所示。

 $i$ 和 $j$ 须满足以下所有条件：

-  $i$ 和 $j$ 均为非负整数。
- $2^i(j+1)\le2^N$。

交互库将会回复一行一个整数 $T$。

如果你询问的次数超过 $m$ 或询问的 $i$ 和 $j$ 不合法，则 $T=-1$，此时你需要立即结束程序。（并会得到 WA 的判定结果）

否则，$T$ 表示的是询问的回复，具体含义如题目描述所示。

#### 回答格式

当你认为你确定了题目所求答案的值，你可以输出一行 `! S` 进行回答。

其中 $S$ 为你认为题目所求答案的值，**你应当在执行此操作后立即结束程序**，否则可能会得到错误的判定结果。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_e

この問題は **インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

正整数 $ N $ および $ 0 $ 以上 $ 2^N $ 未満の整数 $ L,R (L\leq\ R) $ が与えられます。 ジャッジシステムは、$ 0 $ 以上 $ 99 $ 以下の整数からなる長さ $ 2^N $ の数列 $ A\ =\ (A_0,\ A_1,\ \dots,\ A_{2^N-1}) $ を隠し持っています。

あなたの目標は $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを求めることです。ただし、あなたは数列 $ A $ の要素の値を直接知ることはできません。 その代わりに、ジャッジシステムに対して以下の質問を行うことができます。

- $ 2^i (j+1)\leq\ 2^N $ を満たすように非負整数 $ i, j $ を選ぶ。$ l=2^ij, r=2^i (j+1)-1 $ として $ A_l+A_{l+1}+\dots+A_{r} $ を $ 100 $ で割った余りを聞く。
 
どのような $ A $ であっても $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを特定することができる質問回数の最小値を $ m $ とします。$ m $ 回以内の質問を行って $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを求めてください。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

最初に、整数 $ N, L, R $ を標準入力から受け取ってください。

> $ N $ $ L $ $ R $

次に、$ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを特定できるまで質問を繰り返してください。質問は、以下の形式で標準出力に出力してください。

> $ ? $ $ i $ $ j $

ここで、$ i, j $ は以下を満たす必要があります。

- $ i, j $ は非負整数
- $ 2^i (j+1)\leq\ 2^N $
 
これに対する応答は、次の形式で標準入力から与えられます。

> $ T $

ここで、$ T $ は質問に対する答えで、$ l=2^ij, r=2^i (j+1)-1 $ としたとき $ A_l+A_{l+1}+\dots+A_{r} $ を $ 100 $ で割った余りです。

ただし、$ i, j $ が制約を満たしていないか、質問回数が $ m $ 回を超えた場合は $ T $ は `-1` となります。

ジャッジが `-1` を返した場合、プログラムはすでに不正解とみなされています。この場合、ただちにプログラムを終了してください。

$ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りが特定出来たら、$ S $ を $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りとして以下の形式で出力してください。その後、ただちにプログラムを終了してください。

> $ ! $ $ S $

## 输入格式

## 输出格式

## 提示

### 制約

- $ 1\leq\ N\leq\ 18 $
- $ 0\leq\ L\leq\ R\leq\ 2^N-1 $
- 入力は全て整数
 
### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で誤った出力形式による出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
 
### 入出力例

以下は、$ N=3, L=1, R=5, A=(31,41,59,26,53,58,97,93) $ の場合の入出力例です。この場合 $ m=3 $ であるため、質問を $ 3 $ 回まで行うことができます。

    入力 出力 説明     `3 1 5`  まず整数 $ N,L,R $ が与えられます。    `? 0 1`  $ (i,j)=(0,1) $ として質問を行います。   `41`  $ l=1,r=1 $ であるため、質問の答えは $ A_1=41 $ を $ 100 $ で割った余りである $ 41 $ です。ジャッジはその値を返します。    `? 1 1` $ (i,j)\ =\ (1,1) $ として質問を行います。   `85`  $ l=2,r=3 $ であるため、質問の答えは $ A_2+A_3=85 $ を $ 100 $ で割った余りである $ 85 $ です。ジャッジはその値を返します。    `? 1 2` $ (i,j)\ =\ (1,2) $ として質問を行います。   `11`  $ l=4,r=5 $ であるため、質問の答えは $ A_4+A_5=111 $ を $ 100 $ で割った余りである $ 11 $ です。ジャッジはその値を返します。    `! 37` 答えは $ 37 $ であるとわかったので、それを出力します。

## 题解
本题要求给定我们一个区间，然后要你问从 l 到 r 的和是多少，对于我们的区间求和问题，我们的思路是，**通过我们的差分约束思想进行建图**，然后我们通过不断地挑点，就可求出我们的最后的结果是多少。

同样的，我们的建边限制，那么我们就先找到我们从我们的起点到我们的重点，一共经过**多少次跳跃**，条约的次数就是我们的最少询问次数。

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;
const int N = (1 << 18) + 10;
int pre[N];

int main (void)
{
    int n, l, r, up, res = 0;
    queue<int> q;

    cin >> n >> l >> r, ++r, up = 1 << n;
    memset (pre, 0xff, sizeof pre);
    q.push (l), pre[l] = l;
    while (!q.empty ()) {
        int u = q.front (); q.pop ();
        for (int i = 1; i <= up; i <<= 1) {
            int v;
            if ((v = u - i) >= 0 && pre[v] == -1) pre[v] = u, q.push (v);
            if ((v = u + i) <= up && pre[v] == -1) pre[v] = u, q.push (v);
            if (u & i) break;
        }
    }

    for (int u = r; u != l; u = pre[u]) {
        int x = pre[u], y = u, sign = 1, t;
        if (x > y) swap (x, y), sign = -1;
        cout << "? " << __lg (y - x) << ' ' << x / (y - x) << endl;
        cin >> t, (res += sign * t + 100) %= 100;
    }
    cout << "! " << res << endl;
    return 0;
}
```