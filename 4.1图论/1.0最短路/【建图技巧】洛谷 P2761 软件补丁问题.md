# 软件补丁问题

## 题目描述

T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。

每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。

换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。

试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。

## 输入格式

第一行有两个正整数 $n$ 和 $m$。$n$ 表示错误总数，$m$ 表示补丁总数。

接下来 $m$ 行给出了 $m$ 个补丁的信息。每行包括一个正整数，表示运行补丁程序 $i$ 所需时间，以及两个长度为 $n$ 的字符串。中间用一个空格符隔开。

第一个字符串中，如果第 $k$ 个字符为 ```+```，则表示第 $k$ 个错误属于 $B1_i$。若为 ```-```，则表示第 $k$ 个错误属于 $B2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $B1_i$ 也不属于 $B2_i$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。

第二个字符串中，如果第 $k$ 个字符为 ```-```，则表示第 $k$ 个错误属于 $F1_i$。若为 ```+```，则表示第 $k$ 个错误属于 $F2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $F1_i$ 也不属于 $F2_i$，即软件中是否包含第 $k$ 个错误不会因使用补丁 $i$ 而改变。

## 输出格式

程序运行结束时，将总耗时数输出。如果问题无解，则输出 `0`。

## 样例 #1

### 样例输入 #1

```
3 3
1 000 00-
1 00- 0-+
2 0-- -++
```

### 样例输出 #1

```
8
```

## 提示

对于 $100\%$ 的数据：$1\le n\le 20$，$1\le m\le 100$。

## 题解
我们本题的逆天之处在于我们的建图比较具有技巧性，我们不能对于我们的压缩包或者我们的补丁建图，我们要根据我们的 bug 状态来建图，首先，因为我们的 $bug$ 总数不会超过 20，所以我们的点数也不会超过我们的 $2^{20}$。

而建立玩点之后，考虑我们怎么连边，我们两个状态之间如果存在一条边 $"m_{1}"$,那么当且仅当我们的状态左侧包含我们的所有 B 1，并且不包含任何的 B 2，我们的状态右侧的状态就是我们的左侧状态去除我们的 F 1，并且添加了我们的 F 2. 而我们上面的状态，我们就可以表示为：$b_{1}\&x=b_{1},b_{2}\&x=0$,我们的建边的重点就是：$((x|f_{1})\oplus f_{1})|f_{2}$ 。之后，我们再去进行我们的连边即可。

最后，我们跑一个最短路即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int pop=0,n,m,s,t;
int v[4000000],d[4000000];
queue<int>q;
int b1[1000],b2[1000],f1[1000],f2[1000],xx[1000];
void spfa(){
//初始化
    memset(v,0,sizeof(v));
    memset(d,0x7f,sizeof(d));
    d[s]=0;while(q.size())q.pop();
    q.push(s);
    while(q.size()){
        int x=q.front(),y;q.pop();
        v[x]=0;
        for(int i=1;i<=m;i++){ 
        //枚举补丁
            if((b1[i]&x)==b1[i]&&(b2[i]&x)==0){
            //判断当前节点是否可以做为起点
            	y=((x|f1[i])^f1[i])|f2[i];
                //求出终点
                if(d[x]+xx[i]<d[y]){
                  //spfa的松弛操作
                	d[y]=d[x]+xx[i];
                	if(!v[y]){
                		v[y]=1;
                		q.push(y);
                    }
                }
            }
        }
    }
    printf("%d\n",d[t]==0x7f7f7f7f?0:d[t]);
}
int main()
{
    scanf("%d%d",&n,&m);
    t=0;s=(1<<n)-1;
    char a[1000],b[1000];
    for(int i=1;i<=m;i++){   
    //预处理出每个补丁对应的b1,b2,f1,f2
        scanf("%d%s%s",&xx[i],a,b);
        b1[i]=b2[i]=f1[i]=f2[i]=0;
        for(int j=0;j<n;j++){
            if(a[j]=='+')
              b1[i]|=(1<<j);
            if(a[j]=='-')
              b2[i]|=(1<<j);
            if(b[j]=='+')
              f2[i]|=(1<<j);
            if(b[j]=='-')
              f1[i]|=(1<<j);
        }
    }
    spfa();
    return 0;
}
```