## 题目描述
众所周知，TT 有一只魔法猫。

这一天，TT 正在专心致志地玩《猫和老鼠》游戏，然而比赛还没开始，聪明的魔法猫便告诉了 TT 比赛的最终结果。TT 非常诧异，不仅诧异于他的小猫咪居然会说话，更诧异于这可爱的小不点为何有如此魔力？

魔法猫告诉 TT，它其实拥有一张游戏胜负表，上面有 N 个人以及 M 个胜负关系，每个胜负关系为 A B，表示 A 能胜过 B，且胜负关系具有传递性。即 A 胜过 B，B 胜过 C，则 A 也能胜过 C。

TT 不相信他的小猫咪什么比赛都能预测，因此他想知道有多少对选手的胜负无法预先得知，你能帮帮他吗？

## 输入格式

第一行给出数据组数。

每组数据第一行给出 N 和 M（N , M <= 500）。

接下来 M 行，每行给出 A B，表示 A 可以胜过 B。

## 输出格式

对于每一组数据，判断有多少场比赛的胜负不能预先得知。注意 (a, b) 与 (b, a) 等价，即每一个二元组只被计算一次。

## 样例 #1

### 样例输入 #1

```
3
3 3
1 2
1 3
2 3
3 2
1 2
2 3
4 2
1 2
3 4
```

### 样例输出 #1

```
0
0
4
```

## 提示
这一题是传递闭包的标准题型，我们只需要采用bitset优化就可以了。无法确定胜负关系，即等价于$dp[i][j]=dp[j][i]=0$,只需要统计这样的点对即可。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=510;
int n,m;
bitset<N>d[N];
void floyd(){
	for(int k=1;k<n;k++){
		for(int i=1;i<=n;i++){
			if(d[i][k]){
				d[i]|=d[k];
			}
		}
	}
}
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				d[i][j]=(i==j);
			}
		}
		int u,v;
		for(int i=0;i<m;i++){
			cin>>u>>v;
			d[u][v]=1;
		}
		floyd();
		int tot=0;
		for(int i=1;i<=n;i++){
			for(int j=i+1;j<=n;j++){
				if(d[i][j]==0&&d[j][i]==0){
					tot++;
				}
			}
		}
		cout<<tot;
	}
}
```