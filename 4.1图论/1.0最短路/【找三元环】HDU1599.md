杭州有 N 个景区，景区之间有一些双向的路来连接，现在8600想找一条旅游路线，这个路线从 A 点出发并且最后回到 A 点，假设经过的路线为 V1,V2,....VK,V1,那么必须满足 K>2,就是说至除了出发点以外至少要经过2个其他不同的景区，而且不能重复经过同一个景区。现在8600需要你帮他找一条这样的路线，并且花费越少越好。  

### Input

第一行是2个整数N和M（N <= 100, M <= 1000)，代表景区的个数和道路的条数。  
接下来的M行里，每行包括3个整数a,b,c.代表a和b之间有一条通路，并且需要花费c元(c <= 100)。

### Output

对于每个测试实例，如果能找到这样一条路线的话，输出花费的最小值。如果找不到的话，输出"It's impossible.".

## 题解
本题是使用 FLOYD 寻找最小代价环的模板题，我们
1. 一个环中的编号最大的点为 K，i 和 j 是与 K 相邻两点，且满足 i<j<k, 则该环的长度，dist=Dij+Wik+Wkj，Dij 是不经过点 K 的最短距离
2. 使用 Floyd 算法，当最外层循环到点 K 时（还没有开始第 K 次循环），Dij 计算未经过点 K 的最短距离
3. 循环全部点，更新 dist 最小值即可

我们首先枚举我们的一个中转点 $k$,然后我们要求我们**先求环，再去更新我们的最短路**，这样的顺序才能够保证不会出现路径重复的情况。也就是说我们的下面的情况不会出现：
![[Pasted image 20241011231414.png]]

也就是我们可以通过**插入新的点的方法来理解我们的 floyd**。当我们插入一个新的点的时候，我们把**新点和原来的点**都去进行处理更新。
```
for(int k=1;k<=n;k++){

    for(int i=1;i<k;i++){

        for(int j=i+1;j<k;j++){

            mincircle=min(mincircle,dist[i][j]+g[i][k]+g[k][j]);

        }

    }

    for(int i=1;i<=n;i++){

        for(int j=1;j<=n;j++){

            dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);

        }

    }

}
```
