> 我似乎曾**记忆化搜寻**过这个地方……

![](https://uploadfiles.nowcoder.com/images/20230929/0_1695993740068/5671240B3B1FDC6FBA74837F8BAC26B2)  

长途是 ACM 大陆一只快乐的小男孩。今天，他在 cf 战场上历练，遭遇了 $T$ 波丧尸

长途快被丧尸咬死啦！幸好他手中的两把武器都还有 $20^{20^{20^{20}}}$ 枚子弹，一枚子弹可以击中一个丧尸  

-   武器 1——【**_AC_**】：每次射击可以发射一枚子弹
-   武器 2——【**_AK-47_**】：每次射击可以同时朝当前每个丧尸均发射一枚子弹

然而，丧尸有种特殊的能力，每次击中并不会死掉，反而会立刻复制出一个新的丧尸

  

长途有点绝望。幸好他发现当前这波的所有丧尸都处在一个特殊的圆盘上！这个圆盘被称为圆神，当丧尸的数量是 $2^{20}$ 的倍数时，可以选择启动这个装置，消灭当前这波的全部丧尸！！！  
值得注意的是，一共有 $T$ 大波丧尸，只有当一波的丧尸被全部消灭后，下一波的丧尸才会出现，并且手中武器的子弹数也会恢复  
情况很紧急，长途请你帮帮他。对于每一波丧尸，**最少**需要射击多少次才能消灭这一波的所有丧尸。若消耗完所有的子弹都无法消灭这一波的所有丧尸，请输出 $-1$

## 输入
第一行包含一个整数 $T$，表示长途遭遇了 $T\ (1\le T\le 10^5)$波丧尸  
对于每波丧尸：  
仅输入一行，包含一个正整数 $\ n\ (1\le n\le10^9)$，表示当前这波的丧尸数

## 输出
对于每波丧尸：  
仅输出一行，若消耗完所有的子弹都无法消灭这一波的所有丧尸，输出 $-1$；否则输出消灭当前这波的所有丧尸所需要的最少射击次数

## 示例 ：
输入
--

 3 1048575 1048576 1

```
3
1048575
1048576
1
```

输出

```
1
0
20 ```
```

## 题解
令 $p=2^{20}$,设 $r_{x}=\text{x}\%p$, $r_{y}=y\%p$,其中 x 为当前的丧失数量，y 为某一次变化后的丧失数量，如果 $y=x+1$,那么我们有 $r_{y}=(r_{x}+1)\%p$, $r_{y}=(2\times r_{x})\%p$,因为 p 范围不大，我们考虑建图后 $o(1)$ 的回答我们的问题，具体的，对于每一个 $r_{x}$ 可能的值，我们从 $r_{x}$ 向 $r_{x}+1$, $(2\times r_{x})\%p$ 分别连一条边权为 1 的边。
我们最后求 $r_{n}=0$ 的最小操作数。

```cpp
ll dis[1<<20];
vector<ll> e[1<<20];
inline void qfl_zzz(){
    ll n=read();
    writen(dis[n%(1<<20)]);
}
inline void pre_work(){
    ll n=1<<20;
    for(ll i=0;i<n;++i){
        e[(i+1)%n].push_back(i);
        e[2*i%n].push_back(i);
    }
    memset(dis,0x3f,sizeof(dis));
    queue<ll> q;
    q.push(0),dis[0]=0;
    while(q.size()){
        ll u=q.front();q.pop();
        for(ll v:e[u])
            if(dis[v]>dis[u]+1){
                dis[v]=dis[u]+1;
                q.push(v);
            }
    }
}
```

方法 2：我们枚举我们每一步加多少，乘多少，因为我们最大的个数就是 20，所以我们从 20 开始枚举起，先枚举加多少，再枚举乘多少。