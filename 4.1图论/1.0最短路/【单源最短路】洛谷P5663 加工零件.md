# [CSP-J 2019] 加工零件

## 题目描述

凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 $n$ 位工人，工人们从 $1 \sim n$ 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。

如果 $x$ 号工人想生产一个被加工到第 $L\,(L \gt 1)$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要生产一个被加工到第 $L - 1$ 阶段的零件（但 $x$ 号工人自己**无需**生产第 $L - 1$ 阶段的零件）。

如果 $x$ 号工人想生产一个被加工到第 $1$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要为 $x$ 号工人提供一个原材料。

轩轩是 $1$ 号工人。现在给出 $q$ 张工单，第 $i$ 张工单表示编号为 $a_i$ 的工人想生产一个第 $L_i$ 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！

## 输入格式

第一行三个正整数 $n$，$m$ 和 $q$，分别表示工人的数目、传送带的数目和工单的数目。

接下来 $m$ 行，每行两个正整数 $u$ 和 $v$，表示编号为 $u$ 和 $v$ 的工人之间存在一条零件传输带。保证 $u \neq v$。

接下来 $q$ 行，每行两个正整数 $a$ 和 $L$，表示编号为 $a$ 的工人想生产一个第 $L$ 阶段的零件。

## 输出格式

共 $q$ 行，每行一个字符串 `Yes` 或者 `No`。如果按照第 $i$ 张工单生产，需要编号为 1 的轩轩提供原材料，则在第 $i$ 行输出 `Yes`；否则在第 $i$ 行输出 `No`。注意输出**不含**引号。

## 样例 #1

### 样例输入 #1

```
3 2 6
1 2
2 3
1 1
2 1
3 1
1 2
2 2
3 2
```

### 样例输出 #1

```
No
Yes
No
Yes
No
Yes
```

## 样例 #2

### 样例输入 #2

```
5 5 5
1 2
2 3
3 4
4 5
1 5
1 1
1 2
1 3
1 4
1 5
```

### 样例输出 #2

```
No
Yes
No
Yes
Yes
```

## 提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。


编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。

编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

**样例 2 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。

编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。

编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。

编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。

**数据规模与约定**

共 $20$ 个测试点。

对所有测试点保证 $1 \leq u, v, a \leq n$。

测试点 $1\sim4$，$1 \leq n, m \leq 1000$，$q = 3$，$L = 1$。

测试点 $5\sim8$，$1 \leq n, m \leq 1000$，$q = 3$，$1 \leq L \leq 10$。

测试点 $9\sim12$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 100$。

测试点 $13\sim16$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 10^5$。

测试点 $17\sim20$，$1 \leq n, m, q \leq 10^5$，$1 \leq L \leq 10^9$。

## 题解
我们本题首先需要我们推导结论，如果我们的终点需要一个等级为 $L_{i}$ 的零件，那么等价于我们就有两点之间存在一条长为 $L_{i}$ 的可重复路径都要对我们的这一个零件提供我们的原材料。

那么现在我们可以考虑转换，假如我们原来要求的是我们的 $(u,v)$ 之间的距离，现在，我们经过我们的转换后，就可以转换为我们从我们的起点到我们的终点的最短路径是多少。

但是，我们只关注最短路的方法显然是错误的，因为我们如果只关注我们的最短路，首要原因是我们连我们的样例都过不去，根本原因是，我们如果到我们的某一个点的最短距离为 $x$,**不代表，我们可以任意构造一条路径，到我们这一个点的距离为 (x+k)**.

但是，如果我们对我们的图分奇偶来进行讨论，那么我们上述的讨论就是成立的：即：如果我们到我们的某一个点的最短奇数距离为 $x$,那么我们的所有 $x+2k$ 都可以构成。偶数也同理。

最后，综上所述，我们只需要关注我们到某一个点的最小的奇数/偶数路径长度即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
vector<int> edge[N];
void add(int a,int b){
	edge[a].push_back(b);
	edge[b].push_back(a);
}
int dist[N][2];
typedef pair<int,int> PII;
void dij(){
	memset(dist,0x3f3f3f,sizeof dist);
	priority_queue<PII,vector<PII>,greater<PII>> heap;//0表示偶数 
	dist[1][0]=0;
	heap.push({0,1});//1表示奇数 
	while(heap.size()){
		auto u=heap.top();
		heap.pop();
		int prev_no=u.second;
		int val_no=u.first;
		for(int i=0;i<edge[prev_no].size();i++){
			int v=edge[prev_no][i];
			if((val_no+1)%2==0&&dist[v][0]>val_no+1){
				dist[v][0]=val_no+1;
				heap.push({dist[v][0],v});
			}
			if((val_no+1)%2==1&&dist[v][1]>val_no+1){
				dist[v][1]=val_no+1;
				heap.push({dist[v][1],v});
			}
		}
	}
}
int n,m;
signed main(){
	int q;
	cin>>n>>m>>q;
	for(int i=0;i<m;i++){
		int a,b;
		cin>>a>>b;
		add(a,b);
	}
	dij();
	while(q--){
		int a,l;
		cin>>a>>l;
		if(dist[a][l%2]>l){
			cout<<"No"<<endl;
		}else{
			cout<<"Yes"<<endl;
		}
	}
	
}
```