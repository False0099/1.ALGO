# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 输入格式

**本题有多组测试数据。**

第一行，一个整数 $T$，表示数据组数。

对于每组数据：

第一行，一个整数 $n$，表示据点数量；

第二行，$n$ 个整数 $l_1, l_2, \dots, l_n$；

第三行，$n$ 个整数 $r_1, r_2, \dots, r_n$。

## 输出格式

对于每组数据：

一行，一个字符串。若可以满足总司令的需求，一行 `YES`；否则，一行 `NO`。

## 样例 #1

### 样例输入 #1

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2
```

### 样例输出 #1

```
YES
NO
```

## 样例 #2

### 样例输入 #2

```
见下发文件 road2.in
```

### 样例输出 #2

```
见下发文件 road2.out
```

## 提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/29eovgns.png)
#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|    测试点编号     | $n \le$ |                     特殊条件                      | 每个测试点分数 |
| :----------: | :-----: | :-------------------------------------------: | :-----: |
|  $1\sim 2$   |  $10$   |                       无                       |   $5$   |
|  $3\sim 6$   | $1000$  |                       无                       |   $5$   |
|  $7\sim 8$   | $10^5$  | 所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$ |   $5$   |
| $9 \sim 10$  | $10^5$  |              $l_i=0$ 或 $r_i=n-1$              |   $5$   |
| $11 \sim 15$ | $10^5$  |                       无                       |  $10$   |

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 题解
**注意，我们题目中的原有的所有边都需要保留，不能删除，**

本题要求我们构造一个有向无环图，看到构造有向无环图，我们应该想到去对于我们的**每一个点构造它的拓扑序**是多少。

而在拓扑序中，第 $i$ 个点的出度就是比他编号大的点的个数，即 $拓扑序=n-出度$ 。这里，因为我们给出了每一个节点的出度的顺序，我们于是就可以求出我们每一个结点对应的拓扑序的可能的范围是多少。

这个时候，我们的问题就变成了：
**给定 n 个区间 $[l,r]$，问你是否存在一个 $1-n$ 的排列 a，使得 $\forall1\leq i\leq n,l_{i}\leq a_{i}\leq r_{i}$,**

对于上面的问题，我们就可以贪心的求解，对于每一个**排列中的数** $i$,我们把原区间中满足 $l_{i}=i$ 的区间右端点加入到我们的小根堆中，匹配时，我们就取出堆中最小右端点，把 $i$ 放进对应区间，在操作过程中，如果我们的队列为空或者我们的最小右端点比我们的比 $i$ 小，我们就无解。

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve(){
	int n;
	cin>>n;
	unordered_map<int,vector<int>> mp;
	vector<int> l(n);
	vector<int> r(n);
	for(int i=0;i<n;i++){
		cin>>l[i];
	}
	for(int i=0;i<n;i++){
		cin>>r[i];
		mp[l[i]].push_back(r[i]);
	}
	priority_queue<int,vector<int>,greater<int>> heap; 
	for(int i=0;i<n;i++){
		vector<int> posr=mp[i];
		for(auto u:posr){
			heap.push(u);
		}
		if(heap.size()==0){
			cout<<"NO"<<endl;
			return;
		}
		int x=heap.top();
		heap.pop();
		if(x<i){
			cout<<"NO"<<endl;
			return;
		}
	}
	cout<<"YES"<<endl;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		solve();
	}
}
```