Boudreaux 喜欢多任务处理，尤其是在使用电脑时。他从不满足于一次只运行一个应用程序，通常在自己的屏幕中运行九个应用程序。由于电脑屏幕空间有限，他将这些应用程序的窗口重叠放置，并将当前需要使用的任何应用程序窗口带到前景。如果他的屏幕是一个4 x 4的正方形网格，那么 Boudreaux 的每个应用程序将由以下2 x 2方格大小的窗口表示：  

|   |   |   |
|---|---|---|
|\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|1\|1\|.\|.\|<br>\|1\|1\|.\|.\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|2\|2\|.\|<br>\|.\|2\|2\|.\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|3\|3\|<br>\|.\|.\|3\|3\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\||
|\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|4\|4\|.\|.\|<br>\|4\|4\|.\|.\|<br>\|.\|.\|.\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|.\|5\|5\|.\|<br>\|.\|5\|5\|.\|<br>\|.\|.\|.\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|6\|6\|<br>\|.\|.\|6\|6\|<br>\|.\|.\|.\|.\||
|\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\|<br>\|7\|7\|.\|.\|<br>\|7\|7\|.\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\|<br>\|.\|8\|8\|.\|<br>\|.\|8\|8\|.\||\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|.\|.\|<br>\|.\|.\|9\|9\|<br>\|.\|.\|9\|9\||

当Boudreaux将一个应用程序带到前景时，它的窗口所对应的2 x 2方格都会出现在顶部，它将与其他占用这些方格的应用程序窗口发生重叠，导致其他应用程序窗口重叠的部分被遮挡。

例如，如果先将应用程序1置于前景，再将应用程序2置于前景，则结果表示为：

|   |   |   |
|---|---|---|
|\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|1\|2\|2\|?\|<br>\|1\|2\|2\|?\|<br>\|?\|?\|?\|?\|<br>\|?\|?\|?\|?\||如果应用程序4再被带到前景，结果将进一步表示为：|\|   \|   \|   \|   \|<br>\|---\|---\|---\|---\|<br>\|1\|2\|2\|?\|<br>\|4\|4\|2\|?\|<br>\|4\|4\|?\|?\|<br>\|?\|?\|?\|?\||

. . . and so on . . .  
不幸的是，Boudreaux的计算机非常不可靠，经常崩溃。他可以很容易地通过观察每一个方格，看到一个图形表示来判断他的计算机是否发生了崩溃。如果按照序列应用程序置于前景操作后，都不应该出现这种图形表示，此时即为计算机发生了崩溃。如下图所示，对于前述例子，应用程序4最后出现，则第2行的第2个方格应该是4而不是2，原来的2会被最后出现的4覆盖，则说明此时计算机发生了崩溃。  

|   |   |   |   |
|---|---|---|---|
|1|2|2|?|
|4|2|2|?|
|4|4|?|?|
|?|?|?|?|

输入

该问题的输入将由最多100组测试数据组成。每组测试数据都将按照以下描述进行格式化，各组数据之间不会有空行分隔。  
  
每组测试数据均包含3个部分：  

1. 第一部分为一行 字符:  
    START  
    
2. 第二部分为屏幕截图- 4x4 的数字矩阵，代表Boudreaux屏幕的当前图形表示。这个4x4矩阵中的每个位置将代表每个方块中显示的当前应用程序窗口。为了便于输入，每行上的数字列表将用一个空格分隔。  
    
3. 第三部分为一行字符：  
    END  
    

在最后一组测试数据结尾，会有一行提示：  
ENDOFINPUT  
  
请注意，每一个应用程序的窗口都只会出现在屏幕区域。当某个应用程序窗口被带到前面时，这个应用程序对应的2 x 2方格就会出现代表该应用程序的数字，但是这些数字可能会被后面置于前景的应用程序窗口的代表数字所覆盖。

输出

对于每个数据集，只有一行输出。如果通过切换应用程序窗口可以得到当前的图形表示，那么输出一行语句：  
THESE WINDOWS ARE CLEAN  
否则，输出将是一行语句：  
THESE WINDOWS ARE BROKEN

样例

|Inputcopy|Outputcopy|
|---|---|
|START<br>1 2 3 3<br>4 5 6 6<br>7 8 9 9<br>7 8 9 9<br>END<br>START<br>1 1 3 3<br>4 1 3 3<br>7 7 9 9<br>7 7 9 9<br>END<br>ENDOFINPUT|THESE WINDOWS ARE CLEAN<br>THESE WINDOWS ARE BROKEN|


## 题解
我们这一题的关键是枚举我们每一个位置可能有的程序是哪些，注：我们**每一个点只能向比他还要大的地方延申**，用这个来构建一个表，然后我们就从大到小的连边，比如我们的第一个样例：1 2 3 3 4 5 6 6 7 8 9 9 7 8 9 9 。就可以画出这样的一个表：![[Pasted image 20231016220050.png]] 之后，我们根据我们的构造出来的表来连边，**从大到小**，出现在同一块就连边，我们就能构造出下面的图：![[Pasted image 20231016220127.png]]
这是我们就再去判断是否有回路即可。

本题的难点之一在于建图：
我们先用一个**rule 来存储如果是规范的，我们每一个窗口可能有的数字总共有哪些**，之后，我们再看我们这个地方出现的数字是哪一个，那么就说明**我们现在出现的这个数字，覆盖了我们之前出现的数字**，然后再把这个数字和我们的这个位置上和这个数字不同的之间连边，**表示一个覆盖关系**。如果出现的是合法的，那么我们的图中的拓扑序应该是没有环的，否则就是有环的。

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
const int INF = 0x3f;
const int MAX_N = 20;
//____________邻接矩阵__________
int map[10][10];
//____________AOV_______________
int d[MAX_N];//保存入度
int vis[MAX_N];
queue<int>q;//保存入度为0的顶点
//______________________________
int num[5][5];
string rule[5][5];
 
 
//初始化
inline void init(){
    memset(map,0,sizeof(map));
    memset(d,0,sizeof(d));
    memset(vis,0,sizeof(vis));
    while(!q.empty()) q.pop();//清空队列
}
 
int AOV(int n){
    int all = 0;//用于判断环路
    //找入度为0的点
    for(int i = 1;i<=n;i++){
        if(d[i] == 0){
            q.push(i);
            vis[i] = 1;
        }
    }
    //开始计算
    while(!q.empty()){
        int u = q.front();
        q.pop();
        all++;
        for(int v = 1;v<=n;v++){
            if(map[u][v] == 1) d[v]--;
            map[u][v] = 0;
            if(d[v] == 0&&!vis[v]){
                q.push(v);
                vis[v] = 1;
            }
        }
    }
    if(all == n) return 1;
    return 0; 
}
 
inline void get_rule(){
    rule[1][1] = "1";rule[1][2] = "12";rule[1][3] = "23";rule[1][4] = "3";
    rule[2][1] = "14";rule[2][2] = "1245";rule[2][3] = "2356";rule[2][4] = "36";
    rule[3][1] = "47";rule[3][2] = "4578";rule[3][3] = "5689";rule[3][4] = "69";
    rule[4][1] = "7";rule[4][2] = "78";rule[4][3] = "89";rule[4][4] = "9";
}
 
inline void get_map(int n){
    for(int i = 1;i<=4;i++){
        for(int j = 1;j<=4;j++){
            for(int k = 0;rule[i][j][k];k++){
                if(num[i][j]+'0' == rule[i][j][k]) continue;
                else map[num[i][j]][rule[i][j][k]-'0'] = 1;
            }
        }
    }
    //得到入度
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n;j++){
            if(map[j][i] == 1) d[i] ++;
        }
    }
}
 
inline void print_map(int n){
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n;j++) 
            cout<<map[i][j]<<" ";
        cout<<endl;
    }
    cout<<"d:";
    for(int i = 1;i<=n;i++)cout<<" "<<d[i];
    cout<<endl;
}
 
 
 
int main()
{
    string op;
    get_rule();
    while(cin>>op && op!="ENDOFINPUT"){
        init();
        for(int i = 1;i<=4;i++)
            for(int j = 1;j<=4;j++)
                cin>>num[i][j];
        cin>>op;
        get_map(9);
        // print_map(9);
        if(AOV(9)) cout<<"THESE WINDOWS ARE CLEAN"<<endl;
        else cout<<"THESE WINDOWS ARE BROKEN"<<endl;
    }
    return 0;
}
```

