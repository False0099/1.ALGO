# [CoE R 5/Stoi 2029] 半岛铁盒

## 题目背景

> 为什么这样子你拉着我说你有些犹豫  
> 怎么这样子雨还没停你就撑伞要走  
> 已经习惯不去阻止你过好一阵子你就会回来  
> 印象中的爱情好像顶不住那时间  
> ——《[半岛铁盒](https://www.bilibili.com/video/BV1fx411N7bU?p=26)》

## 题目描述

**题意简述**

给定一个 $n$ 个顶点 $m$ 条边的无向图，可能有重边自环，可能不连通。

初始时每个顶点有点权，点权为随机正实数。现在需要重新分配每个顶点的点权，使得：

1. 相邻顶点的点权中较大者与较小者之比不超过 $x$；

2. 点权总和不变；

3. 每个顶点的点权不小于初始时的 $\dfrac{p}{q}$。

求最小的 $x \ge 1$，使得对于给定的图，无论初始点权如何，均存在一种满足上述要求的重新分配方式。

---

**原版题面**

神在半岛铁盒里创建了一个世界。

这个世界由 $n$ 个地域和地域之间的 $m$ 条通道组成，每条通道连接两个地域。创世时每个地域有一定的气压，气压为正数。

由于世界刚刚创建，比较混乱，所以两个地域之间可能有多条通道相连，一个地域也有可能有通道连接到自身，两个地域也可能无法通过若干条通道相互通行。

由于通道连接的两个地域气压之比（大比小，下同）过大时会在通道里形成强风，使得跨地域旅行非常危险，所以造世神决定调整每个地域的气压使得每条通道连接的两个地域气压之比都不超过安全比值 $x$。显然 $x \ge 1$。

由于各种守恒定律被打破会很麻烦，所以神希望调整前后所有地域的气压之和不变。

由于世界中的生物无法在过低的气压中生存但对高气压的适应力强，因此每个地域改变后的气压必须不低于初始的 $\dfrac{p}{q}$。

由于创世时气压不受神控制地随机，所以神希望安全比值 $x$ 满足无论初始气压如何都存在一种合适的调整气压的方法。

由于通道越宽敞，通行越舒适，但是安全比值 $x$ 也越小，因此神想要求出满足要求的最小安全比值 $x$。

由于神忙着处理创世事务，所以他钦定你来解决这个问题。

## 输入格式

第一行四个正整数 $n,m,p,q$，含义如题。

接下来 $m$ 行，每行两个正整数 $u,v$ 表示一条通道连接的两个地域的编号。

## 输出格式

输出一个实数表示 $x$ 的最小值，保留 $7$ 位小数。

本题采用 Special Judge，如果你的答案与参考答案的差值不超过参考答案值的 $10^{-4}$ 倍即为通过。

## 样例 #1

### 样例输入 #1

```
3 2 1 2
1 2
2 3
```

### 样例输出 #1

```
2.0000000
```

## 样例 #2

### 样例输入 #2

```
10 20 13 37
1 2
1 3
1 5
2 4
2 5
2 6
3 4
3 5
3 7
3 9
3 10
4 6
4 7
4 8
5 7
5 9
7 8
7 9
7 10
9 10
```

### 样例输出 #2

```
3.6903390
```

## 提示

**数据范围**

对于 $10\%$ 的数据，$np \le q$；

对于另外 $20\%$ 的数据，有一个地域和其他所有地域之间有通道相连；

对于另外 $30\%$ 的数据，通道构成一棵树。

对于 $100\%$ 的数据，$1 \le u,v \le n \le 10^3$，$1 \le m \le 3 \times 10^4$，$1 \le p<q \le 10^7$。

## 题解
本题的第一个要求是能够完成我们的阅读理解，我们能够把我们的题意转换为我们人能够读得懂的题意。


对于这种，我们不妨考虑推一下式子：
限制条件：
1. $\dfrac{x_{1}}{x_{2}}\leq a$, $\dfrac{x_{2}}{x_{3}}\leq a$,
2. $\dfrac{y_{1}}{y_{2}}\leq a$, $\dfrac{y_{2}}{y_{3}}\leq a$, 
3. $y_{1}\geq \dfrac{p}{q}*x_{1}$, $y_{2}\geq \dfrac{p}{q}*x_{2}$, $y_{3}\geq \dfrac{p}{q}*x_{3}$, 
4. $x_{1}+x_{2}+x_{3}=y_{1}+y_{2}+y_{3}$,

求解：
$min\{ a \}$,使得我们对于任意的 $x_{1},x_{2},x_{3},y_{1},y_{2},y_{3}$,我们的上述式子都成立。

我们不妨用一个向量来表示我们的状态，我们记我们向量 $\mathbb{R}^n$ ，其中我们的 $\mathbb{R}^n({i)}$ 表示我们第 $i$ 个点对应的状态时什么。

注意到一个性质：**如果对于任意两个合法状态，我们合法状态叠加起来仍然是一个合法状态**。从而，如果我们任意状态都要做到，那么我们只需要对于一个任意的类似于 $(0,0,\dots..,x\dots..,0)$ 的状态可以做到，即可。又因为我们的倍增对我们的结果没有影响，所以我们不妨设我们的 $x=1$,然后去检查。

考虑怎么解决我们的 $x=1$ 时，我们怎么检查，显然，我们某一个结点为 1 时，我们的和一定是唯一确定为 $1$ 的，这个时候，如果我们要满足我们的条件，我们首先就是要把我们的 $1$ 原来所在的那个点给分配出去。同时注意到我们题目中的要求 $\dfrac{p}{q}$ 只对我们原本为 1 的点生效。

而要使我们调整后源点尽可能的大，那么我们一定要让我们的其他点加起来尽可能的小，而根据我们的贪心，我们不难列出下面的式子：
$$\sum_{d\geq 0}a_{d}y^d\leq \dfrac{q}{p}$$

其中我们的 $d$ 表示我们某个点距离我们远点的距离，我们的 $a_{d}$ 表示这一个距离对应的点数是多少。

```cpp
#include<cstdio>
#define rg register
#define ll long long
#define db long double
int n,m,p,q,u,v,d;
int head[1003],cnt;
int dep[1003],que[1003],hd,tl;
struct edge
{
	int nxt,to;
}e[60007];
inline void add(int x,int y)
{
	e[++cnt].nxt=head[x],e[cnt].to=y,head[x]=cnt;
	e[++cnt].nxt=head[y],e[cnt].to=x,head[y]=cnt;
}
ll a[1003];
inline void bfs(int s)
{
	que[++tl]=s,dep[s]=0;
	while(hd<=tl)
	{
		u=que[hd],++a[dep[u]],++hd;
		for(rg int i=head[u];i;i=e[i].nxt)
		{
			v=e[i].to;if(~dep[v])continue;
			que[++tl]=v,dep[v]=dep[u]+1;
		}
	}
	d=dep[u];
}
inline db calc(db x)
{
	db res=a[d];
	for(rg int i=d-1;~i;--i)res=res/x+a[i];
	return res;
}
inline db solve()
{
	db l=1,r=1e10,md,rs,tp;
	for(rg int i=0;i<=d;++i)a[i]*=p;
	while(r-l>=1e-8)
	{
		md=(l+r)/2,rs=-q,tp=1;
		for(rg int i=0;i<=d;++i)
		{
			rs+=a[i]*tp,tp/=md;
		}
		if(rs>0)l=md;
		else r=md;
	}
	return l;
}
db x,y;
int main()
{
	scanf(" %d %d %d %d",&n,&m,&p,&q);x=1;
	if(n*p<=q)return puts("1.0000000"),0;
	for(rg int i=0;i<m;++i){scanf(" %d %d",&u,&v);if(u!=v)add(u,v);}
	for(rg int i=1;i<=n;++i)
	{
		for(rg int j=0;j<=n;++j)dep[j]=-1,a[j]=0;
		hd=1,tl=0,bfs(i),y=solve();if(y>x)x=y;
	}
	printf("%.7Lf\n",x);
	return 0;
}

```