## [[ST表]] [[单源最短路]]
# 跑路

## 题目描述

小 A 的工作不仅繁琐，更有苛刻的规定，要求小 A 每天早上在 $6:00$ 之前到达公司，否则这个月工资清零。可是小 A 偏偏又有赖床的坏毛病。于是为了保住自己的工资，小 A 买了一个空间跑路器，每秒钟可以跑 $2^k$ 千米（$k$ 是任意自然数）。当然，这个机器是用 `longint` 存的，所以总跑路长度不能超过 `maxlongint` 千米。小 A 的家到公司的路可以看做一个有向图，小 A 家为点 $1$，公司为点 $n$，每条边长度均为一千米。小 A 想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证 $1$ 到 $n$ 至少有一条路径。

## 输入格式

第一行两个整数 $n,m$，表示点的个数和边的个数。

接下来 $m$ 行每行两个数字 $u,v$，表示一条 $u$ 到 $v$ 的边。

## 输出格式

一行一个数字，表示到公司的最少秒数。

## 样例 #1

### 样例输入 #1

```
4 4
1 1
1 2
2 3
3 4
```

### 样例输出 #1

```
1
```

## 提示

**【样例解释】**

$1 \to 1 \to 2 \to 3 \to 4$，总路径长度为 $4$ 千米，直接使用一次跑路器即可。

**【数据范围】**

$50\%$ 的数据满足最优解路径长度 $\leq 1000$；

$100\%$ 的数据满足 $2\leq n \leq 50$，$m \leq 10 ^ 4$，最优解路径长度 $\leq$ `maxlongint`。

## 题解
首先，我们本题每一个单位时间能够走过的边权非常特殊，是我们的 $2^k$,因此，我们本题也就不能贪心的计算我们的距离，因为我们的 $2^k-1$ 所需要花费的次数并不是我们的 $k$ 次，而是 2 次（跳到 $2^k$ 再-1）

于是，我们本题看上去需要一个新的图形来计算，我们首先需要预处理出，我们从 i 节点跳 $k$ 次后能够到达哪些点，这个可以通过我们的 $st$ 表来进行计算，我们有转移方程如下：
```
dist[i][j][k]=dist[i][t][k-1]&dist[t][j][k-1];
```

之后，如果我们对应的 $dist[i][j][k]$ 为 1，我们直接连边为 1. 之后，我们要求我们的最短路，直接用我们的 mp 转移（floyd），虽然很奢侈，但是因为我们的 n 范围不大，所以也是可彳亍的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=55;
bool p[N][N][34];
int mp[N][N];
int main(){
	memset(mp,0x3f,sizeof mp);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		mp[u][v]=1;
		p[u][v][0]=true;
	}
	for(int t=1;t<=32;t++){
		for(int k=1;k<=n;k++){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					if(p[i][j][t-1]==true&&p[k][j][t-1]==true){
						p[i][j][t]=true;
						mp[i][j]=1;
					}
				}
			}
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				mp[i][j]=min(mp[i][j]+mp[k][j]);
			}
		}
	}
	cout<<mp[1][n]<<endl;
}
```