## 题目描述
给定一个 $n$ 个点 $m$ 条边的无向图，LH 打算从点 $1$ 出发去点 $n$。  
假如 LH 到达了一个点 $i$，那么他可以选择在这个点花费 $a_i$ 的时间休息后继续赶路，或者不休息然后花费 $1$ 的时间简单整顿后继续赶路。
LH 不能连续超过 $k$ 个节点不休息，问从 $1$ 到 $n$ 的最短时间。
注意：假如 LH 到达了点 $n$ 也需要选择休息或者不休息。

## 题解：
本题可以通过一个最短路 dp，我们设我们的 $dist[i][j]$ 表示我们在我们的 $i$ 点，并且在这之前有了 $j$ 个点没有休息时的最短时间是多少。

我们根据我们在**下一个点是否休息**来进行处理，我们如果在**下一个点休息**，那么我们就有 $dist[i][j]\to dist[v][0]+a[v]$。之后，我们还有一个操作是根据我们的下一个阶段如果不休息，那么我们就有 $dist[i][j]\to dist[v][j+1]+1$.

```
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
const int INF = 0x3f3f3f3f3f3f3f3f;
using namespace std;
typedef pair<int, int> PII;
typedef pair<int, PII> PIII;

void init()
{
    // 初始化代码
}

const int N = 2e5 + 10;
vector<int> edge[N];
int dist[N][15];

void solve()
{
    int n, m, k; 
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
    {
        edge[i].clear();
        for (int j = 0; j <= k; j++)
        {
            dist[i][j] = INF;
        }
    }
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        cin >> u >> v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }

    priority_queue<PIII, vector<PIII>, greater<PIII>> heap;
    if(k!=0){
        dist[1][1]=1;
        heap.push({dist[1][1],{1,1}});
    }
    dist[1][0] = a[1];
    heap.push({dist[1][0], {1, 0}});
    while (!heap.empty())
    {
        auto [d, p] = heap.top();
        heap.pop();
        auto [u, states] = p;
        for (auto v : edge[u])
        {
            if (states + 1 <= k)
            {
                if (dist[v][states + 1] > dist[u][states] + 1)
                {
                    dist[v][states + 1] = dist[u][states] + 1;
                    heap.push({dist[v][states + 1], {v, states + 1}});
                }
            }
            if (dist[v][0] > dist[u][states] + a[v])
            {
                dist[v][0] = dist[u][states] + a[v];
                heap.push({dist[v][0], {v, 0}});
            }
        }
    }
    int res = INF;
    for (int i = 0; i <= k; i++)
    {   
        res = min(res, dist[n][i]);   
    }
    cout << res << endl;
}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    int t;
    t = 1;
    cin >> t;
    init();
    while (t--)
    {
        solve();
    }
    return 0;
}
```