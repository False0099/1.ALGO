# [USACO 05 DEC] Knights of Ni S

## 题目描述

贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。

当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x, y$ 轴上的单位长度划分成了 $W \times H\  ( 1 \leq W, H \leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。

贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。

## 输入格式

第一行输入 $2$ 个用空格隔开的整数，即题目中提到的 $ W, H $。

接下来输入贝茜持有的地图，每一行用若干个数字代表地图上对应行的地形。第一行描述了地图最北的那一排土地；最后一行描述的则是最南面的。相邻的数字所对应的区域是相邻的。如果地图的宽小于或等于 $40$，那每一行数字恰好对应了地图上的一排土地。如果地图的宽大于 $40$，那每行只会给出 $40$ 个数字，并且保证除了最后一行的每一行都包含恰好 $40$ 个数字。没有哪一行描述的区域分布在两个不同的行里。

地图上的数字所对应的地形：

- $0$：贝茜可以通过的空地；
- $1$：由于各种原因而不可通行的区域；
- $2$：贝茜现在所在的位置； 
- $3$：骑士们的位置；
- $4$：长着贝茜需要的灌木的土地。

## 输出格式

输出一个正整数，即贝茜最少要花多少天才能完成骑士们给的任务。

## 样例 #1

### 样例输入 #1

```
8 4
4 1 0 0 0 0 1 0
0 0 0 1 0 1 0 0
0 2 1 1 3 0 4 0
0 0 0 4 1 1 1 0
```

### 样例输出 #1

```
11
```

## 提示

这片森林的长为 $8$，宽为 $4$ ．贝茜的起始位置在第 $3$ 行，离骑士们不远。

贝茜可以按这样的路线完成骑士的任务：北，西，北，南，东，东，北，东，东，南，南。她在森林的西北角得到一株她需要的灌木，然后绕过障碍把它交给在东南方的骑士。

## 题解
我们本题的最优解是状态压缩加上最短路，我们这一题是类似于我们拯救大兵瑞恩的哪一题，我们需要先设置一维表示我们收集到的钥匙的情况，然后我们就需要用我们的 BFS 来更新我们每一次的状态，当我们走到了一个 (x, y, S)时，如果 (x, y)位置正好有我们的药时，我们就来更新我们的 S，
```cpp
#include<cstdio>
const int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
const int MAXN=1000+10;
int map[MAXN][MAXN];
struct Node{
	int x,y;
	bool tag;
	//tag 记录是否已取得灌木。
}que[MAXN*MAXN];
Node make(int x,int y,bool tag){
	Node t;
	t.x=x,t.y=y;
	t.tag=tag;
	return t;
}
int l,r;
int dis[MAXN][MAXN][2];
bool vis[MAXN][MAXN][2];
int ex,ey;
int main(){
	int w,h;
	scanf("%d%d",&w,&h);
	for(int i=1;i<=h;++i){
		for(int j=1;j<=w;++j){
			scanf("%d",&map[i][j]);
			if(map[i][j]==2){
				que[r++]=make(i,j,false);
				vis[i][j][0]=true;
			}
			if(map[i][j]==3){
				ex=i,ey=j;
			}
			//处理起点与终点。
		}
	}
	for(int i=1;i<=h;++i){
		map[i][0]=map[i][w+1]=1;
	}
	for(int j=1;j<=w;++j){
		map[0][j]=map[h+1][j]=1;
	}
	//处理边界。
	while(l!=r){//bfs
		Node t=que[l++];
		int x=t.x,y=t.y;
		bool tag=t.tag;
		if(x==ex&&y==ey&&tag){
			break;
		}
		//到达终点且取得灌木才能结束。
		for(int i=0;i<4;++i){
			int u=x+dx[i],v=y+dy[i];
			bool w=tag||(map[u][v]==4);
			//若此前已取得灌木，或当前位置长有灌木，则当前状态下已取得灌木。
			if(!vis[u][v][w]&&map[u][v]!=1){
				dis[u][v][w]=dis[x][y][tag]+1;
				vis[u][v][w]=true;
				que[r++]=make(u,v,w);
			}
		}
	}
	printf("%d",dis[ex][ey][1]);
	return 0;
}
```
