# 黑匣子

## 题目描述

Black Box 是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量 $i$。最开始的时候 Black Box 是空的．而 $i=0$。这个 Black Box 要处理一串命令。

命令只有两种：

- `ADD(x)`：把 $x$ 元素放进 Black Box;

- `GET`：$i$ 加 $1$，然后输出 Black Box 中第 $i$ 小的数。

记住：第 $i$ 小的数，就是 Black Box 里的数的按从小到大的顺序排序后的第 $i$ 个元素。

我们来演示一下一个有 11 个命令的命令串。（如下表所示）

| 序号 | 操作 | $i$ | 数据库 | 输出 |
| :--: | :--- | :------: | ------ | :----: |
|   1  | `ADD(3)`     |   $0$    |  $3$  | / |
|   2  | `GET` |   $1$    |  $3$  | $3$ |
|   3  | `ADD(1)` | $1$ | $1,3$ |/|
|   4  | `GET` | $2$ | $1,3$ | $3$ |
|   5  | `ADD(-4)` | $2$ | $-4,1,3$ |/|
|   6  | `ADD(2)` | $2$ | $-4,1,2,3$ |/|
|   7  | `ADD(8)` | $2$ | $-4,1,2,3,8$ |/|
|   8  | `ADD(-1000)` | $2$ | $-1000,-4,1,2,3,8$ |/|
|   9  | `GET` | $3$ | $-1000,-4,1,2,3,8$ | $1$ |
|  10  | `GET` | $4$ | $-1000,-4,1,2,3,8$ | $2$ |
|  11  | `ADD(2)` | $4$ | $-1000,-4,1,2,2,3,8$ |/|

现在要求找出对于给定的命令串的最好的处理方法。`ADD` 命令共有 $m$ 个，`GET` 命令共有 $n$ 个。现在用两个整数数组来表示命令串：

1. $a_1,a_2,\cdots,a_m$：一串将要被放进 Black Box 的元素。例如上面的例子中 $a=[3,1,-4,2,8,-1000,2]$。

2. $u_1,u_2,\cdots,u_n$：表示第 $u_i$ 个元素被放进了 Black Box 里后就出现一个 `GET` 命令。例如上面的例子中 $u=[1,2,6,6]$ 。输入数据不用判错。

## 输入格式

第一行两个整数 $m$ 和 $n$，表示元素的个数和 `GET` 命令的个数。

第二行共 $m$ 个整数，从左至右第 $i$ 个整数为 $a_i$，用空格隔开。

第三行共 $n$ 个整数，从左至右第 $i$ 个整数为 $u_i$，用空格隔开。

## 输出格式

输出 Black Box 根据命令串所得出的输出串，一个数字一行。

## 样例 #1

### 样例输入 #1

```
7 4
3 1 -4 2 8 -1000 2
1 2 6 6
```

### 样例输出 #1

```
3
3
1
2
```

## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n,m \leq 10^{4}$。
- 对于 $50\%$ 的数据，$1 \leq n,m \leq 10^{5}$。
- 对于 $100\%$ 的数据，$1 \leq n,m \leq 2 \times 10^{5},|a_i| \leq 2 \times 10^{9}$，保证 $u$ 序列单调不降。

## 题解
我们本题考虑使用一种数据结构：对顶堆。
所谓的对顶堆，就是同时维护我们的两个堆，一个大根堆，一个小根堆。我们的大根堆维护我们的堆顶，保证我们的堆顶是一个是我们的所有数当中的第 i+1 小的数字。我们的**小根堆里存放我们的第 $k$ 大的数字**。

我们考虑怎么维护我们的对顶堆。因为我们要维护动态的 k，因此，我们分类讨论。
当我们的数字增大时，我们就根据我们的大小，决定我们应该插入的位置是哪里。如果**比我们的第k 大元素小**，我们就把我们的大根堆（前 k 大）的堆顶弹出，然后让他放入到我们的小根堆当中。
之后，我们再把我们新增的元素放入到我们的大根堆当中。

如果我们的新增元素比我们的第 k 大元素还要大，那么我们就直接放入到我们的小根堆当中去。

当我们的数字
当我们的 $k=0$ 时，我们不需要输出，这个时候，我们可以吧我们的所有的元素**都放到我们的小根堆**中，于是，在下一次查询的时候，我们就可以直接输出我们的小根堆的数值即可。

当我们的 k 要从我们的 0 变化到我们的 1 的时候，我们现在的小根堆堆顶显然不满足我们的要求，这个时候，我们就可以把我们的**小根堆堆顶元素弹出**放到我们的**大根堆**当中去，然后这个时候，我们的大根堆堆顶就满足我们的第 $i+1$ 小。

```cpp
#include <cstdio>
#include <queue>
#define Qmax priority_queue<int>
#define Qmin priority_queue<int,vector<int>,greater<int> >
#define f(i , a , b) for(int i=(a) ; i <= (b) ; i++)
using namespace std;
inline int Input(){
    char C=getchar();
    int N=0 , F=1;
    while(('0' > C || C > '9') && (C != '-')) C=getchar();
    if(C == '-') F=-1 , C=getchar();
    while('0' <= C && C <= '9') N=(N << 1)+(N << 3)+(C - 48) , C=getchar();
    return F*N; 
} //骗时间的读入优化 QAQ
int main(){
    int a[200001];
    Qmax A;
    Qmin B;
    int n=Input() , m=Input() , r=1 , q;
    f(i , 1 , n) a[i]=Input();
    f(i , 1 , m){
        q=Input();
        f(j , r , q){
            A.push(a[j]);
            if(A.size() == i) B.push(A.top()) , A.pop(); //超过大小，移除元素
        }
        r=q+1;
        printf("%d\n" , B.top()); //输出每次 GET 的答案
        A.push(B.top()) , B.pop(); //为下一次的 GET 作准备，填满小顶堆的空间
    }
    return 0;
}
```