# [ABC 359 E] Water Tank

## 题面翻译

给你一个长度为 $N$ 的正整数序列 $H$，下标从 $1$ 到 $n$。

有一个长度为 $N+1$ 的非负整数序列 $A$，下标从 $0$ 到 $n$，初始时 $A_i=0$。

重复进行以下操作：
1. $A_0\leftarrow A_0+1$；
2. 从 $1$ 到 $n$ 按顺序枚举 $i$ 若 $A_{i-1}>A_i$ 且 $A_{i-1}>H_i$，则 $A_{i-1}\leftarrow A_{i-1}-1,A_i\leftarrow A_i+1$。

求对于每个 $i=1,2,\ldots,N$，使 $A_i>0$ 最少的操作次数。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc359/tasks/abc359_e

長さ $ N $ の正整数列 $ H=(H\ _\ 1, H\ _\ 2,\dotsc, H\ _\ N) $ が与えられます。

長さ $ N+1 $ の非負整数列 $ A=(A\ _\ 0, A\ _\ 1,\dotsc, A\ _\ N) $ があります。 はじめ、$ A\ _\ 0=A\ _\ 1=\dotsb=A\ _\ N=0 $ です。

$ A $ に対して、次の操作を繰り返します。

1. $ A\ _\ 0 $ の値を $ 1 $ 増やす。
2. $ i=1,2,\ldots, N $ に対して、この順に次の操作を行う。
  - $ A\ _\ {i-1}\gt\ A\ _\ i $ かつ $ A\ _\ {i-1}\gt\ H\ _\ i $ のとき、$ A\ _\ {i-1} $ の値を $ 1 $ 減らし、$ A\ _\ i $ の値を $ 1 $ 増やす。
 
$ i=1,2,\ldots, N $ のそれぞれに対して、初めて $ A\ _\ i\ >\ 0 $ が成り立つのは何回目の操作の後か求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ H\ _\ 1 $ $ H\ _\ 2 $ $ \dotsc $ $ H\ _\ N $

## 输出格式

$ i=1,2,\ldots, N $ に対する答えを、空白を区切りとして $ 1 $ 行に出力せよ。

## 样例 #1

### 样例输入 #1

```
5
3 1 4 1 5
```

### 样例输出 #1

```
4 5 13 14 26
```

## 样例 #2

### 样例输入 #2

```
6
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
```

### 样例输出 #2

```
1000000001 2000000001 3000000001 4000000001 5000000001 6000000001
```

## 样例 #3

### 样例输入 #3

```
15
748 169 586 329 972 529 432 519 408 587 138 249 656 114 632
```

### 样例输出 #3

```
749 918 1921 2250 4861 5390 5822 6428 6836 7796 7934 8294 10109 10223 11373
```

## 提示

### ストーリー

> 長い水槽があり、高さの異なる板が等間隔に配置されています。高橋くんは、この水槽の端へ水を注いでいったとき、板で区切られたそれぞれの領域に水が到達する時刻が知りたいです。

### 制約

- $ 1\leq\ N\leq 2\times 10\ ^\ 5 $
- $ 1\leq\ H\ _\ i\leq 10\ ^\ 9\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ $ 5 $ 回の操作では以下のようになります。 それぞれの行が一回の操作に対応し、左端が $ 1 $ 番の操作を、それ以外が $ 2 $ 番の操作に対応します。 !\ [\](https://img.atcoder.jp/abc359/570466412318b9902952c408a421be0c.png) この図から、$ A\ _\ 1\gt 0 $ が初めて成り立つのは $ 4 $ 回目の操作の後、$ A\ _\ 2\gt 0 $ が初めて成り立つのは $ 5 $ 回目の操作の後です。同様にして、$ A\ _\ 3, A\ _\ 4, A\ _\ 5 $ に対する答えは $ 13,14,26 $ です。 よって、`4 5 13 14 26` を出力してください。

### Sample Explanation 2

出力すべき値が $ 32\operatorname{bit} $ 整数に収まらない場合があることに注意してください。


## 题解
本题我们考虑用我们的单调栈来处理，我们根据我们的图例能够很清楚的看出，我们的**某一个漕被填满，一定是由我们的左侧的第一个没有被填满的位置**到这里所有的元素都被填满后，我们再+1 得到的。

```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
int INF=0x3f3f3f3f3f3f3f3f;
using namespace std;
typedef pair<int,int> PII;
void init(){
    
}
void solve(){
    int n;
    cin>>n;
    vector<int> h(n+1);
    vector<int> ans(n+1,0);
    vector<int> sum(n,0);
    stack<int> stk;
    for(int i=1;i<=n;i++){
        cin>>h[i];
        //找到左侧第一个比当前还要高的元素
        while(stk.size()&&h[stk.top()]<=h[i]){
            stk.pop();
        }
        if(stk.size()){
            int prev_pos=stk.top();
            ans[i]=ans[prev_pos]+(i-prev_pos)*h[i];
        }else{
            ans[i]=h[i]*(i);
        }
        stk.push(i);
        cout<<ans[i]+1<<" ";
    }
    cout<<endl;
}
signed main(){
    ios::sync_with_stdio(false),cin.tie(0);
    int t;
    t=1;
    //cin>>t;
    init();
    while(t--){
        solve();
    }
}
```