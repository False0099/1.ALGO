# 奶牛排队

## 题目描述

奶牛在熊大妈的带领下排成了一条直队。

显然，不同的奶牛身高不一定相同……

现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。问这样的奶牛最多会有多少头？

从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 $0,2$，但不会是 $1$）。

## 输入格式

第一行一个正整数 $N$，表示奶牛的头数。

接下来 $N$ 行，每行一个正整数，从上到下表示从左到右奶牛的身高 $h_i$。

## 输出格式

一行一个整数，表示最多奶牛数。

## 样例 #1

### 样例输入 #1

```
5
1
2
3
4
1
```

### 样例输出 #1

```
4
```

## 提示

#### 样例解释

取第 $1$ 头到第 $4$ 头奶牛，满足条件且为最多。

#### 数据范围

对于全部的数据，满足 $2 \le N \le 10^5$，$1 \le h_i <2^{31}$。

## 题解
后缀极值：
第一级应用：求出我们最大的栈排序出栈序列（类似于我们的后缀数组求出我们的最大字典序）
第二级应用：转换为当前序列后缀极值，求出我们一个区间内满足端点极值的区间最大长度/个数。我们的思路是，把我们的区间端点的条件转换到我们的后缀数组上。

在本题中，我们考虑**固定我们的右端点** $R$，然后再考虑这个右端点对应的左端点可以有哪些。首先，为了满足我们的长度最大，我们的 $A$ 一定要尽可能的靠左。

同时，又因为我们的 $A$ 是我们的区间 $[A,B]$ 内的最小元素，所以我们就等价于要求我们的 $A$ 是 $[A,B]$ 这一段区间中**第一个比我们的 B 还要小的哪一个元素**。

我们知道，我们的**A 是随着我们的 A 的增大而越来越容易满足条件的**，也就是说如果我们的 $A$ 满足条件，我们的 $A+1$ 也满足条件。因此，我们可以**二分找到我们的对应的 A**。



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10; 
int a[N];
int maxtop;
int mintop;
int stkmax[N];
int stkmin[N];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		//stkmax维护了我们的能取到的元素的左边界在哪里 
		while(maxtop&&a[stkmax[maxtop]]<a[i]){
			maxtop--;
		}
		//stkmin维护了所有可能的集合对应的下标 
		while(mintop&&a[stkmin[mintop]]>=a[i]){
			mintop--;
		}
		//k就是找到stkmin范围内满足条件的下标 
		int k=upper_bound(stkmin+1,stkmin+1+mintop,stkmax[maxtop])-stkmin;
		
		if(k!=mintop+1){
			ans=max(ans,i-stkmin[k]+1);
		}
		stkmin[++mintop]=i;
		stkmax[++maxtop]=i;
	}
	cout<<ans<<endl;
}
```