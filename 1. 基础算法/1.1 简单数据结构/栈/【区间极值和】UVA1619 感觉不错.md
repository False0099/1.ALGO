# 感觉不错 Feel Good

## 题目背景

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=825&page=show_problem&problem=4494

[PDF](https://uva.onlinejudge.org/external/16/p1619.pdf)

## 题面翻译

题目大意：
给出正整数 n 和一个 (1 <= n <= 100 000)长度的数列，要求找出一个子区间，使这个子区间的数字和乘上子区间中的最小值最大。输出这个最大值与区间的两个端点。

## 题目描述

给出正整数 $n$ 和一个长度为 $n$ 的数列 $a$，要求找出一个子区间 $[l,r]$，使这个子区间的数字和乘上子区间中的最小值最大。

形式化的，要求找出 $[l,r]$ 使得：
$$
\left(\sum \limits_{i=l}^{r}a_i\right)\times\min\limits_{i=l}^{r}a_i
$$
最大。输出这个最大值与区间的两个端点。

在答案相等的情况下最小化区间长度，最小化长度的情况下最小化左端点序号。

## 输入格式

本题有多组数据。

每组数据的第一行是一个整数 $n$；
第二行是 $n$ 个非负整数 $a_i$。

两组数据之间用一个空行隔开。

## 输出格式

对于每组数据，第一行输出最大值，第二行输出区间左、右端点。

两组数据间用 **一个空行** 隔开。

**本题不忽略文末回车。**

## 样例 #1

### 样例输入 #1

```
6
3 1 6 4 5 2
```

### 样例输出 #1

```
60
3 5
```

## 提示

$1 \leq n \leq 10^5, 0 \leq a_i \leq 10^6$。

## 题解
我们本题要求的答案就是我们的 $\sum_{i=l}^ra[i]*min_{l\leq i\leq r}a[i]$，我们最最最最朴素的想法就是枚举我们的每一个区间，然后去 $o(1)$ 的求出我们的区间和和我们的区间最小值。

我们对于这一类区间问题有两类优化思路，一类固定一个端点，然后通过根据我们的性质来暴力的跳我们的指针，典型的就是求我们的区间 $mex$,或者我们的区间 $gcd$,暴力的跳到下一个会有改变的位置。

对于本体来说，上述的优化思路显然是不太可行的，于是我们考虑我们的第二种思路：枚举我们的某一个特殊值，然后用一种类似于“贡献”的想法，计算出我们某个值固定时，我们的答案最大会是多少。典型的就是求我们的 $max,min$ 区间。这里。

上面所说的做法显然是可行的，我们考虑枚举我们的最小值是多少，然后每一次计算相关的区间和是多少。并且由于我们本题中我们的 $a[i]$ 一定是大于 0 的，所以我们的区间越长，我们的答案也就更优。

那么现在我们的问题就变成，求我们以某个数为端点，左侧和右侧都比他要小的数在哪里。我们可以把我们的上面的问题拆分为两个问题，并且我们的两个问题都是独立的。我们对于我们的两侧分别使用我们的一个单调栈。我们每一次找到左侧第一个没被删除的元素，然后比较我们两者的大小，如果这个元素比我们的当前元素还要大，我们就干掉这一个元素，知道我们干不掉人了，或者我们已经空了，这个时候我们的栈顶就是我们的答案。
```cpp
vector<int> stk;
for(int i=0;i<n;i++){
	while(stk.size()&&stk.top()>a[i]){
		stk.pop();
	}
	ans[i]=stk.top();
	stk.push(a[i]);
}
```