# [XJTUPC 2024] 雪中楼

## 题目描述

西安交通大学下雪了，所有楼顶都被积雪覆盖。

在梧桐道上有 $n$ 座房子，自南向北第 $i$ 座房子的标号是 $i$，所有房子的高度互不相同。LNC 从南向北，依次登上每栋楼楼顶，然后他会回头观察他已经到达过的房子，并记录下这些房子中，比当前他所在房子矮的所有房子中，最高的房子的编号，记为 $a_i$。特殊的，当没有房子比当前房子矮的时候，$a_i=0$。

现在给你所有的 $a_i$，要求你还原出所有楼的大小关系。由于高度的具体值未知，你只需要按照高度从低到高，输出房子编号。

可以证明对于任何合法的输入，均存在唯一解。

## 输入格式

输入第一行一个正整数 $n$ ($1\le n \le 2\times 10^5$)，代表房子个数。

接下来一行 $n$ 个非负整数 $a_i$，满足 $0\le a_i <i$，两两之间用空格隔开。

## 输出格式

输出一行 $n$ 个正整数构成的排列，用空格隔开，表示最终的答案。

## 样例 #1

### 样例输入 #1

```
5
0 0 0 0 2
```

### 样例输出 #1

```
4 3 2 5 1
```

## 提示

假设高度是一个 $1\sim n$ 的排列，那么可以发现高度为 $5, 3, 2, 1, 4$ 是唯一的解，按照高度排名输出得到 $4, 3, 2, 5, 1$。

## 题解
我们注意到，本题我们如果对于一个位置，他有一个潜质的关系 $x$,那么我们的这一个一定是连接到我们的这一个关系的前面，而我们的最后的顺序也就是我们构成的那一个链表的顺序。
```
#include <bits/stdc++.h>
using namespace std;
vector<int> p[200005];
int ind[200005], n, x;
void topo() {
    priority_queue<int> q;
    for(int i = 1; i <= n; i++) if(!ind[i]) q.push(i);
    while(!q.empty()) {
        int u = q.top();
        q.pop();
        cout << u << " ";
        for(auto v : p[u]) {
            if(!--ind[v])
                q.push(v);
        }
    }
}
signed main()
{
    cin >> n >> x;
    for(int i = 2; i <= n; i++) {
        cin >> x;
        if(!x) p[i].push_back(i-1), ind[i-1]++;
        else p[x].push_back(i), ind[i]++;
    }
    topo();
    return 0;
}

```