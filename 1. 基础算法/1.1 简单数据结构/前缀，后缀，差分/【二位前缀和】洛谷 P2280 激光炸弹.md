# [HNOI 2003] 激光炸弹

## 题目描述

一种新型的激光炸弹，可以摧毁一个边长为 $m$ 的正方形内的所有目标。现在地图上有 $n$ 个目标，用整数 $x_i$ , $y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $v_i$ .激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为 $m$ 的边必须与 $x$ 轴, $y$ 轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。

现在你的任务是计算一颗炸弹最多能炸掉地图上总价值为多少的目标。

## 输入格式

输入的第一行为整数 $n$ 和整数 $m$，

接下来的 $n$ 行，每行有 $3$ 个整数 $x, y, v$，表示一个目标的坐标与价值。

## 输出格式

输出仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过 $32767$ ）。

## 样例 #1

### 样例输入 #1

```
2 1
0 0 1
1 1 1
```

### 样例输出 #1

```
1
```

## 提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \le n \le 10^4$，$0 \le x_i ,y_i \le 5\times 10^3$，$1 \le m \le 5\times 10^3$，$1 \le v_i < 100$。


## 题解
本题是我们二维差分的模板题目，

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, s[5010][5010];
// 因为空间较为紧张，这里只用了一个数组，计算出前缀和后原数组直接被覆盖

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i ++) {
		int x, y, v;
		cin >> x >> y >> v;
		s[x + 1][y + 1] += v;	// 将横纵坐标都加一，坐标范围变成 [1, 5001]，避免越界
	}
	
	int N = 5001; // N 为坐标范围
    // 方法一
	for (int i = 1; i <= N; i ++)
		for (int j = 1; j <= N; j ++)
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j];
/*	
	// 方法二
	for (int i = 1; i <= N; i ++)
		for (int j = 1; j <= N; j ++) s[i][j] += s[i][j - 1];
	for (int j = 1; j <= N; j ++)
		for (int i = 1; i <= N; i ++) s[i][j] += s[i - 1][j];
	*/
	
	int ans = 0;
	for (int i = m; i <= N; i ++)
		for (int j = m; j <= N; j ++) {
			int num = s[i][j] - s[i - m][j] - s[i][j - m] + s[i - m][j - m];
            // num 为以 (i, j) 为右下角的边长为 m 的正方形区域中的目标价值之和
			ans = max(ans, num);
            // 用 num 更新答案
		}
	
	cout << ans << endl;
	
	return 0;
}
```