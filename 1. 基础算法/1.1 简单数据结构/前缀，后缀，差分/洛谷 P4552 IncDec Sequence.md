# [Poetize 6] IncDec Sequence

## 题目描述

给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间 $[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 
  
请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。

## 输入格式

第一行一个正整数 $n$   
接下来 $n$ 行, 每行一个整数, 第 $i+1 $行的整数表示 $a_i$。

## 输出格式

第一行输出最少操作次数   
第二行输出最终能得到多少种结果

## 样例 #1

### 样例输入 #1

```
4
1
1
2
2
```

### 样例输出 #1

```
1
2
```

## 提示

对于 $100\%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。

## 题解
我们这一题只需要按照计算出，我们每一个元素之间的差得到我们的差分数组，对于这个差分数组，我们就有下面几种操作：
1. 选择一个正数和一个负数，使得正数-1，负数+1，经过 N 次操作，我们一定可以以最少的代价把绝对值较小的一方归零，代价为 $|min(X,Y)|$,
2. 选取一个整数，使其与 $S[1]$ 配对，这样，经过 N 次操作，一定可以归零，代价为 $|abs(X)|$,

于是，我们先进行政府相消的工作，例如：$c=(4,-2,-1,5,-3)$,我们就可以通过一同操作变化为 $(0,0,0,0,3)$,最后，我们再去处理这个 3 即可。公式如下所示：

经过上面的分析，我们就能推导出我们的解题公式
$ans=abs(min(X,Y)+abs(X-Y))=abs(\max(X,Y))$

```cpp
```cpp
#include<bits/stdc++.h>

using namespace std;
int n,a[100005],k;//totz ÕýÊý totf ¸ºÊý 
ll totz,totf,c[100005];
int main()
{
    read(n);
    for(ri i=1;i<=n;i++) read(a[i]);//读入
    c[1]=a[1];//计算差分数组
    for(ri i=2;i<=n;i++)//计算正数和负数的和
    {
        c[i]=a[i]-a[i-1];
        if(c[i]>0) totz+=c[i];
        else totf-=c[i];//注意这里是减号，毕竟是负数
    }
    printf("%lld\n%lld",max(totz,totf),abs(totz-totf)+1);//输出咯
    return 0;
}
```
```