# [ZJOI 2007] 棋盘制作

## 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？

## 输入格式

包含两个整数 $N$ 和 $M$，分别表示矩形纸片的长和宽。接下来的 $N$ 行包含一个 $N\times M$ 的 $01$ 矩阵，表示这张矩形纸片的颜色（$0$ 表示白色，$1$ 表示黑色）。

## 输出格式

包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。

## 样例 #1

### 样例输入 #1

```
3 3
1 0 1
0 1 0
1 0 0
```

### 样例输出 #1

```
4
6
```

## 提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$

## 题解
我们本体仍然是悬线法的应用，不过本题我们需要注意下面的几个坑点：第一个是在我们的 left 和我们的 right 更新的时候，一定要满足：我们的这两个位置对应的各自是不相同的。

另外一点是语法上的问题，因为我们可能初始化的时候每一个值都设置为 0，所以我们在更新的时候要注意我们的边界条件的时候是不能够进行更新的。

于是，我们就可以通过我们的悬线法来计算得到我们的最终答案。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1010;
int g[N][N];
int lef[N][N];
int righ[N][N];
int up[N][N];
//1表示可以选 
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>g[i][j];
			lef[i][j]=j;
			righ[i][j]=j;
			up[i][j]=1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(g[i][j]!=g[i][j-1]&&j!=1){
				lef[i][j]=lef[i][j-1];
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			if(g[i][j]!=g[i][j+1]&&j!=m){
				righ[i][j]=righ[i][j+1];
			}
		}
	}
	int ans1=0;
	int ans2=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(g[i][j]!=g[i-1][j]&&i!=1){
				lef[i][j]=max(lef[i][j],lef[i-1][j]);
				righ[i][j]=min(righ[i][j],righ[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
			if(g[i][j]!=g[i-1][j]&&i!=1){
				ans1=max(ans1,min(up[i][j],righ[i][j]-lef[i][j]+1)*min(up[i][j],righ[i][j]-lef[i][j]+1));	
				ans2=max(ans2,up[i][j]*(righ[i][j]-lef[i][j]+1));
			}
		}
	}
	cout<<ans1<<endl;
	cout<<ans2<<endl;
} 
```