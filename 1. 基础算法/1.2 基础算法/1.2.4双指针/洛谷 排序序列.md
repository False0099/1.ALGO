# 知识点
  ## [[双指针]]
# 题目
 # 「EZEC-10」排列排序

## 题目描述

给你一个长度为 $n$ 的排列 $p_1,p_2, \cdots ,p_n$。你需要把它排序。

每次可以花区间长度，即 $r-l+1$ 的代价，选择排列中的任意一段区间 $[l,r]$，并将 $[l,r]$ 从小到大排序。

现在你可以让他进行若干次这个操作，直到 $p$ 中元素的值从 $1$ 到 $n$ 按升序排序，即对于 $1$ 到 $n$ 的每一个 $i$，都有 $p_i=i$。

求问花的代价最少为多少？

## 输入格式

本题有多组询问，第一行有一个数 $T$ 表示询问组数。

对于每组询问：

第一行给出一个整数 $n$。

第二行 $n$ 个整数，由空格隔开，代表排列 $p$ 中元素的值。

## 输出格式

$T$ 行，每行一个整数表示一组询问的答案。

## 样例 #1

### 样例输入 #1

```
2
3
1 3 2
4
3 2 1 4
```

### 样例输出 #1

```
2
3
```

## 提示

【样例 $1$ 说明】

对于第一组数据，可选择区间 $[2,3]$ 进行排序。

对于第二组数据，可选择区间 $[1,3]$ 进行排序。

【数据规模与约定】

对于 $20\%$ 的数据，$n\leq 4$。

对于另 $30\%$ 的数据，$\sum n\leq5000$。

对于另 $10\%$ 的数据，$p_1=n$。

对于 $100\%$ 的数据，$1\le T,\sum n\le 10^6$。

# 思路
·我们不妨考虑怎样去选择区间才能做到最小代价，然后我们不难想到这样的贪心做法：如果一段区间 $l-r$ 里面的所有数是一个 $l-r$ 的一种排列并且区间长度不为 1（长度为 1 的话不需要花费 1 的代价去升序排列这个区间），那么我们就立即选择这一个区间翻转，并更新下一个需要翻转的区间的左端点。这样可以保证花费的代价是最小的。
·
·
# AC 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[1000005];

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int n, ans = 0;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
        int i = 1;
        while (i <= n)
        {
            if (a[i] == i) 
                i++;
            else 
            {
                int maxv = a[i];
                int j = i + 1;
                maxv = max(maxv, a[j]);
                while (maxv > j)
                {
                    j++;
                    maxv = max(maxv, a[j]);
                }
                //找到区间l,r使得区间中的最大最小也恰好是l,r
                ans += j - i + 1;
                i = j + 1;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```
# 备注
