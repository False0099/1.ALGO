# 【模板】三分法

## 题目描述

如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。

## 输入格式

第一行一次包含一个正整数 $N$ 和两个实数 $l, r$，含义如题目描述所示。

第二行包含 $N + 1$ 个实数，从高到低依次表示该 $N$ 次函数各项的系数。

## 输出格式

输出为一行，包含一个实数，即为 $x$ 的值。若你的答案与标准答案的相对或绝对误差不超过 $10^{-5}$ 则算正确。

## 样例 #1

### 样例输入 #1

```
3 -0.9981 0.5
1 -3 -3 1
```

### 样例输出 #1

```
-0.41421
```

## 提示

对于 $100\%$ 的数据，$6 \le N \le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\leq 10$ 且至多 $15$ 位小数。$l\leq r$。

**【样例解释】**

 ![](https://cdn.luogu.com.cn/upload/pic/2297.png) 

如图所示，红色段即为该函数 $f(x) = x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。

当 $x = -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x = -0.41421$，输出 $-0.41421$。

## 题解
我们三分法的关键就是设置两个指针，一个指针指向我们的极小值一侧，另一个指针指向我们的极大值一侧。我们只需要比较我们两个值的大小，就可以得到我们的结果。在我们实现的时候，我们可以**采用类似于二分的优化方法，最后的复杂度转化为二分的**

需要注意的是，我们的三分法只能在**确保我们的区间是单凸型，我们才可以用我们的三分。

我们的**二分只能在确保单调的时候使用**

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-7;//其实一般精度*0.1=1e-6就可以了
int n;
double L,R;
double a[15];
//普通的求多项式

//秦九韶算法从里到外逐层计算一次多项式的值
double F(double x)
{
 double sum=0;
 for(int i=n;i>=0;i--)
 sum=sum*x+a[i];
 return sum; 
}
int main()
{
 cin>>n>>L>>R;
 for(int i=n;i>=0;i--) cin>>a[i];
 while(fabs(L-R)>=eps)
 {
  double mid=(L+R)/2;
  if(F(mid+eps)>F(mid-eps)) L=mid;//舍弃左区间
  else R=mid;//舍弃右区间
 }
 printf("%.5lf",R);
 return 0;
}
```