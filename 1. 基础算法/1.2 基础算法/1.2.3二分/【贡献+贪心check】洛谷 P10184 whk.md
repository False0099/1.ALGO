# [YDOI R 1] whk

## 题目背景

小 Z ~~只~~考了年级第六，要卷 whk 了。

## 题目描述

小 Z 一共要卷 $n$ 门科目，第 $i$ 门科目他有且只有 $a_i$ 道题。有无数天时间，每天小 Z 可以做无数道题。

如果小 Z 认为一天是有趣的，仅当他在这一天**至少**做了 $t$ 门科目的题。

小 Z 想知道最多有多少天是有趣的。

## 输入格式

第一行，$2$ 个正整数 $n,t$。

接下来一行，有 $n$ 个整数，分别 $a_1,a_2,a_3,\dots,a_{n-1},a_n$。

## 输出格式

一个整数，输出小 Z 认为有趣的天数的最大值。

## 样例 #1

### 样例输入 #1

```
5 3 
3 2 5 1 1
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
6 4 
1 1 4 5 1 4
```

### 样例输出 #2

```
3
```

## 提示

**本题采用捆绑测试**。
| 子任务编号 | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| $1$ | $1000$ | $1000$ | 无 | $20$ | 
| $2$ | $5\times10^5$ | $10^5$ | $t=1$ | $10$ |  
| $3$ | $5\times10^5$ | $1$ | 所有 $a_i$ 值都为 $1$ | $10$ |  
| $4$ | $5\times10^5$ | $10^6$ | 无 | $60$ |   



对于所有数据，$1\le t\le n\le5\times10^5$，$1\le a_i \le 10^6$。

## 题解
我们本题的思路是二分：我们想要直接计算哪些取，哪些不取的时候我们显然是不太好计算的，因为我们可能存在一些边界情况，是不满足我们的贪心的。

于是，对于这种看似可以贪心，实际上边界条件很多的题目，我们考虑能不能二分。我们考虑我们的下面的方法：我们枚举我们现在有 $k$ 天是满足要求的，我们的 check 方法应该按照如下的策略：

我们有一下结论：**如果一个方案可行，当且仅当它的贡献值和大于 $k*t$,其中贡献定义为 $min(a[i], k)$。

如何判定一个 $k$ 是否满足条件呢？我们已经知道了让有趣天数尽可能多的刷题策略。在这种策略下，由于每天每科目只刷一道题，所以一个科目 $k$ 天内至多刷 $k$ 道题。不足的自然能有几道刷几道，超过的最多就能刷 $k$ 道。又根据策略，$k$ 天刷且仅刷 $kt$ 道题。我们算一下每个科目 $k$ 天的过题数之和是否超过了下限即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[1000005],sum;
bool check(long long k){
    long long cnt=0;
    for(int i=1;i<=n;i++){
        if(a[i]>=k) cnt+=k;
        else cnt+=a[i];
    }
    return cnt>=k*m;//判断有没有超过（够不够刷）
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){ cin>>a[i];sum+=a[i]; }
    long long l=0,r=sum,mid,k=0;//!下限天数为0!
    while(l<=r){
        mid=(l+r)>>1;
        if(check(mid)) l=mid+1,k=mid;
        else r=mid-1;
    }
    cout<<k;
    return 0;
}
```