# [USACO18OPEN] Talent Show G

## 题目描述

Farmer John 要带着他的 $n$ 头奶牛，方便起见编号为 $1\ldots n$，到农业展览会上去，参加每年的达牛秀！他的第 $i$ 头奶牛重量为 $w_i$，才艺水平为 $t_i$，两者都是整数。

在到达时，Farmer John 就被今年达牛秀的新规则吓到了：

（一）参加比赛的一组奶牛必须总重量至少为 $W$（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。

（二）总才艺值与总重量的比值最大的一组获得胜利。

FJ 注意到他的所有奶牛的总重量不小于 $W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。

## 输入格式

第一行是两个整数，分别表示牛的个数 $n$ 和总重量限制 $W$。

第 $2$ 到 $(n+1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 头奶牛的重量 $w_i$ 和才艺水平 $t_i$。

## 输出格式

请求出 Farmer 用一组总重量最少为 $W$ 的奶牛最大可能达到的总才艺值与总重量的比值。

如果你的答案是 $A$，输出 $1000A$ 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。

## 样例 #1

### 样例输入 #1

```
3 15
20 21
10 11
30 31
```

### 样例输出 #1

```
1066
```

## 提示

#### 样例解释

在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为 $11$、重量为 $10$ 的奶牛，但是由于我们需要至少 $15$ 单位的重量，最优解最终为使用这头奶牛加上才艺值为 $21$、重量为 $20$ 的奶牛。这样的话才艺与重量的比值为 $\frac{11+21}{10+20}=\frac{32}{30} = 1.0666\dots$，乘以1000向下取整之后得到 $1066$。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 250$，$1 \leq W \leq 1000$，$1 \leq w_i \leq 10^6$，$1 \leq t_i \leq 10^3$。

### 题解
本题与基本的0/1分数规划类似，只不过原本的0-1分数规划的限制条件是$\sum{si}=k$,而我们现在的限制条件变成了$\sum{wi*si}\geq W$，所以我们仍然可以套用0-1分数规划的做法。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int INF=0x3f3f3f3f,N=255,WW=1005;

int n,W;

struct{int w, t; double y;}cow[N];

double  dp[WW]; //dp[i],背包容量为i时最大的价值(y值之和)

bool check(double x){         // 0/1背包

     int i,j;

     for(i=1;i<=n;i++) cow[i].y=(double)cow[i].t-x*cow[i].w;

     for(i=1;i<=W;i++) dp[i]=-INF; //初始化为负无穷小

     dp[0] = 0;               //背包容量为0时价值为0

     for(i=1;i<=n;i++)

         for(j=W;j>=0;j--){   // 滚动数组

             if(j+cow[i].w>=W)  dp[W]=max(dp[W],dp[j]+cow[i].y); //大于W时按W算

            else               dp[j+cow[i].w]=max(dp[j+cow[i].w],dp[j]+cow[i].y);

         }

     return dp[W]<0;          // dp[W] < 0，x大了；= dp[W] ≥ 0，x小了

}

int main(){

cin>>n>>W;

for(int i=1;i<=n;i++)   cin>>cow[i].w>>cow[i].t;

    double L=0,R=0;

    for (int i = 1; i <= n; i++)  R += cow[i].t;  //R的初值

for(int i=0;i<50;i++){

double mid = L+(R-L)/2;

if(check(mid)) R = mid;  //缩小

else           L = mid;  //放大

}

cout<<(int)(L*1000)<<endl;

return 0;

}
```