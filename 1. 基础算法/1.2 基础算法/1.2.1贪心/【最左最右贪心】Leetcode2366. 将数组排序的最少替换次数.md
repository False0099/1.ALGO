# 2366. 将数组排序的最少替换次数
给你一个下标从 **0** 开始的整数数组 `nums` 。每次操作中，你可以将数组中任何一个元素替换为 **任意两个** 和为该元素的数字。
- 比方说，`nums = [5,6,7]` 。一次操作中，我们可以将 `nums[1]` 替换成 `2` 和 `4` ，将 `nums` 转变成 `[5,2,4,7]` 。

请你执行上述操作，将数组变成元素按 **非递减** 顺序排列的数组，并返回所需的最少操作次数。

 

**示例 1：**

```
输入：nums = [3,9,3]
输出：2
解释：以下是将数组变成非递减顺序的步骤：
- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] 
- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] 
总共需要 2 步将数组变成非递减有序，所以我们返回 2 。
```

**示例 2：**

```
输入：nums = [1,2,3,4,5]
输出：0
解释：数组已经是非递减顺序，所以我们返回 0 。
```

 

**提示：**
- `1 &lt;= nums.length &lt;= 105`
- `1 &lt;= nums[i] &lt;= 109`

## 题解
本题，我们的一个观察是，我们对于我们的一个元素进行操作后，我们能够得到的最大值是不变的。于是，我们可以考虑让我们的**最右边的元素大小保持不变**，作为我们的数组的最终最大值。

然后，我们考虑从后往前进行操作，每一次操作后让我们的**最小值尽可能的大**，并且分割后的最大值不超过我们的上一个的最小值。
```
class Solution {
public:
    long long minimumReplacement(vector<int> &nums) {
        long ans = 0L;
        int m = nums.back();
        for (int i = int(nums.size()) - 2; i >= 0; --i) {
            int k = nums[i] - 1) / m;
            ans += k;
            m = nums[i] / (k + 1);
        }
        return ans;
    }
};
```