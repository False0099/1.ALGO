# 题目
 # [USACO 07 JAN] Tallest Cow S

## 题面翻译

**【题目描述】**

FarmerJohn 有 n 头牛，它们按顺序排成一列。FarmerJohn 只知道其中最高的奶牛的序号及它的高度，其他奶牛的高度都是未知的。现在 FarmerJohn 手上有 $R$ 条信息，每条信息上有两头奶牛的序号（$a$ 和 $b$），其中 $b$ 奶牛的高度一定大于等于 $a$ 奶牛的高度，且 $a, b$ 之间的所有奶牛的高度都比 $a$ 小。现在 FarmerJohn 想让你根据这些信息求出每一头奶牛的可能的最大的高度。（数据保证有解）

**【输入格式】**

第一行：四个以空格分隔的整数：$n, i, h, R$（$n$ 和 $R$ 意义见题面；$i$ 和 $h$ 表示第 $i$ 头牛的高度为 $h$，他是最高的奶牛）

接下来 $R$ 行：两个不同的整数 $a$ 和 $b$（$1 \le a, b \le n$）

**【输出格式】**

一共 $n$ 行，表示每头奶牛的最大可能高度.

**【数据范围】**

$1 \le n \le 10000$，$1 \le h \le 1000000$，$0 \le R \le 10000$

Translate provided by @酥皮


## 样例 #1

### 样例输入 #1

```
9 3 5 5
1 3
5 3
4 3
3 7
9 8
```

### 样例输出 #1

```
5
4
5
3
4
4
5
5
5
```

# 思路
***说实话，第一眼看上去比较像差分约束，感觉可以拿我们的差分约束的思路去构造一个图，我们要求每一头牛可能的最大高度，就等价于我们就图上距离的最短路。但这么做会爆掉，所以我们考虑其他的方法

***注意到，我们这一题是知道了最大牛的高度，所以我们不妨依次为突破口去模拟一边我们的全部过程. 我们采用贪心的思路去解决这个问题，如果我们没有任何限制，那么我们每头牛的最大高度就是最高牛的高度。如果我们给出了限制条件，我们可以显然的把限制条件转化为每一个区间内中间的数都统一减去 1。就这样，我们就能得到最后的答案。

**但我们还要注意要去判重，避免有重复的关系，因此我们还要加入一个 map 判重。

# AC 代码
```cpp
```cpp
#include <map>
#include <cstdio>
#include <algorithm>
using namespace std;

int loi[10005];

map<int,map<int,bool> > mmp;

int main()
{
	int n,i,h,r;
	scanf("%d%d%d%d",&n,&i,&h,&r);
	for(int i=1; i<=r; ++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(a>b)
		{
			swap(a,b);
		}

		if(!mmp[a][b])
		{
			mmp[a][b] = 1;
			--loi[a+1];
			++loi[b];
		}
	}

	int cur = 0;
	for(int i=1; i<=n; ++i)
	{
		cur += loi[i];
		printf("%d\n",h+cur);
	}
}
```
```
# 备注
