# 「GMOI R 1-T 4」Rain

## 题目背景

> **求雨**
>
>玉皇爷爷也姓张，
>
>为啥为难俺张*昌？
>
>三天之内不下雨，
>
>先扒龙皇庙，
>
>__再用大炮轰你娘。__

如果再不下雨，张大帅就会轰掉全亚洲所有的宗教场所！

博丽神社因为可以在外界被看到，自然也无法幸免于难，灵梦十分着急，准备使用祖传秘法求雨……

## 题目描述

为了防止神社被“大炮开兮轰他娘”，灵梦需要求雨。

求雨需要在一条笔直的路上建 $n$ 个法阵，编号为 $1,2,\cdots,n$。

给定一个长度为 $n$ 的数组 $a$，表示在 $a_1$ 到 $a_n$ 的位置建法阵，你要干的是给法阵编号。

灵梦需要来检测法阵效果，她会从 $1$ 号法阵走到 $2$ 号，从 $2$ 号再走到 $3$ 号，直到走到 $n$ 号，再从 $n$ 号走回 $1$ 号。

由于法阵的特殊效果，从 $i$ 个走到 $i+1$ 个的距离是 $\left|a_i\times p-a_{i+1}\times q\right|$。特别的，从 $n$ 号走回到 $1$ 号的距离是 $\left|a_n\times p-a_1\times q\right|$。$p,q$ 是给定的两个常数，$a_i,a_{i+1}$ 是两个法阵的位置。

灵梦希望你来求一下最大的行走距离，并输出对应法阵从 $1$ 号到 $n$ 号的位置排列。（多个只需输出一个即可）

## 输入格式

第一行一个整数 $n$，表示法阵数量。

第二行两个整数 $p,q$，表示法阵的倍率常量。

第三行 $n$ 个整数，表示数组 $a$。

## 输出格式

第一行一个整数，表示答案。

第二行 $n$ 个整数，表示对应位置 $a$ 的排列，按照编号从 $1$ 到 $n$ 输出。

## 样例 #1

### 样例输入 #1

```
10
2 3
1 2 3 4 5 6 7 8 9 10
```

### 样例输出 #1

```
131
5 6 7 1 8 2 9 3 10 4
```

## 提示

**本题开启 SPJ。**

**本题读入量较大，建议使用较快的读入方式。**

对于 $100\%$ 的数据满足 $10\le n\le 10^6$，$1\le p,q \le 10^{5}$，$1\le a_i\le 10^{5}$。

|     编号      |      $n$      |      $p,q$      |      $a_i$      |  分数  |
| :---------: | :-----------: | :-------------: | :-------------: | :--: |
|     $1$     |    $n=10$     | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $4$  |
|     $2$     |    $n=10$     | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $5$  |
|     $3$     |    $n=10$     | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $5$  |
|  $4\sim 6$  |    $n=19$     | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $10$ |
|     $7$     | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $8$  |
|     $8$     | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $9$  |
|     $9$     | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $9$  |
| $10\sim 12$ | $n\le 10^{6}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $10$ |
## 题解
**看到绝对值考虑先把绝对值拆掉再做题，对于你做题有很大好处。**

我们本体先考虑下面的一种特殊情况，如果我们的 $p=1,q=1$,这个时候，我们的问题就转换为了经典的 $\sum |a[i]-a[j]|$,这个时候，我们的结论显然是把我们的元素进行交错排序，也就是让我们的第一个取到最大，下一个取到最小以此类推。

我们考虑能不能把我们的上面的方法进行推广。首先，我们考虑把我们的 $pa[i]$,和 $qa[j]$ 分别计算贡献。我们当然希望我们最后是最大的 $N$ 个数做的是正贡献，剩下的 $N$ 个做的负贡献。问题是我们可以做到吗？

**我们可以做到**。我们构造两个集合，记录上面的 $2*N$ 个元素的前 N 大和前 $N$ 小，然后每一次，选择一个元集合中的最大树和我们的较小的数进行匹配。更具体的，我们可以有：
感觉讲的有点少，那么来聊点别的，比如这题如何构造方案。

我们假设 $p<q$,最后一定是留下这些元素：

$\bullet$ $a_i: + p, + q$,记为 A 类元素 
$\bullet$ $a_i: - p, + q$,记为 B 类元素
$\bullet$ $a_i: - p, - q$,记为 C 类元素

那么构造就比较显然了：先把 $\mathcal{B}$ 连起来，然后一个 C 一个 A 的选。
这个是对的，证明就是你写一下确实 $+p$ 对应 $-q$, $-p$ 对应 $+q$,只要你是严格按照这个顺序写的都不会
有问题，毕竟前 $n$ 大肯定大于后 $n$ 大。注意 $p>q$ 的时候 $\mathcal{A},\mathcal{C}$ 顺序要反一下。

```
#include <bits/stdc++.h>

#define MAXN 1000001
int a[MAXN];
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int N; long long p, q; std::cin >> N >> p >> q;
	for (int i = 1; i <= N; ++i) std::cin >> a[i];
	std::sort(a + 1, a + N + 1);
	for (int i = N, j = N; ; ) {
		(p * a[i] >= q * a[j] ? i : j) -= 1;
		if (i + j == N) {
			std::vector<int> s;
			for (int k = std::min(i, j) + 1; k <= std::max(i, j); ++k) s.push_back(a[k]);
			int c = (i < j ? 1 : i + 1), d = (i < j ? j + 1 : 1);
			for (; std::max(c, d) <= N; ++c, ++d) 
				s.push_back(a[c]), s.push_back(a[d]);
			long long ans = std::abs(p * s[N - 1] - q * s[0]);
			for (int i = 0; i + 1 < N; ++i) 
				ans += std::abs(p * s[i] - q * s[i + 1]);
			std::cout << ans << '\n';
			for (int i = 0; i < N; ++i) 
				std::cout << s[i] << " \n"[i + 1 == N];
			return 0;
		}
	}
	return 0;
}
```