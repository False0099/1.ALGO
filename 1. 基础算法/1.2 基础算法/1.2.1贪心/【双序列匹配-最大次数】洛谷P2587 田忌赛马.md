# 田忌赛马

## 题目描述

我国历史上有个著名的故事： 那是在 $2300$ 年以前。齐国的大将军田忌喜欢赛马。他经常和齐王赛马。他和齐王都有三匹马：常规马，上级马，超级马。一共赛三局，每局的胜者可以从负者这里取得 $200$ 银币。每匹马只能用一次。齐王的马好，同等级的马，齐王的总是比田忌的要好一点。于是每次和齐王赛马，田忌总会输 $600$ 银币。

田忌很沮丧，直到他遇到了著名的军师――孙膑。田忌采用了孙膑的计策之后，三场比赛下来，轻松而优雅地赢了齐王 $200$ 银币。这实在是个很简单的计策。由于齐王总是先出最好的马，再出次好的，所以田忌用常规马对齐王的超级马，用自己的超级马对齐王的上级马，用自己的上级马对齐王的常规马，以两胜一负的战绩赢得 $200$ 银币。实在很简单。

如果不止三匹马怎么办？这个问题很显然可以转化成一个二分图最佳匹配的问题。把田忌的马放左边，把齐王的马放右边。田忌的马 A 和齐王的 B 之间，如果田忌的马胜，则连一条权为 $200$ 的边；如果平局，则连一条权为 $0$ 的边；如果输，则连一条权为 $-200$ 的边……如果你不会求最佳匹配，用最小费用最大流也可以啊。然而，赛马问题是一种特殊的二分图最佳匹配的问题，上面的算法过于先进了，简直是杀鸡用牛刀。现在，就请你设计一个简单的算法解决这个问题。

## 输入格式

第一行一个整数 $n$ ，表示他们各有几匹马（两人拥有的马的数目相同）。第二行 $n$ 个整数，每个整数都代表田忌的某匹马的速度值（$0 \le $ 速度值 $\le 100$）。第三行 $n$ 个整数，描述齐王的马的速度值。两马相遇，根据速度值的大小就可以知道哪匹马会胜出。如果速度值相同，则和局，谁也不拿钱。

## 输出格式

仅一行，一个整数，表示田忌最大能得到多少银币。

## 样例 #1

### 样例输入 #1

```
3
92 83 71
95 87 74
```

### 样例输出 #1

```
200
```

## 提示

### 数据规模与约定

- 对于 $20\%$ 的数据，$1\le N\le 65$；
- 对于 $40\%$ 的数据，$1\le N\le 250$；
- 对于 $100\%$ 的数据，$1\le N\le2000$。

## 题解
我们本体想法是，对于田忌的每一匹马，都尽可能的让他赢下来，并且应该要去战胜的那一个人，是和它的实力最为接近的那一个人的。这样，我们就能保证**最大限度地物尽其用**。因此，我们就可以采用我们的双指针，写出我们的下面的代码：
```
#include <bits/stdc++.h>
using namespace std;
int qw[10000001],tj[10000001],ht,hw,tt,tw,ans;
int main(){
    int i,j,k,m,n;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&tj[i]);
    }
    for(i=1;i<=n;i++)
    {
        scanf("%d",&qw[i]);
    }
    sort(tj+1,tj+1+n);
    sort(qw+1,qw+1+n);
    ht=hw=1;//左指针 
    tt=tw=n;//右指针   越右马越好 
    for(i=1;i<=n;i++)
        if(tj[tt]>qw[tw]){//若田忌的快马能赢 加200银子，双方右指针都左移
             ans+=200;
             tt--;
             tw--;
        }
        else if(tj[ht]>qw[hw]){//否则比较双方最慢的马 能赢则双方左指针右移
            ans+=200;
            ht++;
            hw++;
        }
        else if(tj[ht]<qw[tw]){//不行的话就用田忌最坏的马浪费掉齐王的好马
            ans-=200;
            ht++;//左指针右移
            tw--;//右指针左移 
        }
    cout<<ans;
    return 0; 
}

```