一个游戏：在一条直线上有 N 个糖果。第 i 个糖果的位置是 X[i]。从这 N 个糖果中选择若干个，把他们标记起来。对于每一个糖果，在和它本身相距为 R 的区域内必须要有标记的糖果（本身带有标记的糖果，就可以认为和它相距为0的地方有一个糖果被标记）。在满足这个条件的情况，最后如果有 a 个糖果被标记，编写程序使 a 最小化。

## Input

输入的测试文件将包含多个样例。 每个测试样例第一行有两个数据，整数R（其中0≤R≤1000）和整数N（其中1≤N≤1000）。 下一行包含N个整数，指示每个糖果的位置X[1]，…，X[N]（其中0≤X[i]≤1000）。当R=N=-1时，输入结束。

## Output

对于每组输入数据，输出一个数，代表a的最小值。

## Sample Input

0 3
10 20 20
10 7
70 30 1 7 15 20 50
-1 -1

## Sample Output

2
4

## 题解
本题类似于我们的线段合并，我们以我们的糖果为圆心画一个圆，要求每个都没覆盖，问我们最少画多少个圆。那么我们第一步就是去找我们的圆心，第二步以关心向右扩展。一次类推，直到哦我们最后的答案。

```CPP
#include<bits/stdc++.h>
using namespace std;
const int MAX_N = 1005;
int N,R;
int X[MAX_N];
void solve()
{
    int i = 0,ans = 0;
    while (i < N){
        // s是没有被覆盖的最左的点的位置
        int s = X[i++];
        //一直向右前进知道距s的距离大于R的点
        while (i < N && X[i] <= s + R) i++;

        //p是先加上标记的点的位置
        int p = X[i - 1];
        //一直向右前进直到距p的距离大于R的点
        while (i < N && X[i] <= p + R) i++;
        ans++;
    }
    printf("%d\n",ans);
}
```