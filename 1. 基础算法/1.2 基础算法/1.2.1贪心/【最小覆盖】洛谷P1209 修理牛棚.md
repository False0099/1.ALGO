# [USACO 1.3] 修理牛棚 Barn Repair

## 题目描述

在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了好在许多牛正在度假，所以牛棚没有住满。   

牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。所有的牛棚有相同的宽度。   

自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。

给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。

## 输入格式

一行三个整数 $m,s,c$，意义如题目描述。   
接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。

## 输出格式

输出一行一个整数，表示所需木板的最小总长度。

## 样例 #1

### 样例输入 #1

```
4 50 18
3 
4 
6 
8 
14
15 
16 
17 
21
25 
26 
27 
30 
31 
40 
41 
42 
43
```

### 样例输出 #1

```
25
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 50$，$1\le c \le s \le 200$。 

USACO Training Section 1.3

## 题解
我们本题首先我们的要求是我们每一个都必须要覆盖到，是我们的合并果子的模板题。对于我们的这一类题，我们可以通过首先把我们的每一个端点都覆盖，然后再考虑我们能否将我们的两个相邻的元素给合并起来。

在这里，我们合并两个相邻元素的代价，可以通过我们的计算相邻两个的差值之后排序，每一次都选择合并代价最小的来合并即可。

```cpp
#include<cstdio> 
#include<algorithm> 
#include<iostream> 
#define MAXN 205
using namespace std; 
int m,s,c,ans;
int a[MAXN],C[MAXN];
bool cmp(int x,int y)
{
    return x>y;
}
int main() 
{ 
    scanf("%d %d %d",&m,&s,&c);
    for(int i=1;i<=c;i++)
        scanf("%d",&a[i]);
    if(m>c) { //特判，如果木板数大于牛数，那么每只牛可以有一块木板
        printf("%d\n",c);
        return 0;
    }
    sort(a+1,a+c+1);
    ans=a[c]-a[1]+1;//假设只有一块木板连续地铺着
    for(int i=2;i<=c;i++)
        C[i-1]=a[i]-a[i-1];
    sort(C+1,C+c,cmp);
    for(int i=1;i<=m-1;i++)//减去差最大的//将木板从差最大的地方减去
        ans=ans-C[i]+1;
    printf("%d\n",ans);
} 


```