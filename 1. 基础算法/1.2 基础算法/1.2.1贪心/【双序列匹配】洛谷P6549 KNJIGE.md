# [COCI 2010-2011 #2 ] KNJIGE

## 题目描述

Mirko 有一个由 $n$ 本书组成的家庭图书馆，$n$ 本书在一个狭窄的橱柜中一个接一个地排列。由于在上一任务中对字母进行了很好的训练，他现在希望按字母顺序排列书籍，以使书名字典序排第一的书排在最后，而字典序排最后的书在书橱的底部。

Mirko 可以轻松地将书从书橱中拉出，但是很难将其推回书橱中，因此只能将书放回到书橱的顶部。因此，将书排序籍的唯一可用方法是反复将书籍从书橱中拉出并将其放在书橱的顶部。

这些书按字母顺序用从 $1$ 到 $n$ 的整数标记。因此，Mirko 希望从顶部开始将它们排序为 $(1,2, \cdots ,n)$。例如，如果 $n = 3$ 且开始顺序为 $(3,2,1)$，则两步就足够了。首先，他拉出编号为 $2$ 的书并将其放在最上面，这样书的顺序便变成 $(2,3,1)$。之后，他对编号为 $1$ 的书执行相同操作，因此书的顺序变成 $(1,2,3)$。

计算给定起始顺序，排序完毕所需的最少移动次数。

## 输入格式

第一行一个整数 $n$，具体含义请见题目描述。

接下来 $n$ 行，每行一个正整数，表示书籍的初始摆放顺序。

## 输出格式

一行一个整数，表示使书籍按照自然数顺序排列所需的最小移动步数。

## 样例 #1

### 样例输入 #1

```
3
3
2
1
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
4
1
3
4
2
```

### 样例输出 #2

```
2
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 3 \times 10^5$，书籍的初始摆放顺序为 $1\ldots n$ 的一个排列。

#### 说明

- 本题满分 $80$ 分。

- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) KNJIGE，译者 @ [mnesia](https://www.luogu.com.cn/user/115711)。

## 题解
我们可以吧任意的排序问题都转换为如下形式：
给定一个序列 $a$,你可以对这个 $a$ 进行若干操作，要求操作后，我们能够得到 $b$ 序列，且操作次数尽可能的少。

对于这一类题，我们的思路是按照我们的大小顺序来进行一一匹配，在本题中，我们发现，我们进行某一次操作后**相当于确定了我们的最后一位**是多少，于是我们就可以倒序枚举，如果这个位置是我们的对应的答案。

- **逆序检查的策略**：由于我们的操作不会影响被移动书以外的书，我们可以从书架的底部开始，检查哪些书已经在它们的目标位置上。
- **保持正确位置的书不动**：如果一本书已经在它的目标位置上，我们不需要移动它，也不应该移动它，以避免增加不必要的操作。
- **计算需要移动的书的数量**：总的移动次数取决于需要被移动的书的数量。

```python
def minimal_moves(n, P):
    cnt = 0
    expected = n
    for i in range(n - 1, -1, -1):
        if P[i] == expected:
            cnt += 1
            expected -= 1
    return n - cnt

# 示例使用：
n = int(input())
P = [int(input()) for _ in range(n)]
print(minimal_moves(n, P))
```