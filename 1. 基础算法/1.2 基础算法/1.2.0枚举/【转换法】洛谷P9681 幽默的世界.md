# 幽默的世界。

## 题目背景

@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。不过学文化课或许也好不了多少？

## 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。

## 输入格式

第一行输入两个整数 $n,q$。

接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。

接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。

## 输出格式

对于每组询问，输出一行一个整数，代表答案。

## 样例 #1

### 样例输入 #1

```
4 3
3 -4 -1 2
1 2
3 4
1 4
```

### 样例输出 #1

```
1
2
3
```

## 样例 #2

### 样例输入 #2

```
7 6
-1 2 -1 -1 -1 2 -1
2 5
4 7
1 7
5 5
1 3
2 4
```

### 样例输出 #2

```
1
2
4
0
2
1
```

## 提示

对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。

### 子任务

|  #  |         特殊性质          | 分值  |
| :-: | :-------------------: | :-: |
|  0  |          样例           |  0  |
|  1  |      $n,q\le 50$      | 15  |
|  2  | $n,q\le 3\times 10^3$ | 20  |
|  3  |     对于所有询问，$r=n$      | 15  |
|  4  |     对于所有询问，$l=1$      | 15  |
|  5  |           -           | 35  |
## 题解
我们本题首先要知道，什么样的数列是幽默的，首先，一定满足除了最后一个是整数，并且这个整数比我们前面的所有负数加起来都大，另一部分是负数。这样我们的数列才是幽默的。

如果我们考虑枚举负数，那么我只能说孩子你无敌了，这样的话我们的时间一定为超时，我们考虑**枚举每一个正数**，并且计算这一个正数可以向前延伸的最大长度是多少。这个最大长度就是我们对于我们答案的贡献。
```cpp
void init(){
	for(int i=0;i<n;i++){
		if(a[i]>0){
			
		}
	}
}
```
我们可以在每次询问中找到在 l 到 r 中的每一个正数，再从后往前累加，直到和小于零，则求出来的长度就是所求序列的个数。
```
#include<bits/stdc++.h>
using namespace std;
int n,q,l,r,s,a[300000];
long long sum,ans;
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;++i)	scanf("%d",a+i);
	while(q--){
		scanf("%d%d",&l,&r);
		s=ans=sum=0;
		for(int i=r;i>=l;--i)
			if(a[i]>0){
				s=i;
				break;
			}//从后往前找到第一个正数
		for(int i=s;i>=l;--i){
			if(a[i]>0)	sum=0;
          		//每次找到正数重新开始累加
			sum+=a[i];
			if(sum>0)	++ans;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```
所以我们想到预处理，将整个序列中的所有正数提取出来，并储存好每个正数可带领的最长序列的长度（简称正数的长度）。
```
for(int i=n,j;i;--i){
	if(a[i]>0)	j=i,m=0,z[++num]=j;
	//储存每个正数的位置，num记录正数的个数
	m+=a[i];
	if(m>0)	++v[j];//储存长度
}
```

那么我们只需要在每次询问时统计区间内的所有正数的长度就可以了，所以需要找到最大的不大于 r 的正数与最小的不小于 l 的正数。
```
#include<bits/stdc++.h>
using namespace std;
int n,q,num,a[300000],v[300000],z[300000];
long long m,ans,sum[300000];
int ef(int k){//二分查找
	int l=1,r=num,mid;
	while(l<=r){
		mid=l+r>>1;
		z[mid]>k?r=mid-1:l=mid+1;
		//喜欢压行，改不掉的
	}
	return r;
}
int main(){
	int l,r,s,e;
	cin>>n>>q;
	for(int i=1;i<=n;++i)	scanf("%d",a+i);
	for(int i=n,j;i;--i){
		if(a[i]>0)	j=i,m=0,z[++num]=j;
		m+=a[i];
		if(m>0)	++v[j];
	}
	sort(z+1,z+1+num);//排序，方便查找
	for(int i=1;i<=num;++i)	sum[i]=sum[i-1]+v[z[i]];
	//前缀和优化
	while(q--){
		ans=0;//初始化
		scanf("%d%d",&l,&r);
		s=ef(l);
		e=ef(r);
		//找到最大的不大于r的正数e，与最小的不小于l的正数s
		//使用二分算法优化时间复杂度
		if(z[e]<l)	goto nxt;
		//忘记判断e是否在范围内，改了好久╥﹏╥
		if(z[s]<l)	++s;
		//确保s>=l
		ans=sum[e]-sum[s]+min(v[z[s]],z[s]-l+1);
		//统计答案，因为s所带领的序列有可能被吞掉了一部分，所以要特殊处理
		nxt:printf("%lld\n",ans);
	}
	return 0;
}
```
