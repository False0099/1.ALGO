# [CSP-S 2021] 廊桥分配

## 题目描述

当一架飞机抵达机场时，可以停靠在航站楼旁的廊桥，也可以停靠在位于机场边缘的远机位。乘客一般更期待停靠在廊桥，因为这样省去了坐摆渡车前往航站楼的周折。然而，因为廊桥的数量有限，所以这样的愿望不总是能实现。

机场分为国内区和国际区，国内航班飞机只能停靠在国内区，国际航班飞机只能停靠在国际区。一部分廊桥属于国内区，其余的廊桥属于国际区。

L 市新建了一座机场，一共有 $n$ 个廊桥。该机场决定，廊桥的使用遵循“先到先得”的原则，即每架飞机抵达后，如果相应的区（国内/国际）还有空闲的廊桥，就停靠在廊桥，否则停靠在远机位（假设远机位的数量充足）。该机场只有一条跑道，因此不存在两架飞机同时抵达的情况。

现给定未来一段时间飞机的抵达、离开时刻，请你负责将 $n$ 个廊桥分配给国内区和国际区，使停靠廊桥的飞机数量最多。

## 输入格式

输入的第一行，包含三个正整数 $n, m_1, m_2$，分别表示廊桥的个数、国内航班飞机的数量、国际航班飞机的数量。

接下来 $m_1$ 行，是国内航班的信息，第 $i$ 行包含两个正整数 $a_{1, i}, b_{1, i}$，分别表示一架国内航班飞机的抵达、离开时刻。

接下来 $m_2$ 行，是国际航班的信息，第 $i$ 行包含两个正整数 $a_{2, i}, b_{2, i}$，分别表示一架国际航班飞机的抵达、离开时刻。

每行的多个整数由空格分隔。

## 输出格式

输出一个正整数，表示能够停靠廊桥的飞机数量的最大值。

## 样例 #1

### 样例输入 #1

```
3 5 4
1 5
3 8
6 10
9 14
13 18
2 11
4 15
7 17
12 16
```

### 样例输出 #1

```
7
```

## 样例 #2

### 样例输入 #2

```
2 4 6
20 30
40 50
21 22
41 42
1 19
2 18
3 4
5 6
7 8
9 10
```

### 样例输出 #2

```
4
```

## 样例 #3

### 样例输入 #3

```
见附件中的 airport/airport3.in
```

### 样例输出 #3

```
见附件中的 airport/airport3.ans
```

## 提示

**【样例解释 #1 】**

![](https://cdn.luogu.com.cn/upload/image_hosting/48wcffrv.png)

在图中，我们用抵达、离开时刻的数对来代表一架飞机，如 $(1, 5)$ 表示时刻 $1$ 抵达、时刻 $5$ 离开的飞机；用 $\surd$ 表示该飞机停靠在廊桥，用 $\times$ 表示该飞机停靠在远机位。

我们以表格中阴影部分的计算方式为例，说明该表的含义。在这一部分中，国际区有 $2$ 个廊桥，$4$ 架国际航班飞机依如下次序抵达：

1. 首先 $(2, 11)$ 在时刻 $2$ 抵达，停靠在廊桥。
2. 然后 $(4, 15)$ 在时刻 $4$ 抵达，停靠在另一个廊桥。
3. 接着 $(7, 17)$ 在时刻 $7$ 抵达，这时前 $2$ 架飞机都还没离开、都还占用着廊桥，而国际区只有 $2$ 个廊桥，所以只能停靠远机位。
4. 最后 $(12, 16)$ 在时刻 $12$ 抵达，这时 $(2, 11)$ 这架飞机已经离开，所以有 $1$ 个空闲的廊桥，该飞机可以停靠在廊桥。

根据表格中的计算结果，当国内区分配 $2$ 个廊桥、国际区分配 $1$ 个廊桥时，停靠廊桥的飞机数量最多，一共 $7$ 架。

**【样例解释 #2 】**

当国内区分配 $2$ 个廊桥、国际区分配 $0$ 个廊桥时，停靠廊桥的飞机数量最多，一共 $4$ 架，即所有的国内航班飞机都能停靠在廊桥。

需要注意的是，本题中廊桥的使用遵循“先到先得”的原则，如果国际区只有 $1$ 个廊桥，那么将被飞机 $(1, 19)$ 占用，而不会被 $(3, 4)$、$(5, 6)$、$(7, 8)$、$(9, 10)$ 这 $4$ 架飞机先后使用。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 100$，$m_1 + m_2 \le 100$。  
对于 $40 \%$ 的数据，$n \le 5000$，$m_1 + m_2 \le 5000$。  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$m_1, m_2 \ge 1$，$m_1 + m_2 \le {10}^5$，所有 $a_{1, i}, b_{1, i}, a_{2, i}, b_{2, i}$ 为数值不超过 ${10}^8$ 的互不相同的正整数，且保证对于每个 $i \in [1, m_1]$，都有 $a_{1, i} < b_{1, i}$，以及对于每个 $i \in [1, m_2]$，都有 $a_{2, i} < b_{2, i}$。

【感谢 hack 数据提供】

- [xingxuxin](/user/393378)。
- [cyslngsul](/user/126765)。

## 题解
我们本题按照下面的思路分析，首先我们可以**枚举我们给国内航班分配了** $k$ 种，给我们的国际航班分配了 $n-k$ 种的和是多少，然后再对每一个和取一个最值，就能够得到我们的答案。

现在，我们的问题就变成了，给定我们有 $k$ 种分配给国内，问我们能接待多少架飞机。这里如果我们不是要求我们一定要先到先得的话，我们就可以贪心然后求出我们的最终值是多少。但注意，我们这里是先到先得，与我们的贪心策略是相反的。

考虑怎么计算我们给定 k 种的方案，首先，如果我们是要问我们给定了 $m$ 架飞机，问我们最少需要多少的飞行架，能够让我们完全起落，这个问题是简单的，我们只需要按照我们的时间排序即可。

而我们当前的问题就属于是上述问题的一个“反演”。考虑下面的一种做法：我们维护一个空闲的廊桥队列，每到达一架航班，就给它安排编号最小的廊桥供其使用。这里，我们除了需要基础我们的个数意外，还需要记录我们每一个队列的使用结束时间 $t_{i}$,然后如果我们满足我们的 $t_{now}>t_{i}$,我们就把对应的元素给踢出来。



现在加上廊桥数量的限制。容易发现刚才的廊桥分配方法直接就帮我们解决了廊桥限制的问题：如果当前有 $n$ 个廊桥可供使用，则分配到 $n+1$ 号及以后的廊桥实质上就是分配到远机位了，不需要再做任何额外的处理。（同时，这也是对于处理我们的队列分配的一种通法）

到这里做法就很清晰了：我们按照开头提到的分配方法来安排航班的停靠位置，记录各廊桥停靠的航班数，做一个前缀和，最后枚举分配给某个区的廊桥数，算出各情况下两区实际使用廊桥的航班数总和，即可解决本题。

```cpp
// Problem: P7913 [CSP-S 2021] 廊桥分配（洛谷民间数据）
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7913
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
typedef pair<int, int> pii;
struct range {
  int x, y;
} a[100005], b[100005];
int res1[100005], res2[100005];
int n;
bool cmp(const range& a, const range& b) { return a.x < b.x; }
void calc(range* t, int m, int* res) {
  priority_queue<pii, vector<pii>, greater<pii> > lq; // 等待离港航班队列
  priority_queue<int, vector<int>, greater<int> > wq; // 空闲廊桥队列
  for (int i = 1; i <= n; i++) wq.push(i);
  for (int i = 1; i <= m; i++) {
    while (!lq.empty() && t[i].x >= lq.top().first) {
      wq.push(lq.top().second);
      lq.pop();
    }
    if (wq.empty()) continue;
    int dest = wq.top();
    wq.pop();
    res[dest]++;
    lq.push(make_pair(t[i].y, dest));
  }
  for (int i = 1; i <= n; i++) res[i] += res[i - 1];
}
int main() {
  int m1, m2;
  cin >> n >> m1 >> m2;
  for (int i = 1; i <= m1; i++) cin >> a[i].x >> a[i].y;
  for (int i = 1; i <= m2; i++) cin >> b[i].x >> b[i].y;
  sort(a + 1, a + m1 + 1, cmp);
  sort(b + 1, b + m2 + 1, cmp);
  calc(a, m1, res1);
  calc(b, m2, res2);
  int ans = 0;
  for (int i = 0; i <= n; i++) {
    ans = max(ans, res1[i] + res2[n - i]);
  }
  cout << ans << endl;
  return 0;
}

```