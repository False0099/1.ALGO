# [CSP-S 2023] 密码锁

## 题目描述

小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，

![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)

因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。

当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\tt{0\;0\;1\;1\;5}$ 转成 $\tt{1\;1\;1\;1\;5}$，但不会转成 $\tt{1\;2\;1\;1\;5}$。

时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。

为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。

## 输入格式

输入的第一行包含一个正整数 $n$，表示锁车后密码锁的状态数。

接下来 $n$ 行每行包含五个整数，表示一个密码锁的状态。

## 输出格式

输出一行包含一个整数，表示密码锁的这 $n$ 个状态按照给定的锁车方式能对应多少种正确密码。

## 样例 #1

### 样例输入 #1

```
1
0 0 1 1 5
```

### 样例输出 #1

```
81
```

## 提示

**【样例 1 解释】**

一共有 $81$ 种可能的方案。

其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。

**【样例 2】**

见选手目录下的 lock/lock 2. In 与 lock/lock 2. Ans。

**【数据范围】**

对于所有测试数据有：$1 \leq n \leq 8$。

|    测试点     | $n\leq$ | 特殊性质 |
| :--------: | :-----: | :--: |
| $1\sim 3$  |   $1$   |  无   |
| $4\sim 5$  |   $2$   |  无   |
| $6\sim 8$  |   $8$   |  A   |
| $9\sim 10$ |   $8$   |  无   |

特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。

## 题解
首先，由于我们本体的值域范围比较小，我们的数字都只有六位，我们就可以暴力枚举我们的所有状态，然后再去查看这些状态是不是符合要求的。

其中判断一个状态是否符合要求，可以通过我们的预处理来得到。
```
#include<bits/stdc++.h>
using namespace std;
const int N=11,mod=10;
int n,ans,dp[N][N][N][N][N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b,c,d,e;
		cin>>a>>b>>c>>d>>e;
		for(int j=1;j<=9;j++)
		{
			dp[(a+j)%mod][b][c][d][e]++;
			dp[a][(b+j)%mod][c][d][e]++;
			dp[a][b][(c+j)%mod][d][e]++;
			dp[a][b][c][(d+j)%mod][e]++;
			dp[a][b][c][d][(e+j)%mod]++;
			dp[(a+j)%mod][(b+j)%mod][c][d][e]++;
			dp[a][(b+j)%mod][(c+j)%mod][d][e]++;
			dp[a][b][(c+j)%mod][(d+j)%mod][e]++;
			dp[a][b][c][(d+j)%mod][(e+j)%mod]++;
		}
	}
	for(int i=0;i<=9;i++)
	    for(int j=0;j<=9;j++)
	        for(int k=0;k<=9;k++)
	            for(int u=0;u<=9;u++)
	                for(int v=0;v<=9;v++)
	                    if(dp[i][j][k][u][v]==n)ans++;
	cout<<ans;
	return 0;
}

```