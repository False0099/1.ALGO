# [USACO 08 MAR] Cow Travelling S

## 题目描述

奶牛们在被划分成 $N$ 行 $M$ 列（$2 \leq N,M \leq 100$）的草地上游走，试图找到整块草地中最美味的牧草。

Farmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \lt T \leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。

设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。

现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。

## 输入格式

第一行包含 $3$ 个用空格隔开的整数：$N,M,T$。

接下来 $n$ 行：第 $i$ 行为 $M$ 个连续的字符，描述了草地第 $i$ 行各点的情况，保证字符是 `.` 和 `*` 中的一个。

最后一行 $4$ 个整数 $R_1,C_1,R_2,C_2$。

## 输出格式

输出从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的方案数。

## 样例 #1

### 样例输入 #1

```
4 5 6
...*.
...*.
.....
.....
1 3 1 5
```

### 样例输出 #1

```
1
```

## 提示

奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。

## 题解
本题因为有时间限制，所以我们的 bfs 是不太好用的，我们这一题需要的是我们的记忆化搜索，我们记忆化搜索需要的内容：当前的时间，走到的 x 位置，走到的 y 位置。那么对于每一个位置，我们都存在一个转移 $dp[i][x][y]=dp[i-1][x][y-1]+dp[i-1][x-1][y]+dp[i-1][x][y+1]+dp[i+1][y]$
但是，我们可以发现，这个转移是不符合我们的一般 dp for 循环更新法，所以我们需要采用记忆化搜索的方式来更新我们的这个数组。

```c
#include<iostream>
#include<cstring>

using namespace std;

const int N=110;

char g[N][N];
int n,m,t;
int r1,c1,r2,c2;
int f[N][N][N];//f[x][y][t]表示以(x,y)为起点,在时间为t时可以到达终点的路线数 

int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};

int dfs(int x,int y,int t){
	if(f[x][y][t]!=-1)	return f[x][y][t];
	if(t==0){//注意关注t的在f数组中的意义 
		if(x==r2&&y==c2)	return f[x][y][t]=1;
		return f[x][y][t]=0;
	}
	int mx,my;
	int tmp=0;
	for(int i=0;i<4;i++){
		mx=x+dx[i];
		my=y+dy[i];
		if(mx>=0&&mx<n&&my>=0&&my<m&&g[mx][my]!='*')	tmp+=dfs(mx,my,t-1);
	}
	return f[x][y][t]=tmp;
}

int main(){
	cin>>n>>m>>t;
	memset(f,-1,sizeof f);
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			cin>>g[i][j];
	cin>>r1>>c1>>r2>>c2;
	r2--;c2--;
	cout<<dfs(r1-1,c1-1,t);
}
```