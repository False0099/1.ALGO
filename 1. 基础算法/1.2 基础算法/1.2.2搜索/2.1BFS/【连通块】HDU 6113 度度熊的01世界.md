度度熊是一个喜欢计算机的孩子，在计算机的世界中，所有事物实际上都只由0和1组成。  
  
现在给你一个 n * m 的图像，你需要分辨他究竟是0，还是1，或者两者均不是。  
  
图像0的定义：存在1字符且1字符只能是由一个连通块组成，存在且仅存在一个由0字符组成的连通块完全被1所包围。  
  
图像1的定义：存在1字符且1字符只能是由一个连通块组成，不存在任何0字符组成的连通块被1所完全包围。  
  
连通的含义是，只要连续两个方块有公共边，就看做是连通。  
  
完全包围的意思是，该连通块不与边界相接触。  

## Input

本题包含若干组测试数据。  
每组测试数据包含：  
第一行两个整数n,m表示图像的长与宽。  
接下来n行m列将会是只有01组成的字符画。  
  
满足1<=n,m<=100  

## Output

如果这个图是1的话，输出1；如果是0的话，输出0，都不是输出-1。  

## Sample

|Inputcopy|Outputcopy|
|---|---|
|32 32<br>00000000000000000000000000000000<br>00000000000111111110000000000000<br>00000000001111111111100000000000<br>00000000001111111111110000000000<br>00000000011111111111111000000000<br>00000000011111100011111000000000<br>00000000111110000001111000000000<br>00000000111110000001111100000000<br>00000000111110000000111110000000<br>00000001111110000000111110000000<br>00000001111110000000011111000000<br>00000001111110000000001111000000<br>00000001111110000000001111100000<br>00000001111100000000001111000000<br>00000001111000000000001111000000<br>00000001111000000000001111000000<br>00000001111000000000000111000000<br>00000000111100000000000111000000<br>00000000111100000000000111000000<br>00000000111100000000000111000000<br>00000001111000000000011110000000<br>00000001111000000000011110000000<br>00000000111000000000011110000000<br>00000000111110000011111110000000<br>00000000111110001111111100000000<br>00000000111111111111111000000000<br>00000000011111111111111000000000<br>00000000111111111111100000000000<br>00000000011111111111000000000000<br>00000000001111111000000000000000<br>00000000001111100000000000000000<br>00000000000000000000000000000000<br>32 32<br>00000000000000000000000000000000<br>00000000000000001111110000000000<br>00000000000000001111111000000000<br>00000000000000011111111000000000<br>00000000000000111111111000000000<br>00000000000000011111111000000000<br>00000000000000011111111000000000<br>00000000000000111111110000000000<br>00000000000000111111100000000000<br>00000000000001111111100000000000<br>00000000000001111111110000000000<br>00000000000001111111110000000000<br>00000000000001111111100000000000<br>00000000000011111110000000000000<br>00000000011111111110000000000000<br>00000001111111111111000000000000<br>00000011111111111111000000000000<br>00000011111111111111000000000000<br>00000011111111111110000000000000<br>00000000001111111111000000000000<br>00000000000000111111000000000000<br>00000000000001111111000000000000<br>00000000000111111110000000000000<br>00000000000011111111000000000000<br>00000000000011111111000000000000<br>00000000000011111111100000000000<br>00000000000011111111100000000000<br>00000000000000111111110000000000<br>00000000000000001111111111000000<br>00000000000000001111111111000000<br>00000000000000000111111111000000<br>00000000000000000000000000000000<br>3 3<br>101<br>101<br>011|0<br>1<br>-1|

## 题解
我们在外圈补一层 0，然后 dfs 一下 1 和 0 的连通块的个数，就可以发现，1 的连通块个数是 1，0 的是 2，那么就是图像 0，如果 1 和 2 都是 1，那么就是图像 1，其余的就是-1.

```cpp
#include "iostream"
#include "string.h"
#include "stack"
#include "queue"
#include "string"
#include "vector"
#include "set"
#include "map"
#include "algorithm"
#include "stdio.h"
#include "math.h"
#pragma comment(linker, "/STACK:102400000,102400000")
#define ll long long
#define endl ("\n")
#define bug(x) cout<<x<<" "<<"UUUUU"<<endl;
#define mem(a,x) memset(a,x,sizeof(a))
#define mp(x,y) make_pair(x,y)
#define pb(x) push_back(x)
#define ft first
#define sd second
#define lrt (rt<<1)
#define rrt (rt<<1|1)
using namespace std;
const long long INF = 1e18+1LL;
const int inf = 1e9+1e8;
const int N=1e5+100;
const ll mod=1e9+7;

int n,m;
int G[105][105],vis[2][105][105];
int d[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
struct Node{
    int xx, yy;
};
void bfs(int x, int y, int k){
    queue<Node> Q;
    while(!Q.empty()) Q.pop();
    Node now,next; now.xx=x, now.yy=y;
    Q.push(now), vis[k][x][y]=1;
    while(!Q.empty()){
        now=Q.front(); Q.pop();
        for(int i=0; i<4; ++i){
            next.xx=now.xx+d[i][0];
            next.yy=now.yy+d[i][1];
            if(next.xx>n+1 || next.xx<0 || next.yy>m+1 || next.yy<0) continue;
            if(G[next.xx][next.yy]==k && !vis[k][next.xx][next.yy]){
                Q.push(next);
                vis[k][next.xx][next.yy]=1;
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    while(cin>>n>>m){
        mem(G,0), mem(vis,0);
        for(int i=1; i<=n; ++i){
            for(int j=1; j<=m; ++j){
                char cc; cin>>cc;
                G[i][j]=cc-'0';
            }
        }
        int c0=0, c1=0;
        for(int i=0; i<=n+1; ++i){
            for(int j=0; j<=m+1; ++j){
                if(G[i][j]==0 && !vis[0][i][j]){
                    bfs(i,j,0); c0++;
                }
                else if(G[i][j]==1 && !vis[1][i][j]){
                    bfs(i,j,1); c1++;
                }
            }
        }
        if(c1!=1 || c0>=3) cout<<-1<<endl;
        else if(c0==1) cout<<1<<endl;
        else cout<<0<<endl;
    }
    return 0;
}
```
