你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5 \times 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 $-1$。

#### 数据范围

$0 < n \le 500$

#### 输入样例：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

输出样例：

```diff
3
2
-1
```


## 题解
我们本题理论上，可以用我们的异或基来解决我们这一道题目，但是既然已经放在了搜索里，我们不妨用一点搜索的方法。
在我们用 bfs 是，因为我们不能直接把我们的图给放到 dfs 种，所以需要我们用状态压缩的方式，存贮我们的每一个状态

```cpp
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 5e7+10;
const ll mod = 1000000007;

unordered_map<int,int>vis;
int build(int x,int p)
{
    x ^= ( 1<< p);
    if(p % 5) x ^= (1 << (p - 1));
    if(p >= 5) x ^= (1 << (p - 5));
    if(p < 20) x ^= (1 << (p + 5));
    if((p % 5) < 4) x ^= (1 << (p + 1));
    return x;
}

void bfs()
{
    queue<int> que;
    int now = (1 << 25) - 1;
    vis[now] = 1;
    que.push(now);
    while(!que.empty())
    {
        int top = que.front();
        que.pop();
        if(vis[top] == 7) break;
        for(int i = 0;i < 25;i++)
        {
            now = build(top,i);
            if(!vis.count(now))
            {
                vis[now] = vis[top] + 1;
                que.push(now);
            }
        }
    }
}
int main()
{
    bfs();
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int sum = 0;
        for(int i = 0;i < 25;i++)
        {
            char t;
            cin >> t;
            sum += ((t - '0') << i);
        }
        printf("%d\n",vis[sum] - 1);
    }
    return 0;
}


```
