# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP 2017 普及组 T 3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的），你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $个金币。

另外，你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用，而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法；只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？

## 输入格式

第一行包含两个正整数$ m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。

接下来的$ n $行，每行三个正整数$ x, y, c $， 分别表示坐标为$ (x, y) $的格子有颜色$ c$。

其中$ c=1$ 代表黄色，$ c=0$ 代表红色。相邻两个数之间用一个空格隔开。棋盘左上角的坐标为 $(1, 1)$，右下角的坐标为 $( m, m)$。

棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1, 1)$ 一定是有颜色的。

## 输出格式

一个整数，表示花费的金币的最小值，如果无法到达，输出 $-1$。

## 样例 #1

### 样例输入 #1

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0
```

### 样例输出 #1

```
8
```

## 样例 #2

### 样例输入 #2

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0
```

### 样例输出 #2

```
-1
```

## 提示

### 输入输出样例 1 说明

 ![](https://cdn.luogu.com.cn/upload/pic/10841.png) 

从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币

从 $(2,2)$ 走到 $(2,3)$ 不花费金币

从 $(2,3)$ 走到 $(3,3)$ 不花费金币

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费$ 2$ 枚金币，

从 $(4,4)$ 走到 $(4,5)$ 不花费金币

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币

共花费 $8 $枚金币。

### 输入输出样例 2 说明

 ![](https://cdn.luogu.com.cn/upload/pic/10842.png) 

从 $( 1, 1)$ 走到 $( 1, 2)$,不花费金币

从 $( 1, 2)$ 走到 $( 2, 2)$,花费$ 1 $金币

施展魔法将 $( 2, 3)$ 变为黄色, 并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费$ 2$ 金币

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$

而从以上四点均无法到达 $( 5, 5)$,故无法到达终点, 输出 $-1$

### 数据规模与约定

对于 $30\%$ 的数据, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。

## 题解
我们这一题，还是可以按照我们 bfs 的思路来进行，我们可以这么来处理我们的变色，假设我们站在了一个施了魔法的格子上，我们上一步的格子称为 now，**思考我们下一步能走到的格子**有哪些，因为魔法不能连用，于是，我们能选择的只有 3 种或更少可能。我们**施展魔法，等价于连续走了两步**![[Pasted image 20230918194709.png]]
如图，蓝色的表示我们使用魔法所能走到的理论情况，绿色表示我们不适用魔法所能走到的理论最大区域。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
template <typename Tp>
struct node{
	int x,y,c,w; 
	bool operator <(node b)const{//const不可丢 
		return w>b.w;
	}//因为STL中优先队列默认取出最大的元素 
	 //所以这里重载运算符，保证每次取出的是最小代价的 
};
priority_queue<node>q;//node类型必须定义< 
int dx[]={0,1,0,-1,1,1,-1,-1,0,2,0,-2};//12方向及魔法代价 
int dy[]={1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[]={0,0,0,0,2,2,2,2,2,2,2,2};
int a[105][105],dis[105][105];//a存储棋盘上格子的颜色 
int n,m;
void bfs(){
	memset(dis,0x3f,sizeof(dis));dis[1][1]=0;
	q.push((node){1,1,a[1][1],dis[1][1]});
	node cur,nxt;
	while(!q.empty()){
		cur=q.top();q.pop();
		if(dis[cur.x][cur.y]<cur.w)continue;
		for(int i=0;i<12;i++){//懒惰删除 
			nxt.x=cur.x+dx[i];
			nxt.y=cur.y+dy[i];
			nxt.w=cur.w+dw[i];
            if(nxt.x<=0||nxt.x>m||nxt.y<=0||nxt.y>m)continue;//保证在棋盘范围内
			nxt.c=a[nxt.x][nxt.y];
			if(!nxt.c)continue;
			if(cur.c!=nxt.c)nxt.w++;//确定下一步的信息 
			if(dis[nxt.x][nxt.y]>nxt.w){
				dis[nxt.x][nxt.y]=nxt.w;
				q.push(nxt);
			}
		}
	}
}
int main(){
	int x,y,c;
	read(m);read(n);
	for(int i=1;i<=n;i++){
		read(x);read(y);read(c);
		a[x][y]=c+1;
	}//这里c+1，为了方便区分无色格子 
	bfs();
	if(!a[m][m]){//处理(m,m)无色情况 
		int ans=min(dis[m][m-1],dis[m-1][m])+2;
		if(ans>=inf)puts("-1");
		else printf("%d\n",ans);
	}
	else{
		if(dis[m][m]==inf)puts("-1");
		else printf("%d\n",dis[m][m]);
	}
	return 0;
}
```

