# 知识点
  ## [[BFS]] [[Dijstra算法]]
# 题目
	 达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。

翰翰的家里有一辆飞行车。有一天飞行车的电路板突然出现了故障，导致无法启动。电路板的整体结构是一个 R行 C列的网格（R, C≤500），如下图所示。
![[Pasted image 20230411205459.png]]

每个格点都是电线的接点，每个格子都包含一个电子元件。

电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。

在旋转之后，它就可以连接另一条对角线的两个接点。

电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。

达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。

她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。

不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。

注意：只能走斜向的线段，水平和竖直线段不能走。

# 输入格式
输入文件包含多组测试数据。第一行包含一个整数 T，表示测试数据的数目。对于每组测试数据，第一行包含正整数 R和 C，表示电路板的行数和列数。

之后 R行，每行 C个字符，字符是"/"和"\"中的一个，表示标准件的方向。

# 输出格式
对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。

如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。

# 数据范围
$1≤R, C≤500$

$1≤T≤5$
# 输入样例 ：
```
1
3 5
\\/\\
\\///
/\\\\
``````
# 输出样例 ：
1
# 样例解释
样例的输入对应于题目描述中的情况。只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。


![[Pasted image 20230411205647.png]]
难度：简单
时/空限制：1 s / 64 MB
总通过数：10832
总尝试数：23520


# 思路
·原问题可以转化为从一个顶点到达另一个顶点所需要的最短距离，对于这种同源点，我们可以直接使用 dijstra 算法相关的思想来解决。相关的有关于更改的我们也都可以设置为对应的权值。
·我们一开始需要处理两个点，一个是怎么把输入的数据转换为一个简单的图形。
## 我们首先先列举对角线上的点，记为数组 $dx [][]$,之后我们再去列举对角线所对应的正方形。记为 $dx_{2}[][]$,

·其次，我们还需要去处理那些烦人的\/\/这样的内容
## 我们就可以通过存储每一一个正方形上的对应\/为依据，设置到其他正方形的边权。
·这道题其实就是 dijkstra 算法的特殊情况。就是先把源点放入优先队列，接下来重复以下操作 (取出队列中距离源点最近的点—优先队列的队头，用该点更新其它与该点相邻的点的距离，再把更新后的距离放入队列)。
每个点在出队的时候就说明从源点到该点的最短距离已经找到，因此要对这个点进行标记，后续计算时忽略该点。
本题也是一样，先把左上方的 (0，0)点放入队列中，然后接着操作。
但是本题用的数据结构并不是优先队列，而是双端队列，为了实现和优先队列相同的效果，当边权重是零的时候，就把新的点从队列头插入，是一的时候，就从队列尾部插入。这样可以保证该队列从头部到尾部，是单调不下降的。这样，就从本质上实现了 dijkstra 算法。
欢迎指正！
# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fir(i,a,b) for(int i=a;i<=b;i++)
const int N=510;
const int dxy1[4][2]= {{1,1},{-1,-1},{1,-1},{-1,1}},dxy2[4][2]= {{1,1},{0,0},{1,0},{0,1}};//两种不同走法(因为两种线路),所以要两个方向数组
struct node
{
    int x,y;
};
int t,n,m,ans=1e8,dis[N][N];
char s[N][N];
bool vis[N][N];
deque<node> q;//双端队列
int check(int x,int y)
{
    return x>=0 && x<=n && y>=0 && y<=m;//范围内
}
void bfs()
{
    vis[0][0]=1;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));//初始化最大值
    q.push_front(node {0,0});//0开始,是因为读入的不是坐标,而是两种线路,然后你就会发现其实坐标点是要从0开始的,当然你n+1,m+1也是可以的
    dis[0][0]=0;
    while(q.size())
    {
        node now=q.front();
        q.pop_front();
        fir(i,0,3)//四种方向
        {
            int tx=now.x+dxy1[i][0],t1=now.x+dxy2[i][0];//如果是'\'
            int ty=now.y+dxy1[i][1],t2=now.y+dxy2[i][1];//如果是'/'
            int tt=(s[t1][t2] != (i<=1? '\\':'/'));//转义字符要双写,这里用到了三目运算符
            if(check(tx,ty) && dis[tx][ty]>dis[now.x][now.y]+tt)//check成功,并且当前值更加优秀
            {
                dis[tx][ty]=dis[now.x][now.y]+tt;
                if(tt)
                    q.push_back(node {tx,ty});//边权值为1
                else
                    q.push_front(node {tx,ty});//边权值为0
            }
        }
    }
}
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        fir(i,1,n)
        fir(j,1,m)
        cin>>s[i][j];
        bfs();
        if(dis[n][m]<1e8)//如果找到了方案
            cout<<dis[n][m]<<endl;
        else
            cout<<"NO SOLUTION"<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/971/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
# 备注
