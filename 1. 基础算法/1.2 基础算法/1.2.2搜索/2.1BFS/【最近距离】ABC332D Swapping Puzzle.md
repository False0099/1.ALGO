# [ABC 332 D] Swapping Puzzle

## 题面翻译

给定两个 $n \times m$ 的矩阵 $A$ 和 $B$。

你每次可以交换矩阵 $A$ 的相邻两行中的所有元素或是交换两列中的所有元素。

请问要使 $A$ 变换至 $B$ 至少需要几步操作？

如果无法变换至 $B$，则输出 `-1`。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc332/tasks/abc332_d

$ H $ 行 $ W $ 列の $ 2 $ つのグリッド A, B が与えられます。

$ 1\ \leq\ i\ \leq\ H $ と $ 1\ \leq\ j\ \leq\ W $ を満たす各整数の組 $ (i,\ j) $ について、 $ i $ 行目 $ j $ 列目にあるマスをマス $ (i,\ j) $ と呼ぶとき、 グリッド A の マス $ (i,\ j) $ には整数 $ A_{i,\ j} $ が、 グリッド B の マス $ (i,\ j) $ には整数 $ B_{i,\ j} $ がそれぞれ書かれています。

あなたは「下記の $ 2 $ つのうちのどちらか $ 1 $ つを行う」という操作を好きな回数（ $ 0 $ 回でもよい）だけ繰り返します。

- $ 1\ \leq\ i\ \leq\ H-1 $ を満たす整数 $ i $ を選び、グリッド A の $ i $ 行目と $ (i+1) $ 行目を入れ替える。
- $ 1\ \leq\ i\ \leq\ W-1 $ を満たす整数 $ i $ を選び、グリッド A の $ i $ 列目と $ (i+1) $ 列目を入れ替える。

上記の操作の繰り返しによって、グリッド A をグリッド B に一致させることが可能かどうかを判定してください。 さらに、一致させることが可能な場合は、そのために行う操作回数の最小値を出力してください。

ここで、グリッド A とグリッド B が一致しているとは、 $ 1\ \leq\ i\ \leq\ H $ と $ 1\ \leq\ j\ \leq\ W $ を満たす全ての整数の組 $ (i,\ j) $ について、 グリッド A の マス $ (i,\ j) $ とグリッド B の マス $ (i,\ j) $ に書かれた整数が等しいこととします。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{1,\ 1} $ $ A_{1,\ 2} $ $ \cdots $ $ A_{1,\ W} $ $ A_{2,\ 1} $ $ A_{2,\ 2} $ $ \cdots $ $ A_{2,\ W} $ $ \vdots $ $ A_{H,\ 1} $ $ A_{H,\ 2} $ $ \cdots $ $ A_{H,\ W} $ $ B_{1,\ 1} $ $ B_{1,\ 2} $ $ \cdots $ $ B_{1,\ W} $ $ B_{2,\ 1} $ $ B_{2,\ 2} $ $ \cdots $ $ B_{2,\ W} $ $ \vdots $ $ B_{H,\ 1} $ $ B_{H,\ 2} $ $ \cdots $ $ B_{H,\ W} $

## 输出格式

グリッド A をグリッド B に一致させることが不可能な場合は `-1` を、可能な場合はグリッド A をグリッド B に一致させるために行う操作回数の最小値を出力せよ。

## 样例 #1

### 样例输入 #1

```
4 5
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
1 3 2 5 4
11 13 12 15 14
6 8 7 10 9
16 18 17 20 19
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
2 2
1 1
1 1
1 1
1 1000000000
```

### 样例输出 #2

```
-1
```

## 样例 #3

### 样例输入 #3

```
3 3
8 1 6
3 5 7
4 9 2
8 1 6
3 5 7
4 9 2
```

### 样例输出 #3

```
0
```

## 样例 #4

### 样例输入 #4

```
5 5
710511029 136397527 763027379 644706927 447672230
979861204 57882493 442931589 951053644 152300688
43971370 126515475 962139996 541282303 834022578
312523039 506696497 664922712 414720753 304621362
325269832 191410838 286751784 732741849 806602693
806602693 732741849 286751784 191410838 325269832
304621362 414720753 664922712 506696497 312523039
834022578 541282303 962139996 126515475 43971370
152300688 951053644 442931589 57882493 979861204
447672230 644706927 763027379 136397527 710511029
```

### 样例输出 #4

```
20
```

## 提示

### 制約

- 入力される値は全て整数
- $ 2\ \leq\ H,\ W\ \leq\ 5 $
- $ 1\ \leq\ A_{i,\ j},\ B_{i,\ j}\ \leq\ 10^9 $

### Sample Explanation 1

初期状態のグリッド A の $ 4 $ 列目と $ 5 $ 列目を入れ替えると、グリッド A は下記の通りになります。 ``` 1 2 3 5 4 6 7 8 10 9 11 12 13 15 14 16 17 18 20 19 ``` 続けて、グリッド A の $ 2 $ 行目と $ 3 $ 行目を入れ替えると、グリッド A は下記の通りになります。 ``` 1 2 3 5 4 11 12 13 15 14 6 7 8 10 9 16 17 18 20 19 ``` 最後に、グリッド A の $ 2 $ 列目と $ 3 $ 列目を入れ替えると、グリッド A は下記の通りになり、グリッド B に一致します。 ``` 1 3 2 5 4 11 13 12 15 14 6 8 7 10 9 16 18 17 20 19 ``` 上に述べた $ 3 $ 回の操作でグリッド A をグリッド B に一致させることができ、 これより少ない回数の操作でグリッド A をグリッド B に一致させることはできないため、 $ 3 $ を出力します。

### Sample Explanation 2

問題文中の操作をどのように行ってもグリッド A をグリッド B に一致させることは不可能であるため `-1` を出力します。

### Sample Explanation 3

グリッド A ははじめからグリッド B に一致しています。

## 题解
我们本题的思路之一是：通过我们的暴力中的暴力来每一次枚举我们换哪一行，换那一列，然后再用我们的 map 来去重，最后检查我们得到的是不是我们想要的答案。
```
#include <bits/stdc++.h>
using namespace std;
vector<vector<int>> a,b;
int n,m;
map<vector<vector<int>>,int> mp;
int ans=0;
typedef pair<int,vector<vector<int>>> PII;
void bfs(){
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	heap.push({0,a});
	mp[a]=0;
	while(heap.size()){
		auto u=heap.top();
		heap.pop();
		vector<vector<int>> g=u.second;
		for(int i=0;i+1<n;i++){
			swap(g[i],g[i+1]);
			if(!mp.count(g)){
				mp[g]=u.first+1;
				heap.push({mp[g],g});
			}
			swap(g[i],g[i+1]);
		}
		for(int j=0;j+1<m;j++){
			for(int i=0;i<n;i++){
				swap(g[i][j],g[i][j+1]);
			}
			if(!mp.count(g)){
				mp[g]=u.first+1;
				heap.push({mp[g],g});
			}
			for(int i=0;i<n;i++){
				swap(g[i][j],g[i][j+1]);
			}	
		}
	}
}
int main(){
	cin>>n>>m;
	a.resize(n);
	b.resize(n);
	for(int i=0;i<n;i++){
		a[i].resize(m);
		for(int j=0;j<m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=0;i<n;i++){
		b[i].resize(m);
		for(int j=0;j<m;j++){
			cin>>b[i][j];
		}
	}
	bfs();
	if(mp.count(b)){
		cout<<mp[b]<<endl;
	}else{
		cout<<-1<<endl;
	}
}

```