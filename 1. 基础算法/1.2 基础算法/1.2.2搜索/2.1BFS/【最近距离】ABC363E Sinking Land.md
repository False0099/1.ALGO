# [ABC 363 E] Sinking Land

## 题面翻译

有一个面积为 $H \times W$ 的小岛，四面环海。  
该岛被分成 $H$ 行和 $W$ 列的 $1 \times 1$ 部分，从顶部起 $i$ 行和从左侧起 $j$ 列的部分（相对于当前海平面）的海拔高度为 $A_{i,j}$ 。

从现在开始，海平面每年上升 $1$ 。在这里，垂直或水平临海的地段或沉入海中的地段，其标高**不大于**海平面，将沉入海中。  

在这里，当一个断面新沉入海中时，垂直或水平相邻的标高不大于海平面的断面也会同时沉入海中，新沉入海中的断面重复这一过程。

对于每个 $i=1,2,\ldots, Y$ ，求 $i$ 年后该岛仍高于海平面的面积。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i, j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ Y $ $ A_{1,1} $ $ A_{1,2} $ $ \ldots $ $ A_{1, W} $ $ A_{2,1} $ $ A_{2,2} $ $ \ldots $ $ A_{2, W} $ $ \vdots $ $ A_{H, 1} $ $ A_{H, 2} $ $ \ldots $ $ A_{H, W} $

## 输出格式

$ Y $ 行出力せよ。 $ i $ 行目 $ (1\leq\ i\leq\ Y) $ には現在から $ i $ 年後に海に沈まず残っている島の面積を出力せよ。

## 样例 #1

### 样例输入 #1

```
3 3 5
10 2 10
3 1 4
10 5 10
```

### 样例输出 #1

```
9
7
6
5
4
```

## 样例 #2

### 样例输入 #2

```
3 5 3
2 2 3 3 3
2 1 2 1 3
2 2 3 3 3
```

### 样例输出 #2

```
15
7
0
```

## 提示

### 制約

- $ 1\leq\ H, W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i, j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i, j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 题解
本题我们考虑直接使用我们的 BFS 来进行模拟，当我们枚举到一个点的时候，我们用这一个点去把我们的所有临近的点的对应的状态进行一个更新，然后我们最后求出每一个点是什么时候沉默的，最后统计即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 6e6 + 10;
int x[maxn], y[maxn];
int cnt[maxn], sum[maxn];
int mpx[maxn], mpy[maxn];
signed main()
{
    int n, d;
    cin >> n >> d;
    for (int i = 1; i <= n; i++)
    {
        cin >> x[i] >> y[i];
        mpx[x[i] + 2000000]++, mpy[y[i] + 2000000]++;
    }
    int now = 0, l = 0, r = n, ans = 0;
    for (int i = 1; i <= n; i++)
    {
        now += abs((-(2e6 + 1)) - y[i]);
    }
    for (int i = -2e6; i <= 2e6; i++)
    {
        now += l, now -= r;
        if (now <= d)
            cnt[now]++;
        l += mpy[i + 2000000], r -= mpy[i + 2000000];
    }
    for (int i = 0; i <= d; i++)
    {
        sum[i] = sum[i - 1] + cnt[i];
    }
    now = 0, l = 0, r = n;
    for (int i = 1; i <= n; i++)
    {
        now += abs(-(2e6 + 1) - x[i]);
    }
    for (int i = -2e6; i <= 2e6; i++)
    {
        now += l, now -= r;
        if (now <= d)
            ans += sum[d - now];
        l += mpx[i + 2000000], r -= mpx[i + 2000000];
    }
    cout << ans;
    return 0;
}
```