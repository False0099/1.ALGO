今年的奥运会之后，在行星 mm-21上冰壶越来越受欢迎。但是规则和我们的有点不同。这个游戏是在一个冰游戏板上玩的，上面有一个正方形网格。他们只用一块石头。游戏的目的是让石子从起点到终点，并且移动的次数最小

图1显示了一个游戏板的例子。一些正方形格子可能被砖块占据。有两个特殊的格子，起始点和目标点，这是不占用块。一旦石头开始移动就不会停下，除非它击中砖块或飞出边界。

![](https://vj.csgrandeur.cn/dfcadffc211686655c382e9ad94bdbfe?v=1485266318)  
图1：例子（S：开始，G：目标）

石头的运动遵循以下规则：

- 开始时，石头静止起点广场上。
- 石头的运动仅限于x和y方向。禁止对角线移动。
- 当石头静止时，你可以让他向任意方向移动，除非它移动的方向上有砖块（图2（a））。
- 一旦抛出，石头不断向同一方向移动，直到下列事件之一发生：
    - 石头击中砖块（图2（b），（c））。.
        - 石头停在他击中的砖块之前
        - 被击中的砖块消失
    - 石块飞出游戏板之外。
        - 游戏结束的条件
    - 到达目标点（经过终点就算抵达）
        - 石头经过目标点游戏成功
- 不能在十步之内到达目标点则返回失败。

![](https://vj.csgrandeur.cn/725189cee19b86e1cd2410490b0dadc2?v=1485266318)  
Fig. 2: Stone movements

通过这些规则我们想知道，石头是否能够到达目标点和最少移动次数

初始配置如图1所示，石头从开始到目标需要4次移动。路线如图3所示（a）。注意当石头到达目标时，游戏版的配置如图3（b）改变。

![](https://vj.csgrandeur.cn/c657651fda754a877e0c3a2ce3a06fd7?v=1485266318)  
图3：图1的解决方案和解决之后的结果。

Input

输入是一组数据。输入结束标志为两个0。数据组的数量不超过100。

每个数据集如下展示

> _板的宽度（w）和高度（h）_  
> _游戏版的第一行_  
> ...  
> _游戏版的h-th行_

版的宽和高满足: 2 <= _w_ <= 20, 1 <= _h_ <= 20.

每行由一个空格分隔的十进制数字组成。该数字描述相应的格子的状态。

> |   |   |
> |---|---|
> |0|空|
> |1|砖块|
> |2|开始点|
> |3|目标点|

图. D-1数据如下:

> 6 6  
> 1 0 0 2 1 0  
> 1 1 0 0 0 0  
> 0 0 0 0 0 3  
> 0 0 0 0 0 0  
> 1 0 0 0 0 1  
> 0 1 1 1 1 1

Output

对于每个数据，打印一个十进制整数的行，表示从开始到目标的路径的最小移动次数。如果没有这样的路线，打印- 1。每个行不应该有这个数字以外的任何字符。

Sample Input

2 1
3 2
6 6
1 0 0 2 1 0
1 1 0 0 0 0
0 0 0 0 0 3
0 0 0 0 0 0
1 0 0 0 0 1
0 1 1 1 1 1
6 1
1 1 2 1 1
6 1
1 0 2 1 1 3
12 1
2 0 1 1 1 1 1 1 1 1 1 3
13 1
2 0 1 1 1 1 1 1 1 1 1 1 3
0 0

Sample Output

1
4
-1
4
10
-1

## 题解
我们这一题因为有要求在 10 步之内到达，所以我们可以采用我们的 BFS，而且我们这一题的**状态转移有些许的特殊**，我们的每一次转移都是转移到了我们这个方向的最顶端。

首先我们定义一个地图，0为空地、1为墙壁、2为起点、3为终点，在算法开始前，先将该起点位置保存，并将该位置置为空地，getStartFlag和getEndFlag用于提前结束寻找起点与终点循环，函数isLegal用于判断现在的情况下的棋子位置是否合法。深度优先遍历的逻辑如下：结束判断为：如果现在的起点位置正好是终点位置，那么说明现在正好是找到了最终点，那么退出；而如果此时的步数answerStep大于十或大于另设的最大阈值了，那么也退出。每次对下一步进行循环的时候，都要做一件事情=>对四个方向进行遍历，所以这里我们用一个向量数组表示我们位移的方向。那么对单一方向进行位移的过程中，我们用now对象来储存当前的位置，一直循环直到碰壁或接触到终点，碰壁则退出循环，终点则结束。退出循环后当然还要进行一次判断，判断该次位移是否只“移动了一位”，这里判断只移动了一位的原因是，在题目中不能往紧贴墙的位置击打，同时我们由于碰壁退出循环的条件是当前的map[now.x][now.y] == 1，所以若只位移了一次，说明这次的位移是“撞碎紧贴墙壁”造成的位移，所以如果是这样的话，我们就要进行下一个方向的位移阶段了。那么若是不是“撞碎紧贴墙壁”造成的位移，那么这次位移我们可以认为是OK的，我们将这里的map置为0，让start位移到这里，并减去一个单位的d向量（因为其实我们现在是在碎墙上），继续下一次的查找。每次函数退出，会将刚才的地图置为1，步数减一，视为悔步。

```cpp
1 #include <cstdio>
 2 #include <algorithm>
 3 #include <iostream>
 4 using namespace std; 5 const int maxn = 22;
 6 struct Point{ 7     int r, c; 8     Point(int r=-1, int c=-1):r(r),c(c){}
 9 };
10 Point s,t;
11 int W,H;
12 int G[maxn][maxn];
13 const int dr[] = {1,-1,0,0};
14 const int dc[] = {0,0,-1,1};
15 int ans  = 100000;
16 void dfs(int r,int c,int k){
17     if(k >= 10) return ;
18     for(int i = 0; i < 4; i++){
19         int nr = r;
20         int nc = c;
21         int is_walk = 0;
22         while(G[nr+dr[i]][nc+dc[i]]==0){//走到我们的最末端
23             is_walk=1;
24             nr+=dr[i];
25             nc+=dc[i];
26             if(nr == t.r && nc == t.c){
27                 ans = min(ans,k+1);
28                 return ;
29 }
30 }
31         if(!is_walk)continue;
32         if(G[nr+dr[i]][nc+dc[i]] == 4)continue ;
33         if(G[nr+dr[i]][nc+dc[i]] == 1){//表示我们这个点走过了
34            G[nr+dr[i]][nc+dc[i]] = 0;
35             dfs(nr,nc,k+1);
36             G[nr+dr[i]][nc+dc[i]] = 1;//表示我们这个点没走过
37 }
38 }
39 }
40 int main(){
41     while(scanf("%d%d ", &W, &H) && (W || H)){
42         ans  = 100000;
43         for(int i = 1; i <= H; i++){
44             for(int j = 1; j <= W; j++)
45                 scanf("%d",&G[i][j]);
46 }
47         for(int i = 0; i <= W+1; i++)
48             G[0][i] = 4,G[H+1][i] = 4;
49         for(int i = 0; i <= H+1; i++)
50             G[i][0] = 4,G[i][W+1] = 4;
51         for(int i = 1; i <= H; i++){
52             for(int j = 1; j <= W; j++){
53                 if(G[i][j] == 2){
54                     s = Point(i,j);
55                     G[i][j] = 0;
56 }
57                 else if (G[i][j] == 3){
58                     t = Point(i,j);
59                     G[i][j] = 0;
60 }
61 }
62 }
63         dfs(s.r,s.c,0);
64         if(ans != 100000 && ans <= 10)printf("%d\n",ans);
65         else printf("%d\n",-1);
66 }
67     return 0;
68 }
```



