# [USACO 05 DEC] Scales S

## 题目描述

约翰有一架用来称牛的体重的天平。与之配套的是 $ N \ ( 1 \leq N \leq 1000 ) $ 个已知质量的砝码（所有砝码质量的数值都在 $32$ 位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $ C \ ( 1 \leq C \leq 2^{30} ) $ 时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第 $3$ 个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## 输入格式

第 $1$ 行输入两个用空格隔开的正整数 $ N $ 和 $ C $。

第 $2$ 到 $ N+1 $ 行：每一行仅包含一个正整数，即某个砝码的质量。保证这些砝码的质量是一个不下降序列。

## 输出格式

输出一个正整数，表示用所给的砝码能称出的不压坏天平的最大质量。

## 样例 #1

### 样例输入 #1

```
3 15
1
10
20
```

### 样例输出 #1

```
11
```


## 题解
我们这一题只需要用我们的 dfs 来扩展我们的状态，
**首先，既然是求最大，那么就应该从后往前搜索，能够避免很多不必要的递归；然后，弄一个前缀和数组，显然，当 cur+b[index]即当前加上位置 i 的前缀和如果小于 max 时，就不用继续往下了，因为就算你把它们全部都选上也不会比 max 大，故是无用功，剪掉;至于 cur+fama[index]>C 则更不用说了，这应该是很容易想得到的。**



存储对象：我们所能表示的最大质量

转移方式：把堆中的所有元素给取出来，然后将 x+d, x-d 再放入我们的堆中。

判重：如果某一个质量已经出现过了，我们就跳过他。

```cpp
#include<stdio.h>

long long  b[50],max=0,fama[50];
int N,C;

void
dfs(long long cur,int index){
    if(cur+b[index]<=max)
        return ;
    max=cur<max?max:cur;         //千万要把这一句放到下面这个if的上面，，，那一天，我可能比较饿，头晕眼花，结果因为这个找了一个小时，，，
    if(index==0)
        return ;
    if(cur+fama[index]<=C)//这个加上前面的所有都不行，我们呢也不要   
    	dfs(cur+fama[index],index-1);
    dfs(cur,index-1);//大于C我们不要这个砝码

int
main(){
    int i;
    
    scanf("%d %d",&N,&C);    
    i=1;
    while(i<=N){
        scanf("%lld ",fama+i);
        if(fama[i]>C)//直接不要
            break;
        b[i]=b[i-1]+fama[i];//计算砝码的前缀和
        i++;
    }
    dfs(0,i-1);
    printf("%lld",max);
    return 0;
}
```
```
```