# [蓝桥杯 2018 国 AC] 约瑟夫环

## 题目描述

$n$ 个人的编号是 $1 \sim n$，如果他们依编号按顺时针排成一个圆圈，从编号是 $1$ 的人开始顺时针报数。

（报数是从 $1$ 报起）当报到 $k$ 的时候，这个人就退出游戏圈。下一个人重新从 $1$ 开始报数。

求最后剩下的人的编号。这就是著名的约瑟夫环问题。

本题目就是已知 $n$，$k$ 的情况下，求最后剩下的人的编号。

## 输入格式

题目的输入是一行，$2$ 个空格分开的整数 $n,k$。

## 输出格式

要求输出一个整数，表示最后剩下的人的编号。

## 样例 #1

### 样例输入 #1

```
10 3
```

### 样例输出 #1

```
4
```

## 提示

$0<n,k<10^6$。

时限 1 秒, 256 M。蓝桥杯 2018 年第九届国赛

## 题解
当 n 个人围成一圈并以 m 为步长第一次报数时，第 m 个人出列，此时就又组成了一个新的，人数为 n-1的约瑟夫环，要求 n 个人的约瑟夫环问题的解，就依赖于求 n-1个人的约瑟夫问题的解，要求 n-2个人的约瑟夫问题的解，则依赖于求 n-2个人的约瑟夫换问题的解，依次类推，直至求1个人的时候，该问题的解。

**递推公式：f(N,M)=f((N-1,M)+M)%N**

我们可以这么理解，我们先进行一轮杀人，杀掉我们的第 $m-1$ 个人后，我们的答案是多少，首先，我们不难判断，我们如果当前我们已经杀掉了我们的第 $m-1$ 个人。**我们再对我们的剩下的人进行排序，我们的最终答案，就是我们的上一轮结论在我们的重新排序之下的结果**。

由于我们进行我们的**重新排序**相当于把我们的所有元素都变成 $(x+m)\%n$，所以我们的结果也就很显然易见了，就是我们的 $f[n]=(f[n-1]+m)\%n$。


```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,k,s = 0;
    cin >> n >> k;
    for(int i = 2;i <= n;i++)
    {
        s=(s+k)%i;
    }
    cout << s+1; //答案初始下标为1
    return 0;
}
```