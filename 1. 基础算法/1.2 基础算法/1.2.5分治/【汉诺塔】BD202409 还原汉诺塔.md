汉诺塔问题是一个十分经典的问题。

即有三根杆子 $A$ , $B$ , $C$ 。 $A$ 杆上有 $n$ 个穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 $C$ 杆：

1. 每次只能移动一个圆盘
2. 大盘不能叠在小盘上面

由于汉诺塔问题最优步骤实际上是需要 $2^n-1$ 步，可以证明每一步实际上是固定的。所以小度想要知道，对于第 $k$ 步后而言，汉诺塔此时每个圆盘处于哪个杆子。

格式


输入格式：第 1 行 1 个整数 $n$ ,表示穿孔圆盘的个数；
第 2 行 1 个长度为 $n$ 的 01 字符串 $k$,表示二进制下小度想要
查询的第 $k$ 步后的汉诺塔情况。
数据范围保证 $1\leq n\leq10^5$ , $0\leq k\leq2^n-1$ 。

输出格式：输出 1 个长度为 $n$ 的字符串，字符串中仅包含 ABC 三种字符，分别代表第 $i$ 小的圆盘所在的杆子编号。

## 题解
本题我们考虑我们的汉诺塔的**具体过程**，我们有下面的步骤：
第一步：将我们的 (0, n-1)盘子从我们的起始位置移动到我们的 B 盘子
第二步：将我们的 n 盘子从我们的当前位置移动到我们的 C 位置
第三步：将我们的（0, n-1）盘子统一移动到我们的 C 位置。

这个时候，根据我们汉诺塔**输出步骤**的基本思想，我们需要设置三个变量，分别是我们的**起始位置**,**中间位置**，**结束位置**。首先不难看出，如果我们现在对应的二进制字符串为 1，那么就说明我们已经把这一个盘子移动到了对应的位置，**也就是我们已经完成了我们的第一步和第二步**，因此，我们就可以把我们的对应的答案输出出来。**并且此时我们的所有后续盘的位置都会改变**

如果我们的对应的二进制字符串都是 0，那么就说明我们的当前的位置没有发生改变，因此，我们还在进行第一步，但是这个时候，我们的终点位置就要和我们的中间位置进行交换。

因此，我们的代码就如下所示：
```
#include <bits/stdc++.h>

#define int long long

int INF=0x3f3f3f3f3f;

using namespace std;

void solve(){

    int n;

    cin>>n;

    string s;

    cin>>s;

    string ans="";

    char start,mid,end;

    if(s[0]=='1'){

        ans+='C';

        start='B';

        mid='A';

        end='C';

    }else{

        ans+='A';

        start='A';

        mid='C';

        end='B';

    }

    for(int i=1;s[i];i++){

        if(s[i]=='1'){

            ans+=end;

            swap(start,mid);

        }else{

            ans+=start;

            swap(mid,end);

        }

    }

    reverse(ans.begin(),ans.end());

    cout<<ans<<endl;

}

signed main(){

    ios::sync_with_stdio(false),cin.tie(0);

    int t;

    t=1;

    while(t--){

        solve();

    }

}
```