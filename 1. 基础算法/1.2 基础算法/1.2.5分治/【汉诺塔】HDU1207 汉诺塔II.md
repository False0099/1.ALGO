## 题目描述：
经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。有预言说，这件事完成时宇宙会在一瞬间闪电式毁灭。也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。恩，当然这个传说并不可信，如今汉诺塔更多的是作为一个玩具存在。Gardon 就收到了一个汉诺塔玩具作为生日礼物。  

Gardon 是个怕麻烦的人（恩，就是爱偷懒的人），很显然将64个圆盘逐一搬动直到所有的盘子都到达第三个柱子上很困难，所以 Gardon 决定作个小弊，他又找来了一根一模一样的柱子，通过这个柱子来更快的把所有的盘子移到第三个柱子上。下面的问题就是：当 Gardon 在一次游戏中使用了 N 个盘子时，他需要多少次移动才能把他们都移到第三个柱子上？很显然，在没有第四个柱子时，问题的解是2^N-1，但现在有了这个柱子的帮助，又该是多少呢？

## 输入：
包含多组数据，每个数据一行，是盘子的数目 N(1<=N<=64)。

## 输出：
对于每组数据，输出一个数，到达目标需要的最少的移动数。

## 题解：
我们本题可以通过我们的**变形汉诺塔**，也就是我们的**多圆盘汉诺塔**，我们采用我们的 `Frame-Stewart` 算法来进行处理。我们的 `Frame-Stewart` 的思路是：
第一步：先把我们的最上面的 K 个移动到我们的中间位置，我们记为。
第二步：我们再把我们的剩下的 $n-K$ 的移动到我们的最后的 C 位置，
第三步：我们再把我们的中间位置的元素移动到我们的最后的位置。

综上，我们可以写出我们的转移方程：$g[n]=min\{2*g[k]+f[n-k]\}$。其中，我们的 $g[n]$ 表示我们四塔情况下我们的结果，我们的 $f[n]$ 表示我们在三塔情况下我们的最终结果。

于是，我们就可以得到我们的最后的结果如下：
```
#include<iostream>

#include<cstdio>

#include<cstring>

#include<cmath>

#define int long long

int INF=0x3f3f3f3f3f;

using namespace std;

const int N=100;

int g[N];

void init(){

    memset(g,INF,sizeof g);

    g[1]=1;

    g[2]=3;

    for(int i=3;i<=64;i++){

        int minn=INF;

        for(int k=1;k<i;k++){

            if(g[k]*2+pow(2.0,i-k)-1<g[i]){

                g[i]=g[k]*2+pow(2.0,i-k)-1;

            }

        }

    }

}

void solve(){

    int n;

    while(~scanf("%d",&n)){

        cout<<g[n]<<endl;

    }

}

signed main(){

    //ios::sync_with_stdio(false),cin.tie(0);

    int t;

    init();

    t=1;

    while(t--){

        solve();

    }

}
```