给你一个下标从 **0** 开始、大小为 `n * m` 的二维整数矩阵 `grid` ，定义一个下标从 **0** 开始、大小为 `n * m` 的的二维矩阵 `p`。如果满足以下条件，则称 `p` 为 `grid` 的 **乘积矩阵** ：

- 对于每个元素 `p[i][j]` ，它的值等于除了 `grid[i][j]` 外所有元素的乘积。乘积对 `12345` 取余数。

返回 `grid` 的乘积矩阵。

**示例 1：**

**输入：**grid = [[1,2],[3,4]]
**输出：**[[24,12],[8,6]]
**解释：$**p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24$
$p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12$
$p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8$
$p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6$
所以答案是 [[24,12],[8,6]] 。

**示例 2：**

**输入：**grid = [[12345],[2],[1]]
**输出：**[[2],[0],[0]]
**解释：**p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2
p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0 ，所以 p[0][1] = 0
p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0 ，所以 p[0][2] = 0
所以答案是 [[2],[0],[0]] 。

**提示：**

- `1 <= n == grid.length <= 105`
- `1 <= m == grid[i].length <= 105`
- `2 <= n * m <= 105`
- `1 <= grid[i][j] <= 109`

## 题解
我们考虑一维上的做法，在一维上，我们想要求出一个数组除了自己以外的所有数的乘积，并且我们不使用除法，因为我们这一题中有一个取模运算，如果运用除法，我们就要用我们的逆元，这个的计算是相当麻烦的。
于是我们可以考虑维护每一个位置的前缀和后缀。然后我们每一个数的乘积就是这个位置的前缀乘以后缀再取模。这样，我们就可以有一个 $o(n^2)$ 的暴力做法。我们先计算出 $suf[i][j]$,即从 $grid[i][j]$ 的下一个元素开始，到最后一个元素 $grid[n-1][m-1]$ 的乘积，记作 $suf[i][j]$。这可以从最后一行最后一列倒着遍历得到。

另外我们在计算出我们从第一个元素开始，乘到 $grid[i][j]$ 的上一个元素的乘积，记作 $p\mathrm{Re}[i][j]$ 这个我们可以正序遍历得到，那么我们的 $p[i][j]=p\mathrm{Re}i[i][j]\times suf[i][j]$ .

```cpp
class Solution {
public:
    vector<vector<int>> constructProductMatrix(vector<vector<int>> &grid) {
       const int MOD=12345;
       long long suf=1;
    	vector<vector<int>> p(n, vector<int>(m));
       for(int i=0;i<grid.size();i++){
       		for(int j=0;j<grid.size();j++){
       			p[i][j]=suf;
       			suf=(suf%MOD*grid[i][j]%MOD)%MOD;
			}
	   }
	   long long pre=1;
	   for(int i=grid.size()-1;i>=0;i--){
	   		for(int j=grid.size();j>=0;j--){
	   				p[i][j]=p[i][j]*pre%MOD;
	   				pre=pre*grid[i][j]%MOD;
			   }
	   }
	   return p;
};


```