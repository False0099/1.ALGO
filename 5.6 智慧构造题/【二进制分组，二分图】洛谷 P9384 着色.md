# [THUPC 2023 决赛] 着色

## 题目背景

远古的笔迹，远古的乐音，远古的历史，远古的 $K_{1000}$，若无人问津，便悄然褪色……

## 题目描述

给出一个 $n$ 个节点的无向完全图，你需要给每条边标上一个 $0 \sim 9$ 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。

## 输入格式

输入仅一行一个整数 $n$ 表示图的节点数。

## 输出格式

如果不存在方案，输出一行一个整数 `-1`。否则输出 $(n-1)$ 行，第 $i$ 行 $(n-i)$ 个字符，第 $i$ 行的第 $j$ 个字符表示 $(i,i+j)$ 的标号。若有多个方案，输出任意一个即可。

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
012
34
5
```

## 提示

### 数据规模与约定

对于所有测试数据，$2 \le n \le 1000$。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC 2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 题解
不存在三元环或五元环颜色相同看起来很诈骗，不妨加强一下问题，使得不存在奇环颜色相同。那么在这种条件下，我们的每一种颜色都会构成一个二分图，这里是因为我们的二分图定义：
二分图定义：**一定不含有奇数环**，可能包含长度为偶数的环，不一定是连通图，且将所有点分成两个集合，所有边只出现在集合之间，就是二分图。

又发现颜色数 10，又有 $2^{10}=1024>1000$ 。因此，我们可以自然地想到使用二进制位为 0 或为 1 作为划分左、右的依据。

我们的想法就是让每一个颜色对应一个二进制位，当那个二进制位不同的两个点才有可能染出这种颜色。于是我们就可以按照边的 $lowbit$ 来分类，

这里，我们于是就可以用我们边对应的两个点异或的结果的最低位是多少来决定我们这一条边的染色结果。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int lowbit(int x) {
	return x & (-x);
}
int tz[1024];
int main() {
	cin >> n;
	for(int j = 0; j < 10; j++) {
		tz[(1 << j)] = j;
	}
	for(int i = 1; i < n; i++) {
		for(int j = i + 1; j <= n; j++) {
			cout << (char)('0' + tz[lowbit(i ^ j)]);
		}
		cout << endl;
	}
	return 0;
}
```