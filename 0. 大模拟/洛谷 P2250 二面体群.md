# 二面体群

## 题目描述

考虑在一个单位圆周上的 $n$ 个点，$n$ 个点的标号为 $K=0,1,\ldots,n-1$。初始的时候 $K$ 相对于 X 轴的角度为 $\dfrac{360 \times k}{n}$ 度，这里的角度是相对于 X 轴的逆时针角度。我们将在这组点上运行 2 种不同类型的操作：

1. 顺时针旋转 $\dfrac{360}{n}$ 度
2. 相对于 X 轴的映射

对于给定的操作序列，如果结果相同，我们只对最短的操作序列感兴趣。结果相同是指对于不同的操作序列，最后的操作结果中每一个单一点的位置都是一样的。

操作序列以字符串的形式给出，该字符串中只含有字母 `r` 和 `m`。`r` 代表顺时针旋转，`m` 代表单独映射（到右边并且对称）。字符串中如果有多个字母连续出现要简写成 `<字母><数字>` 的形式，为了方便起见，字母如果单独出现也写成这种形式。如 `rrmrrrrrrrrrrrr` 可以写成 `r2 m1 r12`，每个操作序列一行。

## 输入格式

输入共两行。

第一行一个数 $N$，表示圆周上点的个数。

第二行为按上面的方式缩写的操作序列，所有的数字都是正整数，并且小于 $10^8$ 。在输入文件中没有空行，并且每一行的字符个数都小于 $10^5$。

## 输出格式

输出最短操作序列。若无需操作则什么都不输出。

## 样例 #1

### 样例输入 #1

```
54
r218 m3 r1
```

### 样例输出 #1

```
r1 m1
```

## 提示

$100\%$ 的数据满足 $3 \leq N \leq 10^8$。

## 题解
我们本题的思路是：通过模拟得出我们的最终位置在哪里，最后在计算我们从 0 点开始到达这个位置所需要的最小时间是多少。

一些小细节：
1. 我们为了方便我们的计算，我们可以把我们的实际 $n$ 设置为只有原来的一半，然后再用我们的-1，+1 表示我们在哪一个半区

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,t=1,a=0;
char c;
inline void init()	//第一部分 读入
{
	scanf("%d\n",&n),c=getchar();	//读入第一行的数以及第二行的第一个字符。
	while(1)	//一直循环
	{
		while(c!='\n'&&c!=EOF&&c!='r'&&c!='m') c=getchar();		//这里有锅，见下一行
		if(c=='\n'||c==EOF) break;		//数据有锅，如果这里没有EOF的话亲测最后一个点会TLE。
		scanf("%d",&x);		//读入操作数据
		if(c=='r') (a+=t*x%n)%=n;	//旋转操作直接模拟，要加上翻转操作中的顺逆时针，这条语句相当于a=(a+t*x%n)%n;
		if(c=='m') t=(x&1)?-t:t;	//翻转操作，记录下来有多少次翻转（奇数是-1，偶数是1）
		c=getchar();	//继续读
	}
	(a+=n)%=n;	//防止a<0
}
inline void out()
{
	if(n+1-a-t<a) printf("m1 r%d ",n-a),t=-t;	//这个特判也卡了我半天QwQ，特判语句我试了半天
//	1-t表示先翻转（可能之后的翻转不需要，或者之后多出来一次翻转），n-a表示翻转之后顺时针旋转。然后t要取反
	else if(a) printf("r%d ",a);	//如果a=0，就不需要输出了。
	if(t==-1) printf("m1 ");	//如果还有一次
	puts("");	//个人强迫症
}
int main()
{
	return init(),out(),0;	//完美主程序结束
}

```