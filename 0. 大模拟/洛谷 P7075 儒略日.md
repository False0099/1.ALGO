#暴力模拟 #公历时间计算

# [CSP-S 2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 输入格式

第一行一个整数 $Q$，表示询问的组数。  
接下来 $Q$ 行，每行一个非负整数 $r_i$，表示一个儒略日。

## 输出格式

对于每一个儒略日 $r_i$，输出一行表示日期的字符串 $s_i$。共计 $Q$ 行。 $s_i$ 的格式如下：

1. 若年份为公元后，输出格式为 `Day Month Year`。其中日（Day）、月（Month）、年（Year）均不含前导零，中间用一个空格隔开。例如：公元
2020 年 11 月 7 日正午 12 点，输出为 `7 11 2020`。
2. 若年份为公元前，输出格式为 `Day Month Year BC`。其中年（Year）输出该年份的数值，其余与公元后相同。例如：公元前 841 年 2 月 1 日正午 12
点，输出为 `1 2 841 BC`。

## 样例 #1

### 样例输入 #1

```
3
10
100
1000
```

### 样例输出 #1

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC
```

## 样例 #2

### 样例输入 #2

```
3
2000000
3000000
4000000
```

### 样例输出 #2

```
14 9 763
15 8 3501
12 7 6239
```

## 样例 #3

### 样例输入 #3

```
见附件中的 julian/julian3.in
```

### 样例输出 #3

```
见附件中的 julian/julian3.ans
```

## 提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |


## 题解
考虑将时间划分为如下一些段：

$[0,1721423],[1721424,2299160],[2299161,2299238],[2299239,2299603],[2299604,2305447],[2305448,+∞][0,1721423]$
分别对应公元前，公元 1 年 ~ 1582.10.5，1582.10.14 ~ 1582 年末，1583 年，1584 年 ~ 1599 年，1600 年以后六个时间段。

接下来考虑处理出两个表 d1​ 和 d2​，其中 d1,k​ 和 d2,k​ 分别代表平年和闰年时候距离本年 1 月 1 日 k 天是几月几日。

还需要说明几个常量：儒略历中一个整四年有 1461 天，格里高利历中一个整 400 年共有 146097 天。其中除了那个第一年能被 400 整除的世纪有 36525 天之外，别的三个世纪都只有 36524 天。

首先考虑公元前的情况，这个时候每四年是第一年闰。那么先判断出这一年是在哪一个四年中，然后看看这一年是闰年还是平年并算出实际的年数以及到本年 1 月 1 日多少天，最后查表。

接下来是公元后继续实行儒略历的情况。先扣除 1721424 代表这个日期离公元 1 年 1 月 1 日有多少天。接下来跟公元前情况类似，只不过每四年是最后一年闰了。

再接下来是 1582 年实行格里高利历后的情况。注意到 �1,287d1,287​ 为 10 月 15 日，所以扣除 22991612299161 表示这个日期离 1582 年 10 月 15 日有多少天，最后查表。1583 年一年可以直接查表。

对于 1584 年 ~ 1599 年的情况来说，扣除掉 1584 年 1 月 1 日的儒略日之后，发现还是第一年闰，只不过起始年份变成了 1584 而不是 -4713，套公元前的做法即可。

对于 1600 年及以后的话，先算出这个到底是在第几个四百年中，然后再算到底是在第几个世纪中，接下来推算出具体年份和距离本年 1 月 1 日有多少天，最后查表即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int q,n,rsum,month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
void count_date(int year,int k,int r){
	if(r==1)month[2]++;
	int qwq=0,mth;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			if(year-4713<0)printf("%lld %lld %lld BC\n",k,mth,4713-year);
			else printf("%lld %lld %lld\n",k,mth,year-4712);
			break;
		}
	}
	if(r==1)month[2]--;
}//儒略历时代的count_date
void count_date2(int year,int k,int r){
	if(r==1)month[2]++;
	int qwq=0,mth,f=0;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			printf("%lld %lld %lld\n",k,mth,year+1600);
			f=1;
			break;
		}
	}
	if(f==0)printf("1 1 %lld\n",year+1601);
	if(r==1)month[2]--;
}//格里高利历时代的count_date
signed main(){
	//freopen("julian.in","r",stdin);
	//freopen("julian.out","w",stdout);
	for(int i=1;i<=400;i++)
		if((i%4==0&&i%100!=0)||i%400==0)rsum++;
	scanf("%lld",&q);
	while(q--){
		scanf("%lld",&n);
		if(n<=2299160){
			int k=n%(365*4+1),year=n/(365*4+1)*4,r=1;
			if(k>=366)k-=365,year++,r=0;
			if(k>=366)k-=365,year++;
			if(k>=366)k-=365,year++;
			if(r==1)k++;
			count_date(year,k,r);
		}//儒略历时代
		else {
			n+=10;//完美跳过不存在的那几天
			if(n<=2305457){
				int k=n%(365*4+1),year=n/(365*4+1)*4,r=1;
				if(k>=366)k-=365,year++,r=0;
				if(k>=366)k-=365,year++;
				if(k>=366)k-=365,year++;
				if(r==1)k++;
				count_date(year,k,r);
			}//特判的那几年
			else{
				n-=2305458;
				int k=n%(365*400+rsum),year=n/(365*400+rsum)*400,r=1;
				if(k>=366)k-=365,year++,r=0;
				for(int i=2;i<=399;i++){
					if(i%4==0&&i%100!=0){
						if(k>=367)k-=366,year++,r=1;
						else break;
					}
					else{
						if(k>=366)k-=365,year++,r=0;
						else break;
					}
				}
				if(r==1)k++;
				count_date2(year,k,r);
			}//格里高利历时代
		}
	}
	return 0;
}
```