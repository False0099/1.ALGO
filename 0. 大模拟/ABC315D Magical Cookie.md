# [ABC 315 D] Magical Cookies

## 题面翻译

给出 $H \times W$ 的地图，不断进行以下操作：

1. 选定某行，若这行字母数 $\ge 2$，并且全是相同的，将其标记。

1. 选定某列，若这列字母数 $\ge 2$，并且全是相同的，将其标记。

1. 把目前标记删除，若无删除，结束操作，否则重新跳回操作 1。

$1 \le H,W \le 2000$。

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_d

$ H\ \times\ W $ 枚のクッキーが $ H $ 行 $ W $ 列に並んでいます。  
上から $ i $ 行目・左から $ j $ 列目のクッキーの色は英小文字 $ c_{i, j} $ で表されます。

これから、以下の手続きを行います。

1\. 各行に対して次の操作を行う : その行に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

2\. 各列に対して次の操作を行う : その列に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

3\. 印のついたクッキーがあればそれらをすべて取り除いて 1. に戻り、なければ手続きを終了する。

手続きを終了した時点で残っているクッキーの枚数を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

 $ H $ $ W $ $ c_{1,1} $$ c_{1,2} $ $ \ldots $ $ c_{1,W} $ $ c_{2,1} $$ c_{2,2} $ $ \ldots $ $ c_{2, W} $ $ \vdots $ $ c_{H, 1} $$ c_{H,2} $ $ \ldots $ $ c_{H,W} $$

## 输出格式
 
答えを出力せよ。

## 样例 #1

### 样例输入 #1

```
4 3
aaa
aaa
abc
abd
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
2 5
aaaaa
abcde
```

### 样例输出 #2

```
4
```

## 样例 #3

### 样例输入 #3

```
3 3
ooo
ooo
ooo
```

### 样例输出 #3

```
0
```

## 提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ c_{i,j} $ は英小文字である

### Sample Explanation 1

以下で示す順で手続きを行います。 - 1. により、$ 1,\ 2 $ 行目のクッキーに印をつける。 - 2. により、$ 1 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... .bc .bd ``` - 1. により、何もしない。 - 2. により、$ 2 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... ..c ..d ``` - 1. により、何もしない。 - 2. により、何もしない。 - 3. により、印がついているクッキーが存在しないので手続きを終了する。最終的に残っているクッキーの枚数は $ 2 $ 枚です。

## 题解
我们这一题就是带优化的大模拟，我们并没有很好的方法来决定我们怎么办，我们就只能暴力枚举我们要删除哪些行和哪些列，这里我们需要用一个桶来统计我们的对应个数是多少。
```cpp
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2050;
int n, m, st1[maxn][26], st2[maxn][26];
char mp[maxn][maxn];
bool vis1[maxn], vis2[maxn];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> mp[i][j];
		}
		for (int j = 1; j <= m; j++) {
			st1[i][mp[i][j] - 'a']++;
			st2[j][mp[i][j] - 'a']++;
		}
	}
	while(1) {
		vector<int> r, c;
		for (int i = 1; i <= n; i++) {
			if (!vis1[i]) {//如果这一行没有被删除
				int cnt = 0, tot = 0;
				for (int j = 0; j <26;j++) {
					cnt += st1[i][j] > 0;//统计种类
					tot += st1[i][j];//统计我们的数量
				}
				if (cnt == 1 && tot > 1) {//找到我们要删的
					r.push_back(i);
				}
			}
		}
		for (int i = 1; i <= m; i++) {
			if (!vis2[i]) {
				int cnt = 0, tot = 0;
				for (int j = 0; j < 26; j++) {
					cnt += st2[i][j] > 0;
					tot += st2[i][j];
				}
				if (cnt == 1 && tot > 1) {//找到我们的应该删除的列
					c.push_back(i);
				}
			}
		}
		for (int x : r) {
			vis1[x] = 1;
			for (int j = 1; j <= m; j++) {
				if (mp[x][j] != '.') {
					st1[x][mp[x][j] - 'a']--;
					st2[j][mp[x][j] - 'a']--;
				}
				mp[x][j] = '.';
			}
		}
		for (int x : c) {
			vis2[x] = 1;
			for (int j = 1; j <= n; j++) {
				if (mp[j][x] != '.') {
					st1[j][mp[j][x] - 'a']--;
					st2[x][mp[j][x] - 'a']--;
				}
				mp[j][x] = '.';
			}
		}
		if (!r.size() && !c.size()) {
			break;
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			ans += (mp[i][j] != '.');
		}
	}
	cout << ans << "\n";
	return 0;
}
```
```