# [POI 2000] 病毒

## 题目描述

二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。

示例：

例如如果 $\{011, 11, 00000\}$ 为病毒代码段，那么一个可能的无限长安全代码就是 $010101 \ldots$。如果 $\{01, 11, 000000\}$ 为病毒代码段，那么就不存在一个无限长的安全代码。

现在给出所有的病毒代码段，判断是否存在无限长的安全代码。

## 输入格式

第一行包括一个整数 $n$，表示病毒代码段的数目。

以下的 $n$ 行每一行都包括一个非空的 $01$ 字符串，代表一个病毒代码段。

## 输出格式

如果存在无限长的安全代码，输出 `TAK`，否则输出 `NIE`。

## 样例 #1

### 样例输入 #1

```
3
01 
11 
00000
```

### 样例输出 #1

```
NIE
```

## 提示

$1 \leq n \leq 2000$，所有病毒代码段的总长度不超过 $3 \times 10^4$。

## 题解
非法点的定义：1. **原本就是病毒代码串的节点**。2. 病毒串的**后继节点**也是非法点。

因为要有无限长的可行串，我们就可以等价于在一个有向图里找环，我们用 dfs 来实现

总结一下：我们从原点出发，不走非法点，看能不能找到一个环，找到就是 true，找不到就是 false。

```cpp
#include<cstdio>
#include<cstdlib>
const int N=33333;
short c[N][2],f[N],q[N];//没错short
bool e[N],vis[N],inst[N];
char s[N];
void dfs(short u)
{
	if(inst[u])puts("TAK"),exit(0);//找到啦，直接拜拜
	if(vis[u]||e[u])return;//走不通
	inst[u]=vis[u]=1;
	dfs(c[u][0]);
	dfs(c[u][1]);
	inst[u]=0;//两个标记意义不同，这个记得搜完清0
}
int main()
{
	fread(s,1,N,stdin);
	short n,i,u,v,cnt=0,h=0,t=0;
	char*p=s;
	n=*p&15;
	while(*++p>' ')n*=10,n+=*p&15;
    //建自动机
	while(n--)
	{
		while(*++p<=' ');
		for(u=0;*p>' ';++p)
		{
			if(!c[u][i=*p&1])c[u][i]=++cnt;
			u=c[u][i];
		}
		e[u]=1;//标记危险节点（这时还没把所有的危险节点都找出来）
	}
    //处理fail以及危险节点
	if(c[0][0])q[++t]=c[0][0];
	if(c[0][1])q[++t]=c[0][1];
	while(h<t)
	{
		u=q[++h];
		for(i=0;i<=1;++i)
			if((v=c[u][i]))f[q[++t]=v]=c[f[u]][i],e[v]|=e[f[v]];
            //这时候才都找出来了
			else c[u][i]=c[f[u]][i];//直接改空儿子，方便失配处理
	}
	dfs(0);
	puts("NIE");//这时全搜遍了还没找到
	return 0;
}
```