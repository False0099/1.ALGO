## 题目描述
字符集中有一些字符（最多 26 个），再给出一个字串 B，长为 M。
求：任给一个长度为 N 的字符串 A（只包含字符集中的字符），使 B 是 A 的子串的方案数。
N<=100;

$dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*$

## 样例 #1

### 样例输入 #1

```

```

### 样例输出 #1

```

```

## 题解
对于这一类生成子串的问题，我们的想法就是用我们的“状态机”，而我们状态机的预处理就需要用到我们的 `KMP` 算法，我们用我们的 `KMP` 算法，先预处理出我们从状态 `j` 转移到我们的状态 `i` 一共有多少种情况，然后再枚举我们的上一位字符可能的方案。最后相乘就是我们的答案。

**想象一边生成字符串 A，一边用 KMP 匹配到字符串 B 的过程**。

$f[i][j]$ 表示生成到第 i 位，此时 B 串匹配到第 j 位的方案。
枚举下一位生成字符 c，计算出 KMP 匹配指针应该移动到 $j_{1}$,我们进行转移**如果匹配成功**，那么我们由
$f[i+1][j_{1}]+=f[i][j]$,**否则**
记 $g[j][j_{1}]$ 为从 $f[i][j]$ 转移到 $f[i+1][j_{1}]$ 的方案数：
$f[i+1][j_{1}]=\sum f[i][j]*g[j][j_{1}]$

我们的每一次转移都可以写成类似于矩阵的形式，所以我们可以用矩阵快速幂加快我们的递推。


注意: 如果我们的 j=M，我们是不进行转移的，这样就能说明我们的结果中是含有 M 的，便于我们统计答案。也就是哪一行的 G 数组全都为 0.
而我们的 g 数组可以通过我们的 kmp 算法来进行预处理。


我们的答案就是 $\sum dp[i][m]$
## 代码
```cpp

```