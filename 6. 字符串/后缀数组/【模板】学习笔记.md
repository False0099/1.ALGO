## 定义：
1. 后缀
记 $suf(k)$,表示我们 $s(\mathbf{k}..,n)$ 所构成的子串，而在我们的后缀中有一个性质：**任意一个子串都是某个后缀的前缀**。

2. 最长公共前缀：
记 $lcp(s_{1},s_{2})$ 表示我们子串 $s_{1}$ 和字符串 $s_{2}$ 的最长公共前缀，例如：`s1=aabba,s2=aabbc`,那么我们的 $lcp(s_{1},s_{2})=4$。在我们的后缀数组中，我们通常都是要求我们某两个后缀的 lcp 是多少。


## 求出后缀排序：
1. 将我们的所有后缀按照我们的字典序从小到大排序：
方法一：暴力 sort, 时间复杂度为： $o(n^2\log n)$

方法二：二分我们的哈希值求出我们两个后缀数组的最长公共前缀，然后再比较最长公共前缀的后一位 $o(n\log^2n)$

排序后，我们可以得到下面几个数组：
1. `startpos[l]` 表示我们排序第 $l$ 的后缀的开始位置是多少，例如：在我们的字符串 `aabaaaab` 中，我们的 $sa[1]=4\ (aaaab)$, $sa[2]=5\ (aaab)$, $sa[3]=6 \ (aab)$, $sa[4]=1 (aabaaaab)$, $sa[5]=7 \ (ab)$, $sa[6]=2 \ (abaaab)$, $sa[7]=8 \ (b)$, $sa[8]=3 (baaaab)$

2. `rank[i]` 表示我们后缀 $suf[i]$ 的排名是多少

3. 对于上面两个数组，我们存在关系：`startpos[rank[i]]=i,rank[startpos[l]]=l`

方法三：倍增，我们记 `sub[i][k]` 表示我们从 $i$ 开始长度为 $2^k$ 的子串，
那么我们就有下面的性质 `rank[i][k]=sub[i][k]在长度为2^k的所有子串中的排名`， `startpos[i][k]` 表示在长度等于 $2^k$ 的所有子串中排名第 `i` 的子串所在的位置。

我们的转移就有：
我们先求出我们的 $sub[1][0],sub[2][0],\dots,sub[N][0]$,
之后我们再求出我们的 $sub[1][1],sub[2][1],\dots sub[N][1]$
最后，我们求出我们的 $sub[1][k],\dots sub[N][k]$,其中我们的 K
要满足：$2^k\geq N$,这个时候，我们的子串排序就是我们的后缀排序，

考虑对于我们的 $k$ 进行递推，首先我们有 $sub[i][k]$,那么如果我们想要比较我们的 $sub[i][k+1]$ 和我们的 $sub[j][k+1]$,那么我们就可以先比较我们的 $sub[i][k],sub[j][k]$,如果相同，我们再去比较我们的 $sub[i+2^k][k],sub[j+2^k][k]$,也就相当于我们对一个二元组 `rank[i][k],rank[i+2^k][k]` 作为我们的元素来进行比较。

如果我们采用的是我们的 sort 方法来实现，我们的最后复杂度仍然是 $o(n\log^2n)$ 的。但是如果我们采用基数排序，我们就能缩减到我们的 $o(n\log n)$

## 求后缀 lcp
利用我们的排序好的后缀数组，我们就可以求出任意两个后缀的 $lcp$ 长度是多少。但是注意，我们的这一个后缀数组是可以进行扩展的，也就是说，**只要我们给定的字符串数组是有序的**，那么我们就一定可以通过我们的 height 方法来得到我们的任意两个数组之间的 height。

我们记 $height[l]$ 表示我们排名第 $l-1$ 的后缀和排名第 $l$ 的后缀的 lcp 长度。根据我们的定义，我们就有：`height[l]=lcp(startpos[l-1],startpos[l])`,

那么我们 $i$ 和 $j$ 的后缀$lcp(suf(i),suf(j))=min(height[l+1],\dots height[r])$,其中我们的 $l$ ,r 表示我们两个后缀的排名范围。

关于我们的 height 数组，我们的一个思路是采用我们的 $o(n^2)$ 计算. 
```cpp
for i in range(1,N):
	l=rank[i]
	j=sa[l-1];
	k=0;
	while(s[i+k]==s[j+k]){
		++k
	}
	height[l]=k;
```

另一种思路是：利用我们的 height 数组的性质，我们考虑按照排名的顺序来求解 `height` 数组，假设我们现在排名第 $i$ 的对应位置是 $l$,排名为 $i+1$ 的对应位置是 $r$,那么我们一定有如下性质：
$height[l]\geq height[r]-1$
也就是说，我们的 $height[r]\leq height[l]+1$,因为我们每一次如果我们向前延伸了一个，我们的最多就是添加了一个，最坏就是保持我们的不变。
之后，我们只需要用我们的原结论优化我们的暴力即可。最后得到的复杂度是线性的。
```cpp
void height_get(int *r,int n) {
//r为字符串原串，n为字符串长度。
//此处的字符串为添加最小元素后的字符串。
    int k=0;
    for (int i=0;i<n;++i)rank[sa[i]]=i;
    for (int i=0;i<n;++i)
    {
        if (k)k--;
        int j=sa[rank[i]-1];
        while (r[i+k]==r[j+k])k++;
        height[rank[i]]=k;
    }
}//求最长公共前缀,利用h[i]>=h[i-1]-1
```